<package>
<job id="winconfigure">
    <runtime>
        <description>This script generates files for building MPICH2</description>
        <unnamed
            name = "--force"
            helpstring = "Force the creation of new files, overwriting the old"
            required = "false"
        />
        <unnamed
            name = "--force=no"
            helpstring = "Only create files that do not already exist"
            required = "false"
        />
        <unnamed
            name = "--enable-timer-type=x86cycle"
            helpstring = "Use the Pentium rdtsc instruction for timing"
            required = "false"
        />
        <unnamed
            name = "--enable-timer-type=queryperformancecounter"
            helpstring = "Use QueryPerformanceCounter for timing"
            required = "false"
        />
<!--        <unnamed
			name = "--with-mcxx"
			helpstring = "Generate the managed C++ interface"
			required = "false"
		/>
-->
		<unnamed
			name = "--defmsg"
			helpstring = "Generate defmsg.h"
			required = "false"
		/>
		<unnamed
			name = "--genstates"
			helpstring = "Generate mpiallstates.h and describe_states.c"
			required = "false"
		/>
		<unnamed
			name = "--mpicc"
			helpstring = "Generate mpicc.wsf"
			required = "false"
		/>
		<unnamed
			name = "--ifaces"
			helpstring = "Generate the interfaces (c++,f77,f90,etc)"
			required = "false"
		/>
		<unnamed
			name = "--remove-fortran"
			helpstring = "Remove fortran code and interfaces"
			required = "false"
		/>
		<unnamed
			name = "--use-ib-rdma"
			helpstring = "Use the rdma interface in the infiniband channel"
			required = "false"
		/>
		<unnamed
			name = "--cleancode"
			helpstring = "Clean up the c++ header file"
			required = "false"
		/>
		<unnamed
			name = "--dlldec"
			helpstring = "Add dll decoration to the mpi function prototypes"
			required = "false"
		/>
		<unnamed
			name = "--testdir"
			helpstring = "Configure the test directory only"
			require = "false"
		/>
		<unnamed
			name = "--gen-mpi"
			helpstring = "Generate the stub MPI functions"
			require = "false"
		/>
<!--
		<unnamed
			name = "--vs05"
			helpstring = "apply settings to the Visual Studio 2005 project files"
			require = "false"
		/>
-->
		<unnamed
			name = "--genbuild"
			helpstring = "generate a build script and nmake file"
			require = "false"
		/>
		<unnamed
			name = "--genbuildfiles"
			helpstring = "generate the DIRS, SOURCES, etc files necessary for the build tool"
			require = "false"
		/>
		<unnamed
			name = "--rmbuildfiles"
			helpstring = "delete the DIRS, SOURCES, etc files created by --genbuildfiles"
			require = "false"
		/>
<!--
		<named
			name = "channel"
			helpstring = "specify the channel for --genbuildfiles (sock,nemesis)"
			type = "string"
			require = "false"
		/>
-->
		<named
			name = "channel"
			helpstring = "specify the channel for --genbuildfiles (sock,nemesis)"
			type = "string"
			require = "false"
		/>
		<unnamed
			name = "--smpd_version"
			helpstring = "update the smpd version in smpd.h"
			require = "false"
		/>
		<unnamed
			name = "--ia64"
			helpstring = "use definitions for Win64 IA64 instead of X64"
			require = "false"
		/>
		<unnamed
			name = "--verbose"
			helpstring = "Use verbose option for verbose output"
			require = "false"
		/>
        <example>Example: winconfigure.wsf --cleancode</example>
    </runtime>
<script language="VBScript">

' check if we are running cscript or wscript
isCScript = false
If InStr(1, LCase(WScript.FullName), "cscript") > 0 Then
	isCscript = true
End If

' Use cEcho to echo information to the command line only.
' The output is truncated to 4096 characters.
Function cEcho(str)
	On Error Resume Next
	WScript.Echo str
	if err <> 0 then
		num_chars = Len(str) / 2
		if num_chars > 4096 then
			num_chars = 4096
		end if
		WScript.Echo Left(str, num_chars) & vbCrLf & "..." & vbCrLf
		WScript.Echo Right(str, num_chars)
	end if
End Function

wEchoMsgBoxStr=""
Function wEcho(str)
	wEchoMsgBoxStr = wEchoMsgBoxStr & str & vbCrLf
End Function

Function wEchoFlush()
	MsgBox wEchoMsgBoxStr
End Function

Function gEcho(str)
	If isCscript Then
		cEcho(str)
	Else
		wEcho(str)
	End If
End Function

' print Error msgs with ERROR - output by default
echoErrorMsgs = true
' print status msgs with STATUS - output by default
echoStatusMsgs = true
' print debug & non-status msgs with VERBOSE - suppressed by default
' use "--verbose" option to enable
echoVerboseMsgs = false

Function printMsgFlush()
	If(Not isCscript) Then
		wEchoFlush()
	End If
End Function

Function printMsg(level, str)
	Select Case level
		Case "ERROR"
			If echoErrorMsgs Then
				gEcho(str)
			End If
		Case "STATUS"
			If echoStatusMsgs Then
				gEcho(str)
			End If
		Case "VERBOSE"
			If echoVerboseMsgs Then
				gEcho(str)
			End If
		Case Else
			WScript.Echo "ERROR: INVALID USAGE OF PRINTMSG"
	End Select	
End Function

printMsg "STATUS", "Configuring MPICH2 for windows..."

x64 = True
bVS2005 = False
bUseIbRDMA = False
bUsePinCache = False
bRemoveFortran = False
bUseCycleCounter = False
bForce = True
bCleanCode = False
bAddDllDecoration = False
bMcxx = False
bf77_name_lower = False
bf77_name_lower_uscore = False
bf77_name_lower_2uscore = False
bf77_name_upper = False
bf77_name_mixed = False
bf77_name_mixed_uscore = False
unhandled_definitions = ""
unhandled_definitions_count = 0
unhandled_definitions_instances = 0
unhandled_ats = ""
unhandled_ats_count = 0
unhandled_ats_instances = 0
Set customDefDict = Nothing
' variables for creating the nmake file
Dim bfile
Dim mfile
creating_rules = false
files_found = false
cxx_files_found = false
fortran_files_found = false
outdir = "OUTDIR"
cxxflags = "impl_cxxflags"
extra_flags = ""
fort_prefix = ""
remove_buildfiles = false
buildfiles_channel = "sock"
'
' Miscellaneous settings
'
MPI_MAX_PROCESSOR_NAME = "128"
' Use the decorated MPI_AINT64_TYPE with MPI_AINT64_TYPEDEF_BEGIN & *END decos
' for user exposed headers
MPI_AINT64_TYPE        = "MPI_AINT64_TYPE"
' Use MPI_AINT64 for internal headers
MPI_AINT64              = "__int64"
MPI_AINT64_FMT_DEC_SPEC  = "%I64d"
MPIR_PINT64_FMT_DEC_SPEC  = """%I64d"""
MPIR_UPINT64_FMT_DEC_SPEC  = """%I64u"""
MPI_AINT64_FMT_HEX_SPEC  = "%I64x"
BSEND_OVERHEAD64         = "95"
MPI_AINT32               = "int"
MPI_AINT32_FMT_DEC_SPEC  = "%d"
MPIR_PINT32_FMT_DEC_SPEC  = """%d"""
MPIR_UPINT32_FMT_DEC_SPEC  = """%u"""
MPI_AINT32_FMT_HEX_SPEC  = "%x"
BSEND_OVERHEAD32         = "59"
MPI_FINT               = "int"
'MPI_OFFSET             = "long long"

MPI_OFFSET             = "__int64"
'MPI_OFFSET_TYPEDEF     = "typedef __int64 MPI_Offset;"
'MPI_OFFSET_TYPEDEF     = "typedef long long MPI_Offset;"
MPI_OFFSET_TYPEDEF     = "#if defined(USE_GCC) || defined(__GNUC__)" + vbCrLf + "typedef long long MPI_Offset;" + vbCrLf + "#else" + vbCrLf + "typedef __int64 MPI_Offset;" + vbCrLf + "#endif"
MPI_AINT64_TYPEDEF_BEGIN    = "#ifdef MPI_AINT64_TYPE" + vbCrLf + "#undef MPI_AINT64_TYPE" + vbCrLf + "#endif" + vbCrLf + "#if defined(USE_GCC) || defined(__GNUC__)" + vbCrLf + "#define MPI_AINT64_TYPE long long" + vbCrLf + "#else" + vbCrLf + "#define MPI_AINT64_TYPE __int64" + vbCrLf + "#endif" + vbCrLf
MPI_AINT64_TYPEDEF_END = vbCrLf + "#undef MPI_AINT64_TYPE" + vbCrLf
EXTRA_STATUS_DECL      = ""
HAVE_ROMIO             = "#include ""mpio.h"""
mpi_dll_spec_definition = "#ifdef USE_MPI_STATIC_LIBRARY" + vbCrLf + "# define MPIU_DLL_SPEC" + vbCrLf + "#else" + vbCrLf + "# ifdef MPI_EXPORTS" + vbCrLf + "#  define MPIU_DLL_SPEC __declspec(dllexport)" + vbCrLf + "# else" + vbCrLf + "#  define MPIU_DLL_SPEC __declspec(dllimport)" + vbCrLf + "# endif" + vbCrLf + "#endif" + vbCrLf + "#define MPI_CALL __cdecl" + vbCrLf

set f = WScript.CreateObject("Scripting.FileSystemObject")

Set fin = f.OpenTextFile("src\mpid\common\thread\mpe_types.i")
mpid_thread_typedefs = fin.ReadAll()
fin.Close()
Set fin = f.OpenTextFile("src\mpid\common\thread\mpe_funcs.i")
mpid_thread_funcs = fin.ReadAll()
fin.Close()

' Process arguments
If WScript.Arguments.Named.Exists("channel") Then
	buildfiles_channel = WScript.Arguments.Named.Item("channel")
End If
argCount = WScript.Arguments.Count
For arg = 0 To argCount - 1
  argValue = WScript.Arguments(arg)
  If argValue = "--enable-timer-type=x86cycle" Then
    bUseCycleCounter = True
  ElseIf argValue = "--enable-timer-type=queryperformancecounter" Then
    bUseCycleCounter = False
  ElseIf argValue = "--enable-hptiming" Then
    bUseCycleCounter = True
  ElseIf argValue = "--enable-hptiming=yes" Then
    bUseCycleCounter = True
  ElseIf argValue = "--enable-hptiming=no" Then
    bUseCycleCounter = False
  ElseIf argValue = "--force" Then
    bForce = True
  ElseIf argValue = "--force=yes" Then
    bForce = True
  ElseIf argValue = "--force=no" Then
    bForce = False
  ElseIf argValue = "--cleancode" Then
    bCleanCode = True
  ElseIf argValue = "--dlldec" Then
    bAddDllDecoration = True
  ElseIf argValue = "--with-mcxx" Then
	bMcxx = True
  ElseIf argValue = "--f77_name_lower" Then
	bf77_name_lower = True
  ElseIf argValue = "--f77_name_lower_uscore" Then
	bf77_name_lower_uscore = True
  ElseIf argValue = "--f77_name_lower_2uscore" Then
	bf77_name_loser_2uscore = True
  ElseIf argValue = "--f77_name_upper" Then
	bf77_name_upper = True
  ElseIf argValue = "--f77_name_mixed" Then
	bf77_name_mixed = True
  ElseIf argValue = "--f77_name_mixed_uscore" Then
	bf77_name_mixed_uscore = True
  ElseIf argValue = "--defmsg" Then
    GenerateDefmsg()
	printMsgFlush()
    WScript.Quit
  ElseIf argValue = "--genstates" Then
    GenerateStatesFiles()
	printMsgFlush()
    WScript.Quit
  ElseIf argValue = "--mpicc" Then
	GenerateMPICC()
	printMsgFlush()
	WScript.Quit
  ElseIf argValue = "--ifaces" Then
	printMsg "ERROR", "Option not implemented, run the entire script to generate the interfaces"
	' BuildIFaces needs the dictionary object to replace the @xxx@s in mpif.h
	'BuildIFaces()
	printMsgFlush()
	WScript.Quit
  ElseIf argValue = "--remove-fortran" Then
    bRemoveFortran = True
  ElseIf argValue = "--use-ib-rdma" Then
	bUseIbRDMA = True
  ElseIf argValue = "--use_ib_rdma" Then
	bUseIbRDMA = True
  ElseIf argValue = "--use-pin-cache" Then
    bUsePinCache = True
  ElseIf argValue = "--use_pin_cache" Then
    bUsePinCache = True
  ElseIf argValue = "--testdir" Then
    ConfigureTestDir()
	printMsgFlush()
    WScript.Quit
  ElseIf argValue = "--gen-mpi" Then
	FindMPIFuncs()
	printMsgFlush()
	WScript.Quit
  ElseIf argValue = "--gen-sfort" Then
	CreateStdcallFortranInterface()
	printMsgFlush()
	WScript.Quit
  ElseIf argValue = "--vs05" Then
    bVS2005 = True
  ElseIf argValue = "--genbuild" Then
    GenBuild()
	printMsgFlush()
    WScript.Quit
  ElseIf argValue = "--genbuildfiles" Then
    GenBuildFiles(".")
	printMsgFlush()
    WScript.Quit
  ElseIf argValue = "--rmbuildfiles" Then
    remove_buildfiles = true
    GenBuildFiles(".")
	printMsgFlush()
    WScript.Quit
  ElseIf argValue = "--smpd_version" Then
    UpdateSMPDVersion()
	printMsgFlush()
    WScript.Quit
  ElseIf argValue = "--ia64" Then
    x64 = False
  ElseIf argValue = "--verbose" Then
    echoVerboseMsgs = True
  ElseIf argValue = "--help" Then
    WScript.Arguments.ShowUsage
	printMsgFlush()
    WScript.Quit
  End If
Next

'
' datatype sizes
'
  len_short           = "02"
  len_int             = "04"
  len_long            = "04"
  len_long_long       = "08"
  len_float           = "04"
  len_double          = "08"
  len_long_double     = "08"
  len_wchar           = "02"
  len_wchar_t         = "02"
  len_float_int       = "08"
  len_double_int      = "10"
  len_long_int        = "08"
  len_short_int       = "08"
  len_two_int         = "08"
  len_long_double_int = "10"
' Fortran datatype sizes
  len_integer32         = "04"
  len_doublecplx      = "10"
  len_2dc             = "20"

' Special C++ Datatypes
  len_bool			= "01"
  len_complex			= "08"
  len_double_complex		= "10"
  len_long_double_complex	= "10"

' C99 types - These types are not supported by VS, however
' C++ pgms use the same types. So we use the C++ type sizes here
' Also since _Complex is an alias for float _Complex we don't need
' to handle it here
  len__Bool                 = "01"
  len_float__Complex         = "08"
  len_double__Complex        = "10"
  len_long_double__Complex   = "10"

  len_mpi_aint64        = "08"
  len_mpi_aint32        = "04"

  len_mpi_offset        = "08"

Function CreateDtypeDictionary(byref types, str, b64)
	dim regEx, Match, Matches
	set regEx = New RegExp
	'set types = WScript.CreateObject("Scripting.Dictionary")
	' remove all dnl lines to prevent false matches
	regEx.Pattern = "dnl .*"
	regEx.IgnoreCase = True
	regEx.Global = True
	str = regEx.Replace(str, "")
	' find the datatype handles
	regEx.Pattern = "MPI_.*=""?0x4c00.*[0-9a-f][0-9a-f]"
	regEx.IgnoreCase = False
	regEx.Global = True
	Set Matches = regEx.Execute(str)
	For Each Match in Matches
		size_str = RegExpFind("\$\{len.*\}", Match.Value)
		dtype_str = RegExpFind("MPI_[^=]*", Match.Value)
		dtype_val_str = RegExpFind("0x4c00.*[0-9a-f][0-9a-f]", Match.Value)
                ' If size_str is empty then the datatype handle is hardcoded
		if size_str <> "" then
			Select Case size_str
				Case "${len_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_int)
				Case "${len_short}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_short)
				Case "${len_long}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_long)
				Case "${len_long_long}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_long_long)
				Case "${len_float_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_float_int)
				Case "${len_double_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_double_int)
				Case "${len_long_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_long_int)
				Case "${len_short_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_short_int)
				Case "${len_two_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_two_int)
				Case "${len_long_double_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_long_double_int)
				Case "${len_double}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_double)
				Case "${len_doublecplx}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_doublecplx)
				Case "${len_2dc}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_2dc)
				Case "${len_float}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_float)
				Case "${len_long_double}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_long_double)
				Case "${len_integer}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_integer32)
				Case "${len_wchar_t}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_wchar_t)
				Case "${len_wchar}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_wchar)
                                Case "${len__Bool}"
                                        dtype_val_str = Replace(dtype_val_str, size_str, len__Bool)
                                Case "${len_float__Complex}"
                                        dtype_val_str = Replace(dtype_val_str, size_str, len_float__Complex)
                                Case "${len_double__Complex}"
                                        dtype_val_str = Replace(dtype_val_str, size_str, len_double__Complex)
                                Case "${len_long_double__Complex}"
                                        dtype_val_str = Replace(dtype_val_str, size_str, len_long_double__Complex)
                                Case "${len_mpi_aint}"
                                        If b64 Then
                                            dtype_val_str = Replace(dtype_val_str, size_str, len_mpi_aint64)
                                        Else
                                            dtype_val_str = Replace(dtype_val_str, size_str, len_mpi_aint32)
                                        End If
                                Case "${len_mpi_offset}"
                                        dtype_val_str = Replace(dtype_val_str, size_str, len_mpi_offset)
				Case Else
					unmatched_size_strs = unmatched_size_strs & " " & size_str & vbCrLf
			End Select
		end if
		if types.Exists(dtype_str) then
			if types.Item(dtype_str) <> dtype_val_str then
				temp_str = dtype_str & " = " & types.Item(dtype_str) & " or " & dtype_val_str
				MsgBox temp_str
			end if
		else
			types.Add dtype_str, dtype_val_str
		end if
	Next
	if unmatched_size_strs <> "" then
		MsgBox unmatched_size_strs
	end if
	'CreateDtypeDictionary = types
End Function

'
' Create a dictionary of all the datatype handles
'
unmatched_size_strs = ""
set fin = f.OpenTextFile("configure.ac")
contents = fin.ReadAll()
fin.Close()
'set fin = f.OpenTextFile("src\binding\f77\configure.ac")
'contents = contents + fin.ReadAll()
'fin.Close()
'set dtypes = CreateDtypeDictionary(contents, false)
'set dtypes64 = CreateDtypeDictionary(contents, true)
set dtypes = WScript.CreateObject("Scripting.Dictionary")
CreateDtypeDictionary dtypes, contents, false
set dtypes64 = WScript.CreateObject("Scripting.Dictionary")
CreateDtypeDictionary dtypes64, contents, true

'mpi_datatype_prefix = "4c00"

'MPI_CHAR              = "0x" + mpi_datatype_prefix                 + "0101"
'MPI_SIGNED_CHAR       = "0x" + mpi_datatype_prefix                 + "0118"
'MPI_UNSIGNED_CHAR     = "0x" + mpi_datatype_prefix                 + "0102"
'MPI_BYTE              = "0x" + mpi_datatype_prefix                 + "010d"
'MPI_WCHAR             = "0x" + mpi_datatype_prefix + len_wchar       + "0e"
'MPI_WCHAR_T           = "0x" + mpi_datatype_prefix + len_wchar_t     + "0e"
'MPI_SHORT             = "0x" + mpi_datatype_prefix + len_short       + "03"
'MPI_UNSIGNED_SHORT    = "0x" + mpi_datatype_prefix + len_short       + "04"
'MPI_INT               = "0x" + mpi_datatype_prefix + len_int         + "05"
'MPI_UNSIGNED          = "0x" + mpi_datatype_prefix + len_int         + "06"
'MPI_LONG              = "0x" + mpi_datatype_prefix + len_long        + "07"
'MPI_UNSIGNED_LONG     = "0x" + mpi_datatype_prefix + len_long        + "08"
'MPI_LONG_LONG         = "0x" + mpi_datatype_prefix + len_long_long   + "09"
'MPI_LONG_LONG_INT     = "0x" + mpi_datatype_prefix + len_long_long   + "09"
'MPI_UNSIGNED_LONG_LONG ="0x" + mpi_datatype_prefix + len_long_long   + "19"
'MPI_FLOAT             = "0x" + mpi_datatype_prefix + len_float       + "0a"
'MPI_DOUBLE            = "0x" + mpi_datatype_prefix + len_double      + "0b"
'MPI_LONG_DOUBLE       = "0x" + mpi_datatype_prefix + len_long_double + "0c"
'MPI_PACKED            = "0x" + mpi_datatype_prefix                 + "010f"
'MPI_LB                = "0x" + mpi_datatype_prefix                 + "0010"
'MPI_UB                = "0x" + mpi_datatype_prefix                 + "0011"
'MPI_REAL4             = "0x" + mpi_datatype_prefix                 + "0427"
'MPI_REAL8             = "0x" + mpi_datatype_prefix                 + "0829"
'MPI_REAL16            = "0x" + mpi_datatype_prefix                 + "1029"
'MPI_COMPLEX8          = "0x" + mpi_datatype_prefix                 + "0828"
'MPI_COMPLEX16         = "0x" + mpi_datatype_prefix                 + "102b"
'MPI_COMPLEX32         = "0x" + mpi_datatype_prefix                 + "2030"
'MPI_INTEGER1          = "0x" + mpi_datatype_prefix                 + "012d"
'MPI_INTEGER2          = "0x" + mpi_datatype_prefix                 + "022f"
'MPI_INTEGER4          = "0x" + mpi_datatype_prefix                 + "0430"
'MPI_INTEGER8          = "0x" + mpi_datatype_prefix                 + "082a"
'MPI_INTEGER16         = "0x" + mpi_datatype_prefix                 + "102f"
'MPI_FLOAT_INT         = "0x" + mpi_datatype_prefix + len_float_int       + "12"
'MPI_DOUBLE_INT        = "0x" + mpi_datatype_prefix + len_double_int      + "13"
'MPI_LONG_INT          = "0x" + mpi_datatype_prefix + len_long_int        + "14"
'MPI_SHORT_INT         = "0x" + mpi_datatype_prefix + len_short_int       + "15"
'MPI_2INT              = "0x" + mpi_datatype_prefix + len_two_int           + "16"
'MPI_LONG_DOUBLE_INT   = "0x" + mpi_datatype_prefix + len_long_double_int + "17"
'MPI_CHARACTER         = "0x" + mpi_datatype_prefix                + "011a"
'MPI_INTEGER           = "0x" + mpi_datatype_prefix + len_integer    + "1b"
'MPI_REAL              = "0x" + mpi_datatype_prefix + len_integer    + "1c"
'MPI_LOGICAL           = "0x" + mpi_datatype_prefix + len_integer    + "1d"
'MPI_COMPLEX           = "0x" + mpi_datatype_prefix + len_double     + "1e"
'MPI_DOUBLE_PRECISION  = "0x" + mpi_datatype_prefix + len_double     + "1f"
'MPI_2INTEGER          = "0x" + mpi_datatype_prefix + len_double     + "20"
'MPI_2REAL             = "0x" + mpi_datatype_prefix + len_double     + "21"
'MPI_DOUBLE_COMPLEX    = "0x" + mpi_datatype_prefix + len_doublecplx + "22"
'MPI_2DOUBLE_PRECISION = "0x" + mpi_datatype_prefix + len_doublecplx + "23"
'MPI_2COMPLEX          = "0x" + mpi_datatype_prefix + len_doublecplx + "24"
'MPI_2DOUBLE_COMPLEX   = "0x" + mpi_datatype_prefix + len_2dc        + "25"

'F77_MPI_COMPLEX           = "1275070494"
'F77_MPI_DOUBLE_COMPLEX    = "1275072546"
'F77_MPI_LOGICAL           = "1275069469"
'F77_MPI_REAL              = "1275069468"
'F77_MPI_DOUBLE_PRECISION  = "1275070495"
'F77_MPI_INTEGER           = "1275069467"
'F77_MPI_2INTEGER          = "1275070496"
'F77_MPI_2COMPLEX          = "1275072548"
'F77_MPI_2DOUBLE_COMPLEX   = "1275076645"
'F77_MPI_2REAL             = "1275070497"
'F77_MPI_2DOUBLE_PRECISION = "1275072547"
'F77_MPI_CHARACTER         = "1275068698"
'F77_MPI_LB                = "1275068432"
'F77_MPI_PACKED            = "1275068687"
'F77_MPI_UB                = "1275068433"
'F77_COMPLEX8              = "1275070504"
'F77_COMPLEX16             = "1275072554"
'F77_COMPLEX32             = "MPI_DATATYPE_NULL"
'F77_INTEGER1              = "1275068717"
'F77_INTEGER2              = "1275068975"
'F77_INTEGER4              = "1275069488"
'F77_INTEGER8              = "1275070507"
'F77_INTEGER16             = "MPI_DATATYPE_NULL"
'F77_REAL4                 = "1275069479"
'F77_REAL8                 = "1275070505"
'F77_REAL16                = "MPI_DATATYPE_NULL"

'
' Set the datatype variables from the dictionary
'
mpi_datatype_prefix = "4c00"
missing_datatypes = ""

if dtypes.Exists("MPI_CHAR") then
	MPI_CHAR = dtypes.Item("MPI_CHAR")
else
	missing_datatypes = missing_datatypes & "MPI_CHAR" & vbCrLf
	MPI_CHAR              = "0x" + mpi_datatype_prefix                 + "0101"
end if
if dtypes.Exists("MPI_SIGNED_CHAR") then
	MPI_SIGNED_CHAR = dtypes.Item("MPI_SIGNED_CHAR")
else
	missing_datatypes = missing_datatypes & "MPI_SIGNED_CHAR" & vbCrLf
	MPI_SIGNED_CHAR       = "0x" + mpi_datatype_prefix                 + "0118"
end if
if dtypes.Exists("MPI_UNSIGNED_CHAR") then
	MPI_UNSIGNED_CHAR = dtypes.Item("MPI_UNSIGNED_CHAR")
else
	missing_datatypes = missing_datatypes & "MPI_UNSIGNED_CHAR" & vbCrLf
	MPI_UNSIGNED_CHAR     = "0x" + mpi_datatype_prefix                 + "0102"
end if
if dtypes.Exists("MPI_BYTE") then
	MPI_BYTE = dtypes.Item("MPI_BYTE")
else
	missing_datatypes = missing_datatypes & "MPI_BYTE" & vbCrLf
	MPI_BYTE              = "0x" + mpi_datatype_prefix                 + "010d"
end if
if dtypes.Exists("MPI_WCHAR") then
	MPI_WCHAR = dtypes.Item("MPI_WCHAR")
else
	missing_datatypes = missing_datatypes & "MPI_WCHAR" & vbCrLf
	MPI_WCHAR             = "0x" + mpi_datatype_prefix + len_wchar       + "0e"
end if
if dtypes.Exists("MPI_WCHAR_T") then
	MPI_WCHAR_T = dtypes.Item("MPI_WCHAR_T")
else
	'missing_datatypes = missing_datatypes & "MPI_WCHAR_T" & vbCrLf
	'MPI_WCHAR_T           = "0x" + mpi_datatype_prefix + len_wchar_t     + "0e"
        if dtypes.Exists("MPI_WCHAR") then
            MPI_WCHAR_T = dtypes.Item("MPI_WCHAR")
            dtypes.Add "MPI_WCHAR_T", MPI_WCHAR_T
        else
            missing_datatypes = missing_datatypes & "MPI_WCHAR_T" & vbCrLf
            MPI_WCHAR_T       = "0x" + mpi_datatype_prefix + len_wchar       + "0e"
        end if
end if
if dtypes.Exists("MPI_SHORT") then
	MPI_SHORT = dtypes.Item("MPI_SHORT")
else
	missing_datatypes = missing_datatypes & "MPI_SHORT" & vbCrLf
	MPI_SHORT             = "0x" + mpi_datatype_prefix + len_short       + "03"
end if
if dtypes.Exists("MPI_UNSIGNED_SHORT") then
	MPI_UNSIGNED_SHORT = dtypes.Item("MPI_UNSIGNED_SHORT")
else
	missing_datatypes = missing_datatypes & "MPI_UNSIGNED_SHORT" & vbCrLf
	MPI_UNSIGNED_SHORT    = "0x" + mpi_datatype_prefix + len_short       + "04"
end if
if dtypes.Exists("MPI_INT") then
	MPI_INT = dtypes.Item("MPI_INT")
else
	missing_datatypes = missing_datatypes & "MPI_INT" & vbCrLf
	MPI_INT               = "0x" + mpi_datatype_prefix + len_int         + "05"
end if
if dtypes.Exists("MPI_UNSIGNED_INT") then
	MPI_UNSIGNED_INT = dtypes.Item("MPI_UNSIGNED_INT")
else
	missing_datatypes = missing_datatypes & "MPI_UNSIGNED_INT" & vbCrLf
	MPI_UNSIGNED_INT      = "0x" + mpi_datatype_prefix + len_int         + "06"
end if
if dtypes.Exists("MPI_UNSIGNED") then
	MPI_UNSIGNED = dtypes.Item("MPI_UNSIGNED")
else
	'missing_datatypes = missing_datatypes & "MPI_UNSIGNED" & vbCrLf
	'MPI_UNSIGNED          = "0x" + mpi_datatype_prefix + len_int         + "06"
        if dtypes.Exists("MPI_UNSIGNED_INT") then
            MPI_UNSIGNED = dtypes.Item("MPI_UNSIGNED_INT")
            dtypes.Add "MPI_UNSIGNED", MPI_UNSIGNED
        else
            missing_datatypes = missing_datatypes & "MPI_UNSIGNED" & vbCrLf
            MPI_UNSIGNED      = "0x" + mpi_datatype_prefix + len_int         + "06"
        end if
end if
if dtypes.Exists("MPI_LONG") then
	MPI_LONG = dtypes.Item("MPI_LONG")
else
	missing_datatypes = missing_datatypes & "MPI_LONG" & vbCrLf
	MPI_LONG              = "0x" + mpi_datatype_prefix + len_long        + "07"
end if
if dtypes.Exists("MPI_UNSIGNED_LONG") then
	MPI_UNSIGNED_LONG = dtypes.Item("MPI_UNSIGNED_LONG")
else
	missing_datatypes = missing_datatypes & "MPI_UNSIGNED_LONG" & vbCrLf
	MPI_UNSIGNED_LONG     = "0x" + mpi_datatype_prefix + len_long        + "08"
end if
if dtypes.Exists("MPI_LONG_LONG") then
	MPI_LONG_LONG = dtypes.Item("MPI_LONG_LONG")
else
	missing_datatypes = missing_datatypes & "MPI_LONG_LONG" & vbCrLf
	MPI_LONG_LONG         = "0x" + mpi_datatype_prefix + len_long_long   + "09"
end if
if dtypes.Exists("MPI_LONG_LONG_INT") then
	MPI_LONG_LONG_INT = dtypes.Item("MPI_LONG_LONG_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_LONG_LONG_INT" & vbCrLf
	'MPI_LONG_LONG_INT     = "0x" + mpi_datatype_prefix + len_long_long   + "09"
        if dtypes.Exists("MPI_LONG_LONG") then
            MPI_LONG_LONG_INT = dtypes.Item("MPI_LONG_LONG")
            dtypes.Add "MPI_LONG_LONG_INT", MPI_LONG_LONG_INT
        else
            missing_datatypes = missing_datatypes & "MPI_LONG_LONG_INT" & vbCrLf
            MPI_LONG_LONG_INT = "0x" + mpi_datatype_prefix + len_long_long   + "09"
        end if
end if
if dtypes.Exists("MPI_UNSIGNED_LONG_LONG") then
	MPI_UNSIGNED_LONG_LONG = dtypes.Item("MPI_UNSIGNED_LONG_LONG")
else
	missing_datatypes = missing_datatypes & "MPI_UNSIGNED_LONG_LONG" & vbCrLf
	MPI_UNSIGNED_LONG_LONG ="0x" + mpi_datatype_prefix + len_long_long   + "19"
end if
if dtypes.Exists("MPI_FLOAT") then
	MPI_FLOAT = dtypes.Item("MPI_FLOAT")
else
	missing_datatypes = missing_datatypes & "MPI_FLOAT" & vbCrLf
	MPI_FLOAT             = "0x" + mpi_datatype_prefix + len_float       + "0a"
end if
if dtypes.Exists("MPI_DOUBLE") then
	MPI_DOUBLE = dtypes.Item("MPI_DOUBLE")
else
	missing_datatypes = missing_datatypes & "MPI_DOUBLE" & vbCrLf
	MPI_DOUBLE            = "0x" + mpi_datatype_prefix + len_double      + "0b"
end if
if dtypes.Exists("MPI_LONG_DOUBLE") then
	MPI_LONG_DOUBLE = dtypes.Item("MPI_LONG_DOUBLE")
else
	missing_datatypes = missing_datatypes & "MPI_LONG_DOUBLE" & vbCrLf
	MPI_LONG_DOUBLE       = "0x" + mpi_datatype_prefix + len_long_double + "0c"
end if
if dtypes.Exists("MPI_PACKED") then
	MPI_PACKED = dtypes.Item("MPI_PACKED")
else
	missing_datatypes = missing_datatypes & "MPI_PACKED" & vbCrLf
	MPI_PACKED            = "0x" + mpi_datatype_prefix                 + "010f"
end if
if dtypes.Exists("MPI_LB") then
	MPI_LB = dtypes.Item("MPI_LB")
else
	missing_datatypes = missing_datatypes & "MPI_LB" & vbCrLf
	MPI_LB                = "0x" + mpi_datatype_prefix                 + "0010"
end if
if dtypes.Exists("MPI_UB") then
	MPI_UB = dtypes.Item("MPI_UB")
else
	missing_datatypes = missing_datatypes & "MPI_UB" & vbCrLf
	MPI_UB                = "0x" + mpi_datatype_prefix                 + "0011"
end if
if dtypes.Exists("MPI_REAL4") then
	MPI_REAL4 = dtypes.Item("MPI_REAL4")
else
	missing_datatypes = missing_datatypes & "MPI_REAL4" & vbCrLf
	MPI_REAL4             = "0x" + mpi_datatype_prefix                 + "0427"
end if
if dtypes.Exists("MPI_REAL8") then
	MPI_REAL8 = dtypes.Item("MPI_REAL8")
else
	missing_datatypes = missing_datatypes & "MPI_REAL8" & vbCrLf
	MPI_REAL8             = "0x" + mpi_datatype_prefix                 + "0829"
end if
if dtypes.Exists("MPI_REAL16") then
	MPI_REAL16 = dtypes.Item("MPI_REAL16")
else
	missing_datatypes = missing_datatypes & "MPI_REAL16" & vbCrLf
	MPI_REAL16            = "0x" + mpi_datatype_prefix                 + "1029"
end if
if dtypes.Exists("MPI_COMPLEX8") then
	MPI_COMPLEX8 = dtypes.Item("MPI_COMPLEX8")
else
	missing_datatypes = missing_datatypes & "MPI_COMPLEX8" & vbCrLf
	MPI_COMPLEX8          = "0x" + mpi_datatype_prefix                 + "0828"
end	if
if dtypes.Exists("MPI_COMPLEX16") then
	MPI_COMPLEX16 = dtypes.Item("MPI_COMPLEX16")
else
	missing_datatypes = missing_datatypes & "MPI_COMPLEX16" & vbCrLf
	MPI_COMPLEX16         = "0x" + mpi_datatype_prefix                 + "102b"
end if
if dtypes.Exists("MPI_COMPLEX32") then
	MPI_COMPLEX32 = dtypes.Item("MPI_COMPLEX32")
else
	missing_datatypes = missing_datatypes & "MPI_COMPLEX32" & vbCrLf
	MPI_COMPLEX32         = "0x" + mpi_datatype_prefix                 + "2030"
end if
if dtypes.Exists("MPI_INTEGER1") then
	MPI_INTEGER1 = dtypes.Item("MPI_INTEGER1")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER1" & vbCrLf
	MPI_INTEGER1          = "0x" + mpi_datatype_prefix                 + "012d"
end if
if dtypes.Exists("MPI_INTEGER2") then
	MPI_INTEGER2 = dtypes.Item("MPI_INTEGER2")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER2" & vbCrLf
	MPI_INTEGER2          = "0x" + mpi_datatype_prefix                 + "022f"
end if
if dtypes.Exists("MPI_INTEGER4") then
	MPI_INTEGER4 = dtypes.Item("MPI_INTEGER4")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER4" & vbCrLf
	MPI_INTEGER4          = "0x" + mpi_datatype_prefix                 + "0430"
end if
if dtypes.Exists("MPI_INTEGER8") then
	MPI_INTEGER8 = dtypes.Item("MPI_INTEGER8")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER8" & vbCrLf
	MPI_INTEGER8          = "0x" + mpi_datatype_prefix                 + "082a"
end if
if dtypes.Exists("MPI_INTEGER16") then
	MPI_INTEGER16 = dtypes.Item("MPI_INTEGER16")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER16" & vbCrLf
	MPI_INTEGER16         = "0x" + mpi_datatype_prefix                 + "102f"
end if
if dtypes.Exists("MPI_FLOAT_INT") then
	MPI_FLOAT_INT = dtypes.Item("MPI_FLOAT_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_FLOAT_INT" & vbCrLf
	'MPI_FLOAT_INT         = "0x" + mpi_datatype_prefix + len_float_int       + "12"
	MPI_FLOAT_INT         = "0x8c000000"
        dtypes.Add "MPI_FLOAT_INT", MPI_FLOAT_INT
end if
if dtypes.Exists("MPI_DOUBLE_INT") then
	MPI_DOUBLE_INT = dtypes.Item("MPI_DOUBLE_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_DOUBLE_INT" & vbCrLf
	'MPI_DOUBLE_INT        = "0x" + mpi_datatype_prefix + len_double_int      + "13"
	MPI_DOUBLE_INT        = "0x8c000001"
        dtypes.Add "MPI_DOUBLE_INT", MPI_DOUBLE_INT
end if
if dtypes.Exists("MPI_LONG_INT") then
	MPI_LONG_INT = dtypes.Item("MPI_LONG_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_LONG_INT" & vbCrLf
	'MPI_LONG_INT          = "0x" + mpi_datatype_prefix + len_long_int        + "14"
	MPI_LONG_INT          = "0x8c000002"
        dtypes.Add "MPI_LONG_INT", MPI_LONG_INT
end if
if dtypes.Exists("MPI_SHORT_INT") then
	MPI_SHORT_INT = dtypes.Item("MPI_SHORT_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_SHORT_INT" & vbCrLf
	'MPI_SHORT_INT         = "0x" + mpi_datatype_prefix + len_short_int       + "15"
	MPI_SHORT_INT         = "0x8c000003"
        dtypes.Add "MPI_SHORT_INT", MPI_SHORT_INT
end if
if dtypes.Exists("MPI_2INT") then
	MPI_2INT = dtypes.Item("MPI_2INT")
else
	missing_datatypes = missing_datatypes & "MPI_2INT" & vbCrLf
	MPI_2INT              = "0x" + mpi_datatype_prefix + len_two_int          + "16"
end if
if dtypes.Exists("MPI_LONG_DOUBLE_INT") then
	MPI_LONG_DOUBLE_INT = dtypes.Item("MPI_LONG_DOUBLE_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_LONG_DOUBLE_INT" & vbCrLf
	'MPI_LONG_DOUBLE_INT   = "0x" + mpi_datatype_prefix + len_long_double_int + "17"
	MPI_LONG_DOUBLE_INT   = "0x8c000004"
        dtypes.Add "MPI_LONG_DOUBLE_INT", MPI_LONG_DOUBLE_INT
end if
if dtypes.Exists("MPI_CHARACTER") then
	MPI_CHARACTER = dtypes.Item("MPI_CHARACTER")
else
	missing_datatypes = missing_datatypes & "MPI_CHARACTER" & vbCrLf
	MPI_CHARACTER         = "0x" + mpi_datatype_prefix                + "011a"
end if
' Win32 versions
if dtypes.Exists("MPI_INTEGER") then
	MPI_INTEGER_W32 = dtypes.Item("MPI_INTEGER")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER" & vbCrLf
	MPI_INTEGER_W32           = "0x" + mpi_datatype_prefix + len_integer    + "1b"
end if
if dtypes.Exists("MPI_REAL") then
	MPI_REAL_W32 = dtypes.Item("MPI_REAL")
else
	missing_datatypes = missing_datatypes & "MPI_REAL" & vbCrLf
	MPI_REAL_W32              = "0x" + mpi_datatype_prefix + len_integer    + "1c"
end if
if dtypes.Exists("MPI_LOGICAL") then
	MPI_LOGICAL_W32 = dtypes.Item("MPI_LOGICAL")
else
	missing_datatypes = missing_datatypes & "MPI_LOGICAL" & vbCrLf
	MPI_LOGICAL_W32           = "0x" + mpi_datatype_prefix + len_integer    + "1d"
end if
' Win64 versions
if dtypes64.Exists("MPI_INTEGER") then
	MPI_INTEGER_W64 = dtypes64.Item("MPI_INTEGER")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER" & vbCrLf
	MPI_INTEGER_W64           = "0x" + mpi_datatype_prefix + len_integer    + "1b"
end if
if dtypes64.Exists("MPI_REAL") then
	MPI_REAL_W64 = dtypes64.Item("MPI_REAL")
else
	missing_datatypes = missing_datatypes & "MPI_REAL" & vbCrLf
	MPI_REAL_W64              = "0x" + mpi_datatype_prefix + len_integer    + "1c"
end if
if dtypes64.Exists("MPI_LOGICAL") then
	MPI_LOGICAL_W64 = dtypes64.Item("MPI_LOGICAL")
else
	missing_datatypes = missing_datatypes & "MPI_LOGICAL" & vbCrLf
	MPI_LOGICAL_W64           = "0x" + mpi_datatype_prefix + len_integer    + "1d"
end if
' end versions
if dtypes.Exists("MPI_COMPLEX") then
	MPI_COMPLEX = dtypes.Item("MPI_COMPLEX")
else
	missing_datatypes = missing_datatypes & "MPI_COMPLEX" & vbCrLf
	MPI_COMPLEX           = "0x" + mpi_datatype_prefix + len_double     + "1e"
end if
if dtypes.Exists("MPI_DOUBLE_PRECISION") then
	MPI_DOUBLE_PRECISION = dtypes.Item("MPI_DOUBLE_PRECISION")
else
	missing_datatypes = missing_datatypes & "MPI_DOUBLE_PRECISION" & vbCrLf
	MPI_DOUBLE_PRECISION  = "0x" + mpi_datatype_prefix + len_double     + "1f"
end if
if dtypes.Exists("MPI_2INTEGER") then
	MPI_2INTEGER = dtypes.Item("MPI_2INTEGER")
else
	missing_datatypes = missing_datatypes & "MPI_2INTEGER" & vbCrLf
	MPI_2INTEGER          = "0x" + mpi_datatype_prefix + len_double     + "20"
end if
if dtypes.Exists("MPI_2REAL") then
	MPI_2REAL = dtypes.Item("MPI_2REAL")
else
	missing_datatypes = missing_datatypes & "MPI_2REAL" & vbCrLf
	MPI_2REAL             = "0x" + mpi_datatype_prefix + len_double     + "21"
end if
if dtypes.Exists("MPI_DOUBLE_COMPLEX") then
	MPI_DOUBLE_COMPLEX = dtypes.Item("MPI_DOUBLE_COMPLEX")
else
	missing_datatypes = missing_datatypes & "MPI_DOUBLE_COMPLEX" & vbCrLf
	MPI_DOUBLE_COMPLEX    = "0x" + mpi_datatype_prefix + len_doublecplx + "22"
end if
if dtypes.Exists("MPI_2DOUBLE_PRECISION") then
	MPI_2DOUBLE_PRECISION = dtypes.Item("MPI_2DOUBLE_PRECISION")
else
	missing_datatypes = missing_datatypes & "MPI_2DOUBLE_PRECISION" & vbCrLf
	MPI_2DOUBLE_PRECISION = "0x" + mpi_datatype_prefix + len_doublecplx + "23"
end if
if dtypes.Exists("MPI_2COMPLEX") then
	MPI_2COMPLEX = dtypes.Item("MPI_2COMPLEX")
else
	missing_datatypes = missing_datatypes & "MPI_2COMPLEX" & vbCrLf
	MPI_2COMPLEX          = "0x" + mpi_datatype_prefix + len_doublecplx + "24"
end if
if dtypes.Exists("MPI_2DOUBLE_COMPLEX") then
	MPI_2DOUBLE_COMPLEX = dtypes.Item("MPI_2DOUBLE_COMPLEX")
else
	missing_datatypes = missing_datatypes & "MPI_2DOUBLE_COMPLEX" & vbCrLf
	MPI_2DOUBLE_COMPLEX   = "0x" + mpi_datatype_prefix + len_2dc        + "25"
end if

' Special C++ Datatypes to support Fortran datatypes within C++ 
MPIR_CXX_BOOL 			= "0x" + mpi_datatype_prefix + len_bool 		+ "33"
MPIR_CXX_COMPLEX		= "0x" + mpi_datatype_prefix + len_complex		+ "34"
MPIR_CXX_DOUBLE_COMPLEX 	= "0x" + mpi_datatype_prefix + len_double_complex	+ "35"
MPIR_CXX_LONG_DOUBLE_COMPLEX	= "0x" + mpi_datatype_prefix + len_long_double_complex	+ "36"

' Fixed width types
if dtypes.Exists("MPI_INT8_T") then
    MPI_INT8_T = dtypes.Item("MPI_INT8_T")
else
    missing_datatypes = missing_datatypes & "MPI_INT8_T" & vbCrLf
    MPI_INT8_T = "0x" + mpi_datatype_prefix + "01" + "37"
end if
if dtypes.Exists("MPI_INT16_T") then
    MPI_INT16_T = dtypes.Item("MPI_INT16_T")
else
    missing_datatypes = missing_datatypes & "MPI_INT16_T" & vbCrLf
    MPI_INT16_T = "0x" + mpi_datatype_prefix + "02" + "38"
end if
if dtypes.Exists("MPI_INT32_T") then
    MPI_INT32_T = dtypes.Item("MPI_INT32_T")
else
    missing_datatypes = missing_datatypes & "MPI_INT32_T" & vbCrLf
    MPI_INT32_T = "0x" + mpi_datatype_prefix + "04" + "39"
end if
if dtypes.Exists("MPI_INT64_T") then
    MPI_INT64_T = dtypes.Item("MPI_INT64_T")
else
    missing_datatypes = missing_datatypes & "MPI_INT64_T" & vbCrLf
    MPI_INT64_T = "0x" + mpi_datatype_prefix + "08" + "3a"
end if
if dtypes.Exists("MPI_UINT8_T") then
    MPI_UINT8_T = dtypes.Item("MPI_UINT8_T")
else
    missing_datatypes = missing_datatypes & "MPI_UINT8_T" & vbCrLf
    MPI_UINT8_T = "0x" + mpi_datatype_prefix + "01" + "3b"
end if
if dtypes.Exists("MPI_UINT16_T") then
    MPI_UINT16_T = dtypes.Item("MPI_UINT16_T")
else
    missing_datatypes = missing_datatypes & "MPI_UINT16_T" & vbCrLf
    MPI_UINT16_T = "0x" + mpi_datatype_prefix + "02" + "3c"
end if
if dtypes.Exists("MPI_UINT32_T") then
    MPI_UINT32_T = dtypes.Item("MPI_UINT32_T")
else
    missing_datatypes = missing_datatypes & "MPI_UINT32_T" & vbCrLf
    MPI_UINT32_T = "0x" + mpi_datatype_prefix + "04" + "3d"
end if
if dtypes.Exists("MPI_UINT64_T") then
    MPI_UINT64_T = dtypes.Item("MPI_UINT64_T")
else
    missing_datatypes = missing_datatypes & "MPI_UINT64_T" & vbCrLf
    MPI_UINT64_T = "0x" + mpi_datatype_prefix + "08" + "3e"
end if
' C99 types
if dtypes.Exists("MPI_C_BOOL") then
    MPI_C_BOOL = dtypes.Item("MPI_C_BOOL")
else
    missing_datatypes = missing_datatypes & "MPI_C_BOOL" & vbCrLf
    MPI_C_BOOL = "0x" + mpi_datatype_prefix + len__Bool + "3f"
end if
if dtypes.Exists("MPI_C_FLOAT_COMPLEX") then
    MPI_C_FLOAT_COMPLEX = dtypes.Item("MPI_C_FLOAT_COMPLEX")
else
    missing_datatypes = missing_datatypes & "MPI_C_FLOAT_COMPLEX" & vbCrLf
    MPI_C_FLOAT_COMPLEX = "0x" + mpi_datatype_prefix + len_float__Complex + "40"
end if
if dtypes.Exists("MPI_C_COMPLEX") then
    MPI_C_COMPLEX = dtypes.Item("MPI_C_COMPLEX")
else
    if dtypes.Exists("MPI_C_FLOAT_COMPLEX") then
        MPI_C_COMPLEX = dtypes.Item("MPI_C_FLOAT_COMPLEX")
        dtypes.Add "MPI_C_COMPLEX", MPI_C_COMPLEX
    else
        missing_datatypes = missing_datatypes & "MPI_C_COMPLEX" & vbCrLf
        MPI_C_COMPLEX = "0x" + mpi_datatype_prefix + len_float__Complex + "40"
    end if
end if
if dtypes.Exists("MPI_C_DOUBLE_COMPLEX") then
    MPI_C_DOUBLE_COMPLEX = dtypes.Item("MPI_C_DOUBLE_COMPLEX")
else
    missing_datatypes = missing_datatypes & "MPI_C_DOUBLE_COMPLEX" & vbCrLf
    MPI_C_DOUBLE_COMPLEX = "0x" + mpi_datatype_prefix + len_double__Complex + "41"
end if
if dtypes.Exists("MPI_C_LONG_DOUBLE_COMPLEX") then
    MPI_C_LONG_DOUBLE_COMPLEX = dtypes.Item("MPI_C_LONG_DOUBLE_COMPLEX")
else
    missing_datatypes = missing_datatypes & "MPI_C_LONG_DOUBLE_COMPLEX" & vbCrLf
    MPI_C_LONG_DOUBLE_COMPLEX = "0x" + mpi_datatype_prefix + len_long_double__Complex + "42"
end if
' Note that in configure.ac MPI_AINT is named as MPI_AINT_DATATYPE - due to name collision
if dtypes.Exists("MPI_AINT_DATATYPE") then
    MPI_AINT_W32 = dtypes.Item("MPI_AINT_DATATYPE")
else
    missing_datatypes = missing_datatypes & "MPI_AINT" & vbCrLf
    MPI_AINT_W32 = "0x" + mpi_datatype_prefix + len_mpi_aint32 + "43"
end if
dtypes.Add "MPI_AINT_W32", MPI_AINT_W32

if dtypes64.Exists("MPI_AINT_DATATYPE") then
    MPI_AINT_W64 = dtypes64.Item("MPI_AINT_DATATYPE")
else
    missing_datatypes = missing_datatypes & "MPI_AINT" & vbCrLf
    MPI_AINT_W64 = "0x" + mpi_datatype_prefix + len_mpi_aint64 + "43"
end if
dtypes64.Add "MPI_AINT_W64", MPI_AINT_W64

' Note that in configure.ac MPI_OFFSET is named as MPI_OFFSET_DATATYPE - due to name collision
if dtypes.Exists("MPI_OFFSET_DATATYPE") then
    MPI_OFFSET_W64 = dtypes.Item("MPI_OFFSET_DATATYPE")
else
    missing_datatypes = missing_datatypes & "MPI_OFFSET" & vbCrLf
    MPI_OFFSET_W64 = "0x" + mpi_datatype_prefix + len_mpi_offset + "44"
end if
dtypes.Add "MPI_OFFSET_W64", MPI_OFFSET_W64
dtypes64.Add "MPI_OFFSET_W64", MPI_OFFSET_W64


if missing_datatypes <> "" then
	printMsg "ERROR", "Missing datatypes:" & vbCrLf & missing_datatypes
	printMsgFlush()
	WScript.Quit
end if

Function ToInteger(c)
	Dim i
	i = 0
	if c = "0" then i = 0 end if
	if c = "1" then i = 1 end if
	if c = "2" then i = 2 end if
	if c = "3" then i = 3 end if
	if c = "4" then i = 4 end if
	if c = "5" then i = 5 end if
	if c = "6" then i = 6 end if
	if c = "7" then i = 7 end if
	if c = "8" then i = 8 end if
	if c = "9" then i = 9 end if
	if c = "a" then i = 10 end if
	if c = "b" then i = 11 end if
	if c = "c" then i = 12 end if
	if c = "d" then i = 13 end if
	if c = "e" then i = 14 end if
	if c = "f" then i = 15 end if
	ToInteger = i
End Function

' eg: IsSignedInteger(0x8000, 4) = True
Function IsSignedInteger(hex_str, nb)
    Dim max_nibbles

    IsSignedInteger = False
    max_nibbles = nb/4

    If (len(hex_str) > 2) AND (len(hex_str) - 2 <= max_nibbles) Then
        If len(hex_str) - 2 < max_nibbles Then
            ' IsSignedInteger = False
        Else
            If ToInteger(Mid(hex_str, 3, 1)) >= 8 Then
                IsSignedInteger = True
            End If
        End If
    Else
        printMsg "ERROR", "Invalid HEX string provided , str=" & hex_str
    End If
End Function

'first = true
' eg: HexToInt(0x1, 32) = 1, HexToInt(0x1f, 32)=31
Function HexToInt(str, nb)
        Dim i, multiplier, index, max_nibbles
        i = 0
        multiplier = 1
        max_nibbles = nb/4
        if len(str) - 2 > max_nibbles then
            printMsg "ERROR", "Cannot convert hex to integer, hex=" & str
            HexToInt = 0
        else
            for index = len(str) to 3 step -1
                i = i + (ToInteger(Mid(str, index, 1)) * multiplier)
                multiplier = multiplier * 16
            next
            If IsSignedInteger(str, nb) Then
                HexToInt = i - 2^nb
            Else
                HexToInt = i
            End If
        end if
End Function

'Convert hex to a fortran integer
Function HexToFint(str)
    ' sizeof(fint) = 4 bytes
    HexToFint = HexToInt(str, 32)
End Function

F77_MPI_DOUBLE_COMPLEX    = HexToFint(dtypes.Item("MPI_DOUBLE_COMPLEX"))
F77_MPI_COMPLEX           = HexToFint(dtypes.Item("MPI_COMPLEX"))
F77_MPI_LOGICAL_W32           = HexToFint(dtypes.Item("MPI_LOGICAL"))
F77_MPI_LOGICAL_W64           = HexToFint(dtypes64.Item("MPI_LOGICAL"))
F77_MPI_REAL_W32              = HexToFint(dtypes.Item("MPI_REAL"))
F77_MPI_REAL_W64              = HexToFint(dtypes64.Item("MPI_REAL"))
F77_MPI_DOUBLE_PRECISION  = HexToFint(dtypes.Item("MPI_DOUBLE_PRECISION"))
F77_MPI_INTEGER_W32           = HexToFint(dtypes.Item("MPI_INTEGER"))
F77_MPI_INTEGER_W64           = HexToFint(dtypes64.Item("MPI_INTEGER"))
F77_MPI_2INTEGER          = HexToFint(dtypes.Item("MPI_2INTEGER"))
F77_MPI_2COMPLEX          = HexToFint(dtypes.Item("MPI_2COMPLEX"))
F77_MPI_2DOUBLE_COMPLEX   = HexToFint(dtypes.Item("MPI_2DOUBLE_COMPLEX"))
F77_MPI_2REAL             = HexToFint(dtypes.Item("MPI_2REAL"))
F77_MPI_2DOUBLE_PRECISION = HexToFint(dtypes.Item("MPI_2DOUBLE_PRECISION"))
F77_MPI_CHARACTER         = HexToFint(dtypes.Item("MPI_CHARACTER"))
F77_MPI_BYTE              = HexToFint(dtypes.Item("MPI_BYTE"))
F77_MPI_LB                = HexToFint(dtypes.Item("MPI_LB"))
F77_MPI_PACKED            = HexToFint(dtypes.Item("MPI_PACKED"))
F77_MPI_UB                = HexToFint(dtypes.Item("MPI_UB"))
F77_COMPLEX8              = HexToFint(dtypes.Item("MPI_COMPLEX8"))
F77_COMPLEX16             = HexToFint(dtypes.Item("MPI_COMPLEX16"))
F77_COMPLEX32             = HexToFint(dtypes.Item("MPI_COMPLEX32"))
F77_INTEGER1              = HexToFint(dtypes.Item("MPI_INTEGER1"))
F77_INTEGER2              = HexToFint(dtypes.Item("MPI_INTEGER2"))
F77_INTEGER4              = HexToFint(dtypes.Item("MPI_INTEGER4"))
F77_INTEGER8              = HexToFint(dtypes.Item("MPI_INTEGER8"))
F77_INTEGER16             = HexToFint(dtypes.Item("MPI_INTEGER16"))
F77_REAL4                 = HexToFint(dtypes.Item("MPI_REAL4"))
F77_REAL8                 = HexToFint(dtypes.Item("MPI_REAL8"))
F77_REAL16                = HexToFint(dtypes.Item("MPI_REAL16"))
F77_CHAR					= HexToFint(dtypes.Item("MPI_CHAR"))
F77_SIGNED_CHAR				= HexToFint(dtypes.Item("MPI_SIGNED_CHAR"))
F77_UNSIGNED_CHAR			= HexToFint(dtypes.Item("MPI_UNSIGNED_CHAR"))
F77_WCHAR					= HexToFint(dtypes.Item("MPI_WCHAR"))
F77_SHORT					= HexToFint(dtypes.Item("MPI_SHORT"))
F77_UNSIGNED_SHORT			= HexToFint(dtypes.Item("MPI_UNSIGNED_SHORT"))
F77_INT						= HexToFint(dtypes.Item("MPI_INT"))
F77_UNSIGNED				= HexToFint(dtypes.Item("MPI_UNSIGNED"))
F77_LONG					= HexToFint(dtypes.Item("MPI_LONG"))
F77_UNSIGNED_LONG			= HexToFint(dtypes.Item("MPI_UNSIGNED_LONG"))
F77_FLOAT					= HexToFint(dtypes.Item("MPI_FLOAT"))
F77_DOUBLE					= HexToFint(dtypes.Item("MPI_DOUBLE"))
F77_LONG_DOUBLE				= HexToFint(dtypes.Item("MPI_LONG_DOUBLE"))
F77_LONG_LONG_INT			= HexToFint(dtypes.Item("MPI_LONG_LONG_INT"))
F77_UNSIGNED_LONG_LONG		= HexToFint(dtypes.Item("MPI_UNSIGNED_LONG_LONG"))
F77_LONG_LONG				= HexToFint(dtypes.Item("MPI_LONG_LONG"))
F77_FLOAT_INT				= HexToFint(dtypes.Item("MPI_FLOAT_INT"))
F77_DOUBLE_INT				= HexToFint(dtypes.Item("MPI_DOUBLE_INT"))
F77_LONG_INT				= HexToFint(dtypes.Item("MPI_LONG_INT"))
F77_SHORT_INT				= HexToFint(dtypes.Item("MPI_SHORT_INT"))
F77_2INT					= HexToFint(dtypes.Item("MPI_2INT"))
F77_LONG_DOUBLE_INT			= HexToFint(dtypes.Item("MPI_LONG_DOUBLE_INT"))
F77_INT8_T              = HexToFint(dtypes.Item("MPI_INT8_T"))
F77_INT16_T             = HexToFint(dtypes.Item("MPI_INT16_T"))
F77_INT32_T             = HexToFint(dtypes.Item("MPI_INT32_T"))
F77_INT64_T             = HexToFint(dtypes.Item("MPI_INT64_T"))
F77_UINT8_T             = HexToFint(dtypes.Item("MPI_UINT8_T"))
F77_UINT16_T            = HexToFint(dtypes.Item("MPI_UINT16_T"))
F77_UINT32_T            = HexToFint(dtypes.Item("MPI_UINT32_T"))
F77_UINT64_T            = HexToFint(dtypes.Item("MPI_UINT64_T"))
F77_C_BOOL              = HexToFint(dtypes.Item("MPI_C_BOOL"))
F77_C_FLOAT_COMPLEX     = HexToFint(dtypes.Item("MPI_C_FLOAT_COMPLEX"))
F77_C_COMPLEX           = HexToFint(dtypes.Item("MPI_C_COMPLEX"))
F77_C_DOUBLE_COMPLEX    = HexToFint(dtypes.Item("MPI_C_DOUBLE_COMPLEX"))
F77_C_LONG_DOUBLE_COMPLEX      = HexToFint(dtypes.Item("MPI_C_LONG_DOUBLE_COMPLEX"))
F77_AINT_W32                = HexToFint(dtypes.Item("MPI_AINT_W32"))
F77_AINT_W64                = HexToFint(dtypes64.Item("MPI_AINT_W64"))
F77_OFFSET_W64              = HexToFint(dtypes.Item("MPI_OFFSET_W64"))

if false then
foo = ""
foo = "F77_MPI_COMPLEX = " &                F77_MPI_COMPLEX          & vbCrLf
foo = foo & "F77_MPI_DOUBLE_COMPLEX = " &   F77_MPI_DOUBLE_COMPLEX   & vbCrLf
foo = foo & "F77_MPI_LOGICAL = " &          F77_MPI_LOGICAL          & vbCrLf
foo = foo & "F77_MPI_REAL = " &             F77_MPI_REAL             & vbCrLf
foo = foo & "F77_MPI_DOUBLE_PRECISION = " & F77_MPI_DOUBLE_PRECISION & vbCrLf
foo = foo & "F77_MPI_INTEGER = " &          F77_MPI_INTEGER          & vbCrLf
foo = foo & "F77_MPI_2INTEGER = " &         F77_MPI_2INTEGER         & vbCrLf
foo = foo & "F77_MPI_2COMPLEX = " &         F77_MPI_2COMPLEX         & vbCrLf
foo = foo & "F77_MPI_2DOUBLE_COMPLEX = " &  F77_MPI_2DOUBLE_COMPLEX  & vbCrLf
foo = foo & "F77_MPI_2REAL = " &            F77_MPI_2REAL            & vbCrLf
foo = foo & "F77_MPI_2DOUBLE_PRECISION = " & F77_MPI_2DOUBLE_PRECISION & vbCrLf
foo = foo & "F77_MPI_CHARACTER = " &        F77_MPI_CHARACTER        & vbCrLf
foo = foo & "F77_MPI_LB = " &               F77_MPI_LB               & vbCrLf
foo = foo & "F77_MPI_PACKED = " &           F77_MPI_PACKED           & vbCrLf
foo = foo & "F77_MPI_UB = " &               F77_MPI_UB               & vbCrLf
foo = foo & "F77_COMPLEX8 = " &             F77_COMPLEX8             & vbCrLf
foo = foo & "F77_COMPLEX16 = " &            F77_COMPLEX16            & vbCrLf
foo = foo & "F77_COMPLEX32 = " &            F77_COMPLEX32            & vbCrLf
foo = foo & "F77_INTEGER1 = " &             F77_INTEGER1             & vbCrLf
foo = foo & "F77_INTEGER2 = " &             F77_INTEGER2             & vbCrLf
foo = foo & "F77_INTEGER4 = " &             F77_INTEGER4             & vbCrLf
foo = foo & "F77_INTEGER8 = " &             F77_INTEGER8             & vbCrLf
foo = foo & "F77_INTEGER16 = " &            F77_INTEGER16            & vbCrLf
foo = foo & "F77_REAL4 = " &                F77_REAL4                & vbCrLf
foo = foo & "F77_REAL8 = " &                F77_REAL8                & vbCrLf
foo = foo & "F77_REAL16 = " &               F77_REAL16               & vbCrLf
'WScript.Echo foo
end if

Function DecorateMPIFuncs(str)
	' uncomment out the HAVE_EXPORTS_MPI_API block
	'str = ReplaceBetweenTags(str, "/*", "HAVE_EXPORT_MPI_API", "*/", "#ifdef MPICH2_STATIC_LIBRARY" & vbCrLf & "#define EXPORT_MPI_API" & vbCrLf & "#else" & vbCrLf & "#ifdef MPICH2_EXPORTS" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllexport)" & vbCrLf & "#else" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllimport)" & vbCrLf & "#endif" & vbCrLf & "#endif" & vbCrLf & "#ifndef MPI_CALL" & vbCrLf & "#define MPI_CALL __cdecl" & vbCrLf & "#endif" & vbCrLf)
	str = Replace(str, "/* --Insert Additional Definitions Here-- */", "#ifdef MPICH2_STATIC_LIBRARY" & vbCrLf & "#define EXPORT_MPI_API" & vbCrLf & "#else" & vbCrLf & "#ifdef MPICH2_EXPORTS" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllexport)" & vbCrLf & "#else" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllimport)" & vbCrLf & "#endif" & vbCrLf & "#endif" & vbCrLf & "#ifndef MPI_CALL" & vbCrLf & "#define MPI_CALL __cdecl" & vbCrLf & "#endif" & vbCrLf)
	' add dllspec and calling convention to the MPI api
	first_index = InStr(str, "#ifndef MPICH_SUPPRESS_PROTOTYPES")
	last_index = InStr(str, "#endif /* MPICH_SUPPRESS_PROTOTYPES */")
	if first_index <> 0 and last_index <> 0 then
		prototypes = Mid(str, first_index, last_index - first_index)
		prototypes = Replace(prototypes, "int MPI_", "EXPORT_MPI_API int MPI_CALL MPI_")
		prototypes = Replace(prototypes, "double PMPI_Wtime", "EXPORT_MPI_API double MPI_CALL PMPI_Wtime")
		prototypes = Replace(prototypes, "double PMPI_Wtick", "EXPORT_MPI_API double MPI_CALL PMPI_Wtick")
		prototypes = Replace(prototypes, "double MPI_Wtime", "EXPORT_MPI_API double MPI_CALL MPI_Wtime")
		prototypes = Replace(prototypes, "double MPI_Wtick", "EXPORT_MPI_API double MPI_CALL MPI_Wtick")
		str = ReplaceBetweenTags(str, "#ifndef MPICH_SUPPRESS_PROTOTYPES", "MPI_Send", "#endif /* MPICH_SUPPRESS_PROTOTYPES */", prototypes & "#endif /* MPICH_SUPPRESS_PROTOTYPES */")
	end if
	' add dllspec and calling convention to the PMPI api
	first_index = InStr(str, "#if !defined(MPI_BUILD_PROFILING)")
	last_index = InStr(str, "#endif  /* MPI_BUILD_PROFILING */")
	if first_index <> 0 and last_index <> 0 then
		prototypes = Mid(str, first_index, last_index - first_index)
		prototypes = Replace(prototypes, "int PMPI_", "EXPORT_MPI_API int MPI_CALL PMPI_")
		prototypes = Replace(prototypes, "double PMPI_Wtime", "EXPORT_MPI_API double MPI_CALL PMPI_Wtime")
		prototypes = Replace(prototypes, "double PMPI_Wtick", "EXPORT_MPI_API double MPI_CALL PMPI_Wtick")
		str = ReplaceBetweenTags(str, "#if", "MPI_BUILD_PROFILING", "#endif  /* MPI_BUILD_PROFILING */", prototypes & "#endif  /* MPI_BUILD_PROFILING */")
	end if
	DecorateMPIFuncs = str
End Function

'
' Get MPICH2 Version & ABI Version
'
Function GetMPICH2Versions(ByRef mpich2Version, ByRef mpich2ABIVersion, ByRef mpich2ReleaseDate)
    mpich2Version = "0.0"
    mpich2ABIVersion = "0.0"
    mpich2ReleaseDate = "0/0/0"
    if f.FileExists("maint\Version") then
        Dim fin, str
        Set fin = f.OpenTextFile("maint\Version")
        Do Until fin.AtEndOfStream
            Dim strTokenArr
            str = fin.ReadLine()
            Trim(str)
            If(StrComp(Left(str, 1), "#") = 0) OR (str = "") Then
                ' Ignore comments and newlines
            Else
                strTokenArr = Split(str, "=", -1 , 1)
                If UBound(strTokenArr, 1) = 1 Then
                    If(StrComp(Left(strTokenArr(0), 14), "MPICH2_VERSION") = 0) Then
                        mpich2Version = strTokenArr(1)
                    ElseIf(StrComp(Left(strTokenArr(0), 17), "MPICH2_ABIVERSION") = 0) Then
                        mpich2ABIVersion = Replace(strTokenArr(1), ":", ".")
                    ElseIf(StrComp(Left(strTokenArr(0), 19), "MPICH2_RELEASE_DATE") = 0) Then
                        mpich2ReleaseDate = strTokenArr(1)
                    ElseIf(StrComp(Left(strTokenArr(0), 19), "libmpich_so_version") = 0) Then
                        'Ignore libmpich so version
                    Else
                        printMsg "ERROR", "Invalid String """ & str & """ found in mpich2 Version file"
                    End If
                Else
                    printMsg "ERROR", "Invalid format in mpich2 Version file. Expected: ""MPICH2_VERSION_NAME MPICH2_VERSION"" format"
                End If
            End If
        Loop
        fin.Close()
    end if
    ' We only care about MPICH2 version for now
    If (StrComp(mpich2Version, "0.0") <> 0) Then
        GetMPICH2Versions = True
    Else
        GetMPICH2Versions = False
    End If
End Function

' Does the string contain only ints ?
Function IsIntString(str)
	Dim regExpObj, matchesCollection
	Set regExpObj = New regexp

	if IsNull(str) then
		IsIntString = False
		Exit Function
	end if
	if IsEmpty(str) then
		IsIntString = False
		Exit Function
	end if

	regExpObj.Pattern = "[^0-9]+"
	regExpObj.Global = True
	regExpObj.IgnoreCase = True
	Set matchesCollection = regExpObj.Execute(str)
	if matchesCollection.Count > 0 then
		IsIntString = False		
	else
		IsIntString = True
	end if
End Function

' Produce a numeric version assuming the following format:
' Version: [MAJ].[MIN].[REV][EXT][EXT_NUMBER]
'                 or
' Version: [MAJ].[MIN].[REV] 
' Example: 1.0.7rc1 has
'          MAJ = 1
'          MIN = 0
'          REV = 7
'          EXT = rc
'          EXT_NUMBER = 1
'
'			1.0.7 has EXT converted to 0 and EXT_NUMBER = 0
'
' Converting to numeric version will convert EXT to a format number:
'          ALPHA (a) = 0
'          BETA (b)  = 1
'          RC (rc)   = 2
'          PATCH (p) = 3
' Regular releases are treated as patch 0
'
' Numeric version will have 1 digit for MAJ, 2 digits for MIN,
' 2 digits for REV, 1 digit for EXT and 2 digits for EXT_NUMBER.
' eg: 1.0.7rc2 = 10007202
' We also support version numbers with a missing REV number like
'   [MAJ].[MIN][EXT][EXT_NUMBER]

Function GetMPICH2NumVersion(ver)
	Dim verTokenArray, numVer, majorVer, minorVer, revNum, ext, extNum, tmpStr
	Dim verTokenArrayIndex, verTokenArrayLastIndex, minorOrRevNum
	Dim regExpObj, matchesCollection, verHasRev, verHasExt
	Set regExpObj = New regexp
	regExpObj.Global = True
	regExpObj.IgnoreCase = True

	GetMPICH2NumVersion = 0
	verTokenArrayIndex = 0
	verTokenArray = Split(ver, ".", -1, 1)
        verTokenArrayLastIndex = UBound(verTokenArray, 1)
	if((verTokenArrayLastIndex > 2) Or (verTokenArrayLastIndex < 1)) then
		printMsg "ERROR", "Error: " & ver & " not in expected format - eg: 1.0.7rc1/1.0rc1"
		Exit Function
	end if 
'       Initially we assume all versions have [REV] & [EXT] and then verify as we parse the version
'       All valid versions have [MAJ] & [MIN] numbers so we don't need to track them
        verHasRev = True
        verHasExt = True

	majorVer = verTokenArray(verTokenArrayIndex)
	verTokenArrayIndex = verTokenArrayIndex + 1
	if (Len(majorVer) = 1) then
		if Not IsIntString(majorVer) then
			printMsg "ERROR","Error: " & ver & " not in expected format - eg: 1.0.7rc1"
			printMsg "ERROR", "Major version :" & majorVer & " is not an int"
			GetMPICH2NumVersion = 0
			Exit Function
		end if
	else
		printMsg "ERROR", "Error: " & ver & " not in expected format - eg: 1.0.7rc1"
		printMsg "ERROR", "Major ver not in range [0-9]"
		GetMPICH2NumVersion = 0
		Exit Function
	end if
	
	minorVer = verTokenArray(verTokenArrayIndex)
'   The field for minorVer also could contain the EXT/EXT_NUM in case revNum is not present
	if Not ((Len(minorVer) < 0) Or (Len(minorVer) > 6)) then
		if IsIntString(minorVer) then
'                       The field for minor version does not contain [EXT]
			if(minorVer <= 9) then
				minorVer = "0" & Right(minorVer, 1)
			end if 
			verTokenArrayIndex = verTokenArrayIndex + 1
                        if(verTokenArrayIndex > verTokenArrayLastIndex) then
'                           The MPICH2 version only has a [MAJ] & [MIN] version numbers
                            verHasRev = False
                            verHasExt = False
                        else
'                           Something more in verTokenArray to parse...there has to be the [REV] number
			    verHasRev = True
                        end if
		else
'                       The MPICH2 version has no rev number, the field for minor ver contains [EXT]
			verHasRev = False
                        verHasExt = True
		end if
	else
		printMsg "ERROR", "Error: " & ver & " not in expected format - eg: 1.0.7rc1"
		printMsg "ERROR", "Minor ver not in range [0-99]"
		Exit Function
	end if


        if(verHasExt) then
            regExpObj.Pattern = "[^0-9]+"
            Set matchesCollection = regExpObj.Execute(verTokenArray(verTokenArrayIndex))
            if(matchesCollection.Count = 1) then
                    tmpStr = matchesCollection(0)
                    verHasExt = True			
                    select case tmpStr
                            case "a"
                                    ext = 0
                            case "b"
                                    ext = 1
                            case "rc"
                                    ext = 2
                            case "p"
                                    ext = 3
                            case Else
                                    verHasExt = False
                    end select
            else
                    verHasExt = False
            end if 
        end if

        if(verHasRev Or verHasExt) then
            regExpObj.Pattern = "[0-9]+"
            Set matchesCollection = regExpObj.Execute(verTokenArray(verTokenArrayIndex))
            if matchesCollection.Count = 0 then
                    printMsg "ERROR", "Error: " & ver & " not in expected format - eg: 1.0.7rc1"
                    printMsg "ERROR", "No revision num specified"
                    Exit Function
            end if

'           If MPICH2 ver has [REV] we are parsing [REV][EXT][EXT_NUM]
'           If MPICH2 ver does not have [REV], but has [EXT], we are parsing [MIN][EXT][EXT_NUM]
            minorOrRevNum = matchesCollection(0)
            if Not ((Len(minorOrRevNum) < 0) Or (Len(minorOrRevNum) > 2)) then
                    if IsIntString(minorOrRevNum) then
                            if( minorOrRevNum <= 9) then
                                    minorOrRevNum = "0" & Right(minorOrRevNum, 1)
                            end if
                    else
                            printMsg "ERROR", "Error: " & ver & " not in expected format - eg: 1.0.7rc1"
                            printMsg "ERROR", "Revision number: " & minorOrRevNum & " not an int"
                            Exit Function
                    end if
            else
                    printMsg "ERROR", "Error: " & ver & " not in expected format - eg: 1.0.7rc1"
                    printMsg "ERROR", "Rev no not in range [0-99]"
                    Exit Function
            end if
            if verHasRev then
                    revNum = minorOrRevNum
            else
                    minorVer = minorOrRevNum
                    revNum = "00"
            end if	
        else
            if Not verHasRev then
                revNum = "00"
            end if
        end if
	
	if verHasExt then
'		There has to be an extension number
		if(matchesCollection.Count = 2) then
			extNum = matchesCollection(1)
			if (Len(extNum) > 0) And (Len(extNum) < 3) then
				if Not IsIntString(extNum) then
					printMsg "ERROR", "Error: " & ver & " not in expected format - eg: 1.0.7rc1"
					printMsg "ERROR", "Extension number : " & extNum & " is not an int"
					Exit Function
				else
					if(extNum <= 9) then
						extNum = "0" & Right(extNum, 1)
					end if
				end if
			else
				printMsg "ERROR", "Error: " & ver & " not in expected format - eg: 1.0.7rc1"
				printMsg "ERROR", "Extension number no in range [0-99]"
				Exit Function
			end if 
		else
			printMsg "ERROR", "Error: " & ver & " not in expected format - eg: 1.0.7rc1"
			printMsg "ERROR", "No version extension number provided"
			Exit Function
		end if
        else
            ext = "0"
            extNum = "00"
	end if

	numVer = majorVer & minorVer & revNum & ext & extNum
	GetMPICH2NumVersion = 0 + numVer
	printMsg "VERBOSE", " MPICH2 NUM VERSION " & numVer
End Function

GetMPICH2Versions mpich2Version, mpich2ABIVersion, mpich2ReleaseDate
printMsg "VERBOSE", "MPICH2_VERSION = " & mpich2Version & " MPICH2_RELEASE_DATE = " & mpich2ReleaseDate
mpich2NumVersion = GetMPICH2NumVersion(mpich2Version)

Function RegExpFind(pattern, str)
   Dim regEx, Match, Matches           ' Create variable.
   Set regEx = New RegExp              ' Create a regular expression.
   regEx.Pattern = pattern             ' Set pattern.
   regEx.IgnoreCase = True             ' Set case insensitivity.
   regEx.Global = True                 ' Set global applicability.
   Set Matches = regEx.Execute(str)    ' Execute search.
   If Matches.Count <> 0 Then
       For Each Match in Matches           ' Return the first match
           RegExpFind = Match.Value
       Exit For
       Next
   Else
       RegExpFind = Null
   End If
End Function

' Append appendString to origString only if appendString is not
' already present in origString

Function appendUniqueString(ByRef origString, ByVal appendString) 
	Dim regExpObj, matchesCollection
	Set regExpObj = New regexp
	regExpObj.Pattern = Trim(appendString) & vbNewLine
	regExpObj.Global  = True
	regExpObj.IgnoreCase = False
	
	Set matchesCollection = regExpObj.Execute(origString)
	If(matchesCollection.Count = 0) Then
		origString = origString & appendString & vbNewLine
		appendUniqueString = True
	Else
		appendUniqueString = False
	End If
End Function

Function ReplaceAtsWithDecoration(ByVal str, use_f77, b64 )
    Dim regEx, Match, Matches
    Set regEx = New RegExp
    regEx.Pattern = "@.[0-9a-z_]*@"
    regEx.IgnoreCase = True
    regEx.Global = True
    Set Matches = regEx.Execute(str)
    For Each Match in Matches
        Select Case Match
            Case "@MPI_AINT@"
                if b64 then
                    str = Replace(str, "@MPI_AINT@", MPI_AINT64_TYPE)
                    str = MPI_AINT64_TYPEDEF_BEGIN & str & MPI_AINT64_TYPEDEF_END
                else
                    str = Replace(str, "@MPI_AINT@", MPI_AINT32)
                end if
        End Select
    Next
    ReplaceAtsWithDecoration = str
End Function

Function ReplaceAts( str, use_f77, b64 )
	Dim regEx, Match, Matches
	Set regEx = New RegExp
	regEx.Pattern = "@.[0-9a-z_]*@"
	regEx.IgnoreCase = True
	regEx.Global = True
	Set Matches = regEx.Execute(str)
	For Each Match in Matches
		Select Case Match
			Case "@MPI_CHAR@"
				str = Replace(str, "@MPI_CHAR@", MPI_CHAR)
			Case "@MPI_SIGNED_CHAR@"
				str = Replace(str, "@MPI_SIGNED_CHAR@", MPI_SIGNED_CHAR)
			Case "@MPI_WCHAR@"
				str = Replace(str, "@MPI_WCHAR@", MPI_WCHAR)
			Case "@MPI_UNSIGNED_CHAR@"
				str = Replace(str, "@MPI_UNSIGNED_CHAR@", MPI_UNSIGNED_CHAR)
			Case "@MPI_SHORT@"
				str = Replace(str, "@MPI_SHORT@", MPI_SHORT)
			Case "@MPI_UNSIGNED_SHORT@"
				str = Replace(str, "@MPI_UNSIGNED_SHORT@", MPI_UNSIGNED_SHORT)
			Case "@MPI_INT@"
				str = Replace(str, "@MPI_INT@", MPI_INT)
			Case "@MPI_UNSIGNED@"
				str = Replace(str, "@MPI_UNSIGNED@", MPI_UNSIGNED)
			Case "@MPI_UNSIGNED_INT@"
				str = Replace(str, "@MPI_UNSIGNED_INT@", MPI_UNSIGNED)
			Case "@MPI_LONG@"
				str = Replace(str, "@MPI_LONG@", MPI_LONG)
			Case "@MPI_UNSIGNED_LONG@"
				str = Replace(str, "@MPI_UNSIGNED_LONG@", MPI_UNSIGNED_LONG)
			Case "@MPI_LONG_LONG@"
				str = Replace(str, "@MPI_LONG_LONG@", MPI_LONG_LONG)
			Case "@MPI_UNSIGNED_LONG_LONG@"
				str = Replace(str, "@MPI_UNSIGNED_LONG_LONG@", MPI_UNSIGNED_LONG_LONG)
			Case "@MPI_FLOAT@"
				str = Replace(str, "@MPI_FLOAT@", MPI_FLOAT)
			Case "@MPI_DOUBLE@"
				str = Replace(str, "@MPI_DOUBLE@", MPI_DOUBLE)
			Case "@MPI_LONG_DOUBLE@"
				str = Replace(str, "@MPI_LONG_DOUBLE@", MPI_LONG_DOUBLE)
			Case "@MPI_BYTE@"
				If use_f77 Then
					str = Replace(str, "@MPI_BYTE@", F77_MPI_BYTE)
				Else
					str = Replace(str, "@MPI_BYTE@", MPI_BYTE)
				End If
			Case "@MPI_WCHAR_T@"
				str = Replace(str, "@MPI_WCHAR_T@", MPI_WCHAR_T)
			Case "@MPI_PACKED@"
				If use_f77 Then
					str = Replace(str, "@MPI_PACKED@", F77_MPI_PACKED)
				Else
					str = Replace(str, "@MPI_PACKED@", MPI_PACKED)
				End If
			Case "@MPI_LB@"
				If use_f77 Then
					str = Replace(str, "@MPI_LB@", F77_MPI_LB)
				Else
					str = Replace(str, "@MPI_LB@", MPI_LB)
				End If
			Case "@MPI_UB@"
				If use_f77 Then
					str = Replace(str, "@MPI_UB@", F77_MPI_UB)
				Else
					str = Replace(str, "@MPI_UB@", MPI_UB)
				End If
			Case "@MPI_FLOAT_INT@"
				str = Replace(str, "@MPI_FLOAT_INT@", MPI_FLOAT_INT)
			Case "@MPI_DOUBLE_INT@"
				str = Replace(str, "@MPI_DOUBLE_INT@", MPI_DOUBLE_INT)
			Case "@MPI_LONG_INT@"
				str = Replace(str, "@MPI_LONG_INT@", MPI_LONG_INT)
			Case "@MPI_SHORT_INT@"
				str = Replace(str, "@MPI_SHORT_INT@", MPI_SHORT_INT)
			Case "@MPI_2INT@"
				str = Replace(str, "@MPI_2INT@", MPI_2INT)
			Case "@MPI_LONG_DOUBLE_INT@"
				str = Replace(str, "@MPI_LONG_DOUBLE_INT@", MPI_LONG_DOUBLE_INT)
			Case "@MPI_CHARACTER@"
				If use_f77 Then
					str = Replace(str, "@MPI_CHARACTER@", F77_MPI_CHARACTER)
				Else
					str = Replace(str, "@MPI_CHARACTER@", MPI_CHARACTER)
				End If
			Case "@MPI_INTEGER@"
				If b64 then
					If use_f77 Then
						str = Replace(str, "@MPI_INTEGER@", F77_MPI_INTEGER_W64)
					Else
						str = Replace(str, "@MPI_INTEGER@", MPI_INTEGER_W64)
					End If
				Else
					If use_f77 Then
						str = Replace(str, "@MPI_INTEGER@", F77_MPI_INTEGER_W32)
					Else
						str = Replace(str, "@MPI_INTEGER@", MPI_INTEGER_W32)
					End If
				End If
			Case "@MPI_REAL@"
				If b64 Then
					If use_f77 Then
						str = Replace(str, "@MPI_REAL@", F77_MPI_REAL_W64)
					Else
						str = Replace(str, "@MPI_REAL@", MPI_REAL_W64)
					End If
				Else
					If use_f77 Then
						str = Replace(str, "@MPI_REAL@", F77_MPI_REAL_W32)
					Else
						str = Replace(str, "@MPI_REAL@", MPI_REAL_W32)
					End If
				End If
			Case "@MPI_LOGICAL@"
				If b64 Then
					If use_f77 Then
						str = Replace(str, "@MPI_LOGICAL@", F77_MPI_LOGICAL_W64)
					Else
						str = Replace(str, "@MPI_LOGICAL@", MPI_LOGICAL_W64)
					End If
				Else
					If use_f77 Then
						str = Replace(str, "@MPI_LOGICAL@", F77_MPI_LOGICAL_W32)
					Else
						str = Replace(str, "@MPI_LOGICAL@", MPI_LOGICAL_W32)
					End If
				End If
			Case "@MPI_COMPLEX@"
				If use_f77 Then
					str = Replace(str, "@MPI_COMPLEX@", F77_MPI_COMPLEX)
				Else
					str = Replace(str, "@MPI_COMPLEX@", MPI_COMPLEX)
				End If
			Case "@MPI_DOUBLE_PRECISION@"
				If use_f77 Then
					str = Replace(str, "@MPI_DOUBLE_PRECISION@", F77_MPI_DOUBLE_PRECISION)
				Else
					str = Replace(str, "@MPI_DOUBLE_PRECISION@", MPI_DOUBLE_PRECISION)
				End If
			Case "@MPI_2INTEGER@"
				If use_f77 Then
					str = Replace(str, "@MPI_2INTEGER@", F77_MPI_2INTEGER)
				Else
					str = Replace(str, "@MPI_2INTEGER@", MPI_2INTEGER)
				End If
			Case "@MPI_2REAL@"
				If use_f77 Then
					str = Replace(str, "@MPI_2REAL@", F77_MPI_2REAL)
				Else
					str = Replace(str, "@MPI_2REAL@", MPI_2REAL)
				End If
			Case "@MPI_DOUBLE_COMPLEX@"
				If use_f77 Then
					str = Replace(str, "@MPI_DOUBLE_COMPLEX@", F77_MPI_DOUBLE_COMPLEX)
				Else
					str = Replace(str, "@MPI_DOUBLE_COMPLEX@", MPI_DOUBLE_COMPLEX)
				End If
			Case "@MPI_2DOUBLE_PRECISION@"
				If use_f77 Then
					str = Replace(str, "@MPI_2DOUBLE_PRECISION@", F77_MPI_2DOUBLE_PRECISION)
				Else
					str = Replace(str, "@MPI_2DOUBLE_PRECISION@", MPI_2DOUBLE_PRECISION)
				End If
			Case "@MPI_2COMPLEX@"
				If use_f77 Then
					str = Replace(str, "@MPI_2COMPLEX@", F77_MPI_2COMPLEX)
				else
					str = Replace(str, "@MPI_2COMPLEX@", MPI_2COMPLEX)
				End If
			Case "@MPI_2DOUBLE_COMPLEX@"
				if use_f77 Then
					str = Replace(str, "@MPI_2DOUBLE_COMPLEX@", F77_MPI_2DOUBLE_COMPLEX)
				Else
					str = Replace(str, "@MPI_2DOUBLE_COMPLEX@", MPI_2DOUBLE_COMPLEX)
				End If
			Case "@MPI_MAX_PROCESSOR_NAME@"
				str = Replace(str, "@MPI_MAX_PROCESSOR_NAME@", MPI_MAX_PROCESSOR_NAME)
			Case "@BSEND_OVERHEAD@"
				if b64 then
					str = Replace(str, "@BSEND_OVERHEAD@", BSEND_OVERHEAD64)
				else
					str = Replace(str, "@BSEND_OVERHEAD@", BSEND_OVERHEAD32)
				end if
			Case "@MPI_AINT@"
				if b64 then
					str = Replace(str, "@MPI_AINT@", MPI_AINT64)
				else
					str = Replace(str, "@MPI_AINT@", MPI_AINT32)
				end if
			Case "@MPI_AINT_DATATYPE@"
				if b64 then
					str = Replace(str, "@MPI_AINT_DATATYPE@", MPI_AINT_W64)
				else
					str = Replace(str, "@MPI_AINT_DATATYPE@", MPI_AINT_W32)
				end if
			Case "@MPI_AINT_FMT_DEC_SPEC@"
				if b64 then
					str = Replace(str, "@MPI_AINT_FMT_DEC_SPEC@", MPI_AINT64_FMT_DEC_SPEC)
				else
					str = Replace(str, "@MPI_AINT_FMT_DEC_SPEC@", MPI_AINT32_FMT_DEC_SPEC)
				end if
			Case "@MPI_AINT_FMT_HEX_SPEC@"
				if b64 then
					str = Replace(str, "@MPI_AINT_FMT_HEX_SPEC@", MPI_AINT64_FMT_HEX_SPEC)
				else
					str = Replace(str, "@MPI_AINT_FMT_HEX_SPEC@", MPI_AINT32_FMT_HEX_SPEC)
				end if
			Case "@MPI_FINT@"
				str = Replace(str, "@MPI_FINT@", MPI_FINT)
			Case "@MPI_OFFSET@"
				str = Replace(str, "@MPI_OFFSET@", MPI_OFFSET)
			Case "@MPI_OFFSET_DATATYPE@"
				str = Replace(str, "@MPI_OFFSET_DATATYPE@", MPI_OFFSET_W64)
			Case "@MPI_OFFSET_TYPEDEF@"
				str = Replace(str, "@MPI_OFFSET_TYPEDEF@", MPI_OFFSET_TYPEDEF)
                        Case "@MPI_INT8_T@"
                                str = Replace(str, "@MPI_INT8_T@", MPI_INT8_T)
                        Case "@MPI_INT16_T@"
                                str = Replace(str, "@MPI_INT16_T@", MPI_INT16_T)
                        Case "@MPI_INT32_T@"
                                str = Replace(str, "@MPI_INT32_T@", MPI_INT32_T)
                        Case "@MPI_INT64_T@"
                                str = Replace(str, "@MPI_INT64_T@", MPI_INT64_T)
                        Case "@MPI_UINT8_T@"
                                str = Replace(str, "@MPI_UINT8_T@", MPI_UINT8_T)
                        Case "@MPI_UINT16_T@"
                                str = Replace(str, "@MPI_UINT16_T@", MPI_UINT16_T)
                        Case "@MPI_UINT32_T@"
                                str = Replace(str, "@MPI_UINT32_T@", MPI_UINT32_T)
                        Case "@MPI_UINT64_T@"
                                str = Replace(str, "@MPI_UINT64_T@", MPI_UINT64_T)
                        Case "@MPI_C_BOOL@"
                                str = Replace(str, "@MPI_C_BOOL@", MPI_C_BOOL)
                        Case "@MPI_C_FLOAT_COMPLEX@"
                                str = Replace(str, "@MPI_C_FLOAT_COMPLEX@", MPI_C_FLOAT_COMPLEX)
                        Case "@MPI_C_DOUBLE_COMPLEX@"
                                str = Replace(str, "@MPI_C_DOUBLE_COMPLEX@", MPI_C_DOUBLE_COMPLEX)
                        Case "@MPI_C_LONG_DOUBLE_COMPLEX@"
                                str = Replace(str, "@MPI_C_LONG_DOUBLE_COMPLEX@", MPI_C_LONG_DOUBLE_COMPLEX)
			Case "@EXTRA_STATUS_DECL@"
				str = Replace(str, "@EXTRA_STATUS_DECL@", EXTRA_STATUS_DECL)
			Case "@HAVE_ROMIO@"
				str = Replace(str, "@HAVE_ROMIO@", HAVE_ROMIO)
			Case "@MPI_REAL4@"
				str = Replace(str, "@MPI_REAL4@", MPI_REAL4)
			Case "@MPI_REAL8@"
				str = Replace(str, "@MPI_REAL8@", MPI_REAL8)
			Case "@MPI_REAL16@"
				str = Replace(str, "@MPI_REAL16@", MPI_REAL16)
			Case "@MPI_COMPLEX8@"
				str = Replace(str, "@MPI_COMPLEX8@", MPI_COMPLEX8)
			Case "@MPI_COMPLEX16@"
				str = Replace(str, "@MPI_COMPLEX16@", MPI_COMPLEX16)
			Case "@MPI_COMPLEX32@"
				str = Replace(str, "@MPI_COMPLEX32@", MPI_COMPLEX32)
			Case "@MPI_INTEGER1@"
				str = Replace(str, "@MPI_INTEGER1@", MPI_INTEGER1)
			Case "@MPI_INTEGER2@"
				str = Replace(str, "@MPI_INTEGER2@", MPI_INTEGER2)
			Case "@MPI_INTEGER4@"
				str = Replace(str, "@MPI_INTEGER4@", MPI_INTEGER4)
			Case "@MPI_INTEGER8@"
				str = Replace(str, "@MPI_INTEGER8@", MPI_INTEGER8)
			Case "@MPI_INTEGER16@"
				str = Replace(str, "@MPI_INTEGER16@", MPI_INTEGER16)
			Case "@MPICH_TIMER_KIND@"
				If bUseCycleCounter Then
					str = Replace(str, "@MPICH_TIMER_KIND@", "USE_WIN86_CYCLE")
				Else
					str = Replace(str, "@MPICH_TIMER_KIND@", "USE_QUERYPERFORMANCECOUNTER")
				End If
			Case "@MPID_TIMER_TYPE@"
				If bUseCycleCounter Then
					str = Replace(str, "@MPID_TIMER_TYPE@", "unsigned __int64")
				Else
					str = Replace(str, "@MPID_TIMER_TYPE@", "LARGE_INTEGER")
				End If
			Case "@DEFINE_MPI_OFFSET@"
				'str = Replace(str, "@DEFINE_MPI_OFFSET@", "typedef __int64 MPI_Offset;")
				'str = Replace(str, "@DEFINE_MPI_OFFSET@", "#if defined(USE_GCC) || defined(__GNUC__)" + vbCrLf + "typedef long long MPI_Offset;" + vbCrLf + "#else" + vbCrLf + "typedef __int64 MPI_Offset;" + vbCrLf + "#endif")
				'str = Replace(str, "@DEFINE_MPI_OFFSET@", "typedef long long MPI_Offset;")
				str = Replace(str, "@DEFINE_MPI_OFFSET@", MPI_OFFSET_TYPEDEF)
			Case "@NEEDS_MPI_FINT@"
				str = Replace(str, "@NEEDS_MPI_FINT@", "")
			Case "@HAVE_MPI_INFO@"
				str = Replace(str, "@HAVE_MPI_INFO@", "#define HAVE_MPI_INFO")
			Case "@HAVE_MPI_DARRAY_SUBARRAY@"
				str = Replace(str, "@HAVE_MPI_DARRAY_SUBARRAY@", "")
			Case "@DEFINE_HAVE_MPI_GREQUEST@"
				str = Replace(str, "@DEFINE_HAVE_MPI_GREQUEST@", "#define HAVE_MPI_GREQUEST 1")
				'str = Replace(str, "@DEFINE_HAVE_MPI_GREQUEST@", "")
			Case "@ADDRESS_KIND@"
				If b64 then
					str = Replace(str, "@ADDRESS_KIND@", "8")
				Else
					str = Replace(str, "@ADDRESS_KIND@", "4")
				End If
			Case "@OFFSET_KIND@"
				str = Replace(str, "@OFFSET_KIND@", "8")
			Case "@F77_COMPLEX16@"
				str = Replace(str, "@F77_COMPLEX16@", F77_COMPLEX16)
			Case "@F77_COMPLEX32@"
				str = Replace(str, "@F77_COMPLEX32@", F77_COMPLEX32)
			Case "@F77_COMPLEX8@"
				str = Replace(str, "@F77_COMPLEX8@", F77_COMPLEX8)
			Case "@F77_INTEGER1@"
				str = Replace(str, "@F77_INTEGER1@", F77_INTEGER1)
			Case "@F77_INTEGER2@"
				str = Replace(str, "@F77_INTEGER2@", F77_INTEGER2)
			Case "@F77_INTEGER4@"
				str = Replace(str, "@F77_INTEGER4@", F77_INTEGER4)
			Case "@F77_INTEGER8@"
				str = Replace(str, "@F77_INTEGER8@", F77_INTEGER8)
			Case "@F77_INTEGER16@"
				str = Replace(str, "@F77_INTEGER16@", F77_INTEGER16)
			Case "@F77_REAL4@"
				str = Replace(str, "@F77_REAL4@", F77_REAL4)
			Case "@F77_REAL8@"
				str = Replace(str, "@F77_REAL8@", F77_REAL8)
			Case "@F77_REAL16@"
				str = Replace(str, "@F77_REAL16@", F77_REAL16)
			Case "@MPI_F77_BYTE@"
				str = Replace(str, "@MPI_F77_BYTE@", F77_MPI_BYTE)
			Case "@MPI_F77_UB@"
				str = Replace(str, "@MPI_F77_UB@", F77_MPI_UB)
			Case "@MPI_F77_LB@"
				str = Replace(str, "@MPI_F77_LB@", F77_MPI_LB)
			Case "@MPI_F77_PACKED@"
				str = Replace(str, "@MPI_F77_PACKED@", F77_MPI_PACKED)
			Case "@MPI_F77_CHAR@"
				str = Replace(str, "@MPI_F77_CHAR@", F77_CHAR)
			Case "@MPI_F77_SIGNED_CHAR@"
				str = Replace(str, "@MPI_F77_SIGNED_CHAR@", F77_SIGNED_CHAR)
			Case "@MPI_F77_UNSIGNED_CHAR@"
				str = Replace(str, "@MPI_F77_UNSIGNED_CHAR@", F77_UNSIGNED_CHAR)
			Case "@MPI_F77_WCHAR@"
				str = Replace(str, "@MPI_F77_WCHAR@", F77_WCHAR)
			Case "@MPI_F77_SHORT@"
				str = Replace(str, "@MPI_F77_SHORT@", F77_SHORT)
			Case "@MPI_F77_UNSIGNED_SHORT@"
				str = Replace(str, "@MPI_F77_UNSIGNED_SHORT@", F77_UNSIGNED_SHORT)
			Case "@MPI_F77_INT@"
				str = Replace(str, "@MPI_F77_INT@", F77_INT)
			Case "@MPI_F77_UNSIGNED@"
				str = Replace(str, "@MPI_F77_UNSIGNED@", F77_UNSIGNED)
			Case "@MPI_F77_LONG@"
				str = Replace(str, "@MPI_F77_LONG@", F77_LONG)
			Case "@MPI_F77_UNSIGNED_LONG@"
				str = Replace(str, "@MPI_F77_UNSIGNED_LONG@", F77_UNSIGNED_LONG)
			Case "@MPI_F77_FLOAT@"
				str = Replace(str, "@MPI_F77_FLOAT@", F77_FLOAT)
			Case "@MPI_F77_DOUBLE@"
				str = Replace(str, "@MPI_F77_DOUBLE@", F77_DOUBLE)
			Case "@MPI_F77_LONG_DOUBLE@"
				str = Replace(str, "@MPI_F77_LONG_DOUBLE@", F77_LONG_DOUBLE)
			Case "@MPI_F77_LONG_LONG_INT@"
				str = Replace(str, "@MPI_F77_LONG_LONG_INT@", F77_LONG_LONG_INT)
			Case "@MPI_F77_UNSIGNED_LONG_LONG@"
				str = Replace(str, "@MPI_F77_UNSIGNED_LONG_LONG@", F77_UNSIGNED_LONG_LONG)
			Case "@MPI_F77_LONG_LONG@"
				str = Replace(str, "@MPI_F77_LONG_LONG@", F77_LONG_LONG)
			Case "@MPI_F77_FLOAT_INT@"
				str = Replace(str, "@MPI_F77_FLOAT_INT@", F77_FLOAT_INT)
			Case "@MPI_F77_DOUBLE_INT@"
				str = Replace(str, "@MPI_F77_DOUBLE_INT@", F77_DOUBLE_INT)
			Case "@MPI_F77_LONG_INT@"
				str = Replace(str, "@MPI_F77_LONG_INT@", F77_LONG_INT)
			Case "@MPI_F77_SHORT_INT@"
				str = Replace(str, "@MPI_F77_SHORT_INT@", F77_SHORT_INT)
			Case "@MPI_F77_2INT@"
				str = Replace(str, "@MPI_F77_2INT@", F77_2INT)
			Case "@MPI_F77_LONG_DOUBLE_INT@"
				str = Replace(str, "@MPI_F77_LONG_DOUBLE_INT@", F77_LONG_DOUBLE_INT)
			Case "@MPI_F77_INT8_T@"
				str = Replace(str, "@MPI_F77_INT8_T@", F77_INT8_T)
			Case "@MPI_F77_INT16_T@"
				str = Replace(str, "@MPI_F77_INT16_T@", F77_INT16_T)
			Case "@MPI_F77_INT32_T@"
				str = Replace(str, "@MPI_F77_INT32_T@", F77_INT32_T)
			Case "@MPI_F77_INT64_T@"
				str = Replace(str, "@MPI_F77_INT64_T@", F77_INT64_T)
			Case "@MPI_F77_UINT8_T@"
				str = Replace(str, "@MPI_F77_UINT8_T@", F77_UINT8_T)
			Case "@MPI_F77_UINT16_T@"
				str = Replace(str, "@MPI_F77_UINT16_T@", F77_UINT16_T)
			Case "@MPI_F77_UINT32_T@"
				str = Replace(str, "@MPI_F77_UINT32_T@", F77_UINT32_T)
			Case "@MPI_F77_UINT64_T@"
				str = Replace(str, "@MPI_F77_UINT64_T@", F77_UINT64_T)
			Case "@MPI_F77_C_BOOL@"
				str = Replace(str, "@MPI_F77_C_BOOL@", F77_C_BOOL)
			Case "@MPI_F77_C_FLOAT_COMPLEX@"
				str = Replace(str, "@MPI_F77_C_FLOAT_COMPLEX@", F77_C_FLOAT_COMPLEX)
			Case "@MPI_F77_C_COMPLEX@"
				str = Replace(str, "@MPI_F77_C_COMPLEX@", F77_C_COMPLEX)
			Case "@MPI_F77_C_DOUBLE_COMPLEX@"
				str = Replace(str, "@MPI_F77_C_DOUBLE_COMPLEX@", F77_C_DOUBLE_COMPLEX)
			Case "@MPI_F77_C_LONG_DOUBLE_COMPLEX@"
				str = Replace(str, "@MPI_F77_C_LONG_DOUBLE_COMPLEX@", F77_C_LONG_DOUBLE_COMPLEX)
			Case "@MPI_F77_AINT@"
                                If b64 Then
                                    str = Replace(str, "@MPI_F77_AINT@", F77_AINT_W64)
                                Else
                                    str = Replace(str, "@MPI_F77_AINT@", F77_AINT_W32)
                                End If
			Case "@MPI_F77_OFFSET@"
				str = Replace(str, "@MPI_F77_OFFSET@", F77_OFFSET_W64)
			Case "@MPI_STATUS_SIZE@"
				str = Replace(str, "@MPI_STATUS_SIZE@", "5")
			Case "@HAVE_CXX_EXCEPTIONS@"
				str = Replace(str, "@HAVE_CXX_EXCEPTIONS@", "1")
			Case "@F77_MPI_ADDRESS@"
				If b64 then
					str = Replace(str, "@F77_MPI_ADDRESS@", "INTEGER*8")
				Else
					str = Replace(str, "@F77_MPI_ADDRESS@", "INTEGER")
				End If
			Case "@F77_MPI_OFFSET@"
				If b64 then
					str = Replace(str, "@F77_MPI_OFFSET@", "INTEGER*8")
				Else
					str = Replace(str, "@F77_MPI_OFFSET@", "INTEGER (KIND=8)")
				End If
                        Case "@WTIME_DOUBLE_TYPE@"
                                str = Replace(str, "@WTIME_DOUBLE_TYPE@", "DOUBLE PRECISION")
			' FIXME: The size of int,... could depend on compiler options
                        ' These defns, *FC*, are specific to the Intel Fortran Compiler on Windows.
                        ' These values may not work for say gfortran
                        ' We should have a way to override these values
			Case "@SIZEOF_FC_INTEGER@"
				If b64 then
					str = Replace(str, "@SIZEOF_FC_INTEGER@", "4")
				Else
					str = Replace(str, "@SIZEOF_FC_INTEGER@", "4")
				End If
			Case "@SIZEOF_FC_REAL@"
				If b64 then
					str = Replace(str, "@SIZEOF_FC_REAL@", "4")
				Else
					str = Replace(str, "@SIZEOF_FC_REAL@", "4")
				End If
			Case "@SIZEOF_FC_CHARACTER@"
				If b64 then
					str = Replace(str, "@SIZEOF_FC_CHARACTER@", "1")
				Else
					str = Replace(str, "@SIZEOF_FC_CHARACTER@", "1")
				End If
			Case "@SIZEOF_FC_DOUBLE_PRECISION@"
				If b64 then
					str = Replace(str, "@SIZEOF_FC_DOUBLE_PRECISION@", "8")
				Else
					str = Replace(str, "@SIZEOF_FC_DOUBLE_PRECISION@", "8")
				End If
                        ' Fortran real model in "precision, range" format
                        Case "@FC_REAL_MODEL@"
                            str = Replace(str, "@FC_REAL_MODEL@", "6 , 37")
                        ' Fortran double model in "precision, range" format
                        Case "@FC_DOUBLE_MODEL@"
                            str = Replace(str, "@FC_DOUBLE_MODEL@", "15 , 307")
                        ' Fortran integer range
                        Case "@FC_INTEGER_MODEL@"
                            str = Replace(str, "@FC_INTEGER_MODEL@", "9")
                        ' Fortran integer model in "range1, kind1, range2, kind2, ..." format
                        Case "@FC_ALL_INTEGER_MODELS@"
                            str = Replace(str, "@FC_ALL_INTEGER_MODELS@", "2 , 1 , 4 , 2 , 9 , 4 , 18 , 8 ,")
                        ' Fortran integer model map in "{range1, kind1, size1}, {range2, kind2, size2}..." format
                        Case "@FC_INTEGER_MODEL_MAP@"
                            str = Replace(str, "@FC_INTEGER_MODEL_MAP@", "{ 2 , 1 , 1 }, { 4 , 2 , 2 }, { 9 , 4 , 4 }, { 18 , 8 , 8 },")
			' REQD = (Real EQuals Double precision) ? "!" : ""
			Case "@REQD@"
				str = Replace(str, "@REQD@", "")
			' REQI1 = (Real EQuals Integer*1) ? "!" : ""
			Case "@REQI1@"
				str = Replace(str, "@REQI1@", "")
			' REQI2 = (Real EQuals Integer*2) ? "!" : ""
			Case "@REQI2@"
				str = Replace(str, "@REQI2@", "")
			' REQI8 = (Real EQuals Integer*8) ? "!" : ""
			Case "@REQI8@"
				str = Replace(str, "@REQI8@", "")
			Case "@PCONTROL_LIST@"
				'str = Replace(str, "@PCONTROL_LIST@", "")
			Case "@configure_input@"
				'str = Replace(str, "@configure_input@", "")
			Case "@CMB_STATUS_ALIGNMENT@"
				'str = Replace(str, "@CMB_STATUS_ALIGNMENT@", "")
			Case "@CMB_1INT_ALIGNMENT@"
				'str = Replace(str, "@CMB_1INT_ALIGNMENT@", "")
			Case "@DLLIMPORT@"
				str = Replace(str, "@DLLIMPORT@", "CDEC$ ATTRIBUTES DLLIMPORT::/MPIFCMB1/" & vbNewLine & "CDEC$ ATTRIBUTES DLLIMPORT::/MPIFCMB2/" & vbNewLine & "CDEC$ ATTRIBUTES DLLIMPORT::/MPIFCMB3/" & vbNewLine & "CDEC$ ATTRIBUTES DLLIMPORT::/MPIFCMB4/" & vbNewLine & "CDEC$ ATTRIBUTES DLLIMPORT::/MPIFCMB5/" & vbNewLine & "CDEC$ ATTRIBUTES DLLIMPORT::/MPIFCMB7/" & vbNewLine & "CDEC$ ATTRIBUTES DLLIMPORT::/MPIFCMB8/")
			Case "@MPID_THREAD_TYPEDEFS@"
				str = Replace(str, "@MPID_THREAD_TYPEDEFS@", mpid_thread_typedefs)
			Case "@MPID_THREAD_FUNCS@"
				str = Replace(str, "@MPID_THREAD_FUNCS@", mpid_thread_funcs)
			Case "@MPIU_DLL_SPEC_DEF@"
				str = Replace(str, "@MPIU_DLL_SPEC_DEF@", mpi_dll_spec_definition)
			Case "@INCLUDE_MPICXX_H@"
				str = Replace(str, "@INCLUDE_MPICXX_H@", "#include ""mpicxx.h""")
			Case "@FORTRAN_BINDING@"
				str = Replace(str, "@FORTRAN_BINDING@", "1")
			Case "@INCLUDE_MPIDDEFS_H@"
				str = Replace(str, "@INCLUDE_MPIDDEFS_H@", "/* No device specific defs */")
			Case "@GNUC_VERSION@"
				str = Replace(str, "@GNUC_VERSION@", "0")
			Case "@GNUC_MINORVERSION@"
				str = Replace(str, "@GNUC_MINORVERSION@", "0")
			Case "@GNUCXX_VERSION@"
				str = Replace(str, "@GNUCXX_VERSION@", "0")
			Case "@GNUCXX_MINORVERSION@"
				str = Replace(str, "@GNUCXX_MINORVERSION@", "0")
			Case "@MPIR_CXX_BOOL@"
				str = Replace(str, "@MPIR_CXX_BOOL@", MPIR_CXX_BOOL)
			Case "@MPIR_CXX_COMPLEX@"
				str = Replace(str, "@MPIR_CXX_COMPLEX@", MPIR_CXX_COMPLEX)
			Case "@MPIR_CXX_DOUBLE_COMPLEX@"
				str = Replace(str, "@MPIR_CXX_DOUBLE_COMPLEX@", MPIR_CXX_DOUBLE_COMPLEX)
			Case "@MPIR_CXX_LONG_DOUBLE_COMPLEX@"
				str = Replace(str, "@MPIR_CXX_LONG_DOUBLE_COMPLEX@", MPIR_CXX_LONG_DOUBLE_COMPLEX)
			Case "@FORTRAN_MPI_OFFSET@"
				str = Replace(str, "@FORTRAN_MPI_OFFSET@", "INTEGER *8")
			Case "@mpe_c99_stdint_inc@"
				str = Replace(str, "@mpe_c99_stdint_inc@", "/* #include <stdint.h> */")
			Case "@mpe_c99_pridxx_inc@"
				str = Replace(str, "@mpe_c99_pridxx_inc@", "/* #include <inttypes.h> */")
			Case "@mpe_int8_t@"
				str = Replace(str, "@mpe_int8_t@", "__int8")
			Case "@mpe_int16_t@"
				str = Replace(str, "@mpe_int16_t@", "__int16")
			Case "@mpe_int32_t@"
				str = Replace(str, "@mpe_int32_t@", "__int32")
			Case "@mpe_int64_t@"
				str = Replace(str, "@mpe_int64_t@", "__int64")
			Case "@mpe_int8_fmt@"
				str = Replace(str, "@mpe_int8_fmt@", """%hhd""")
			Case "@mpe_int16_fmt@"
				str = Replace(str, "@mpe_int16_fmt@", """%hd""")
			Case "@mpe_int32_fmt@"
				str = Replace(str, "@mpe_int32_fmt@", """%ld""")
			Case "@mpe_int64_fmt@"
				str = Replace(str, "@mpe_int64_fmt@", """%lld""")
			Case "@CLOG_PINT@"
				If b64 Then
					str = Replace(str, "@CLOG_PINT@", "__int64")
				Else
					str = Replace(str, "@CLOG_PINT@", "__int32")
				End If
			Case "@PTHREAD_IN_MPI_DEF@"
				str = Replace(str, "@PTHREAD_IN_MPI_DEF@", "#undef HAVE_PTHREAD_IN_MPI")
			Case "@mpe_callstack_impl_type@"
				str = Replace(str, "@mpe_callstack_impl_type@", "/* MPE CALLSTACK NOT IMPLEMENTED IN WINDOWS */")
			Case "@mpe_callstack_string_h@"
				str = Replace(str, "@mpe_callstack_string_h@", "/* MPE CALLSTACK NOT IMPLEMENTED IN WINDOWS */")
			Case "@mpe_callstack_unistd_h@"
				str = Replace(str, "@mpe_callstack_unistd_h@", "/* MPE CALLSTACK NOT IMPLEMENTED IN WINDOWS */")
			' Config options 
			Case "@CONFIGURE_ARGS_CLEAN@"
				str = Replace(str, "@CONFIGURE_ARGS_CLEAN@", "Check winconfigure.wsf for config options")
			Case "@MPICH2_RELEASE_DATE@"
				str = Replace(str, "@MPICH2_RELEASE_DATE@", Date)
			Case "@DEVICE@"
				str = Replace(str, "@DEVICE@", "ch3")
			Case "@CC@"
				str = Replace(str, "@CC@", "cl.exe")
			Case "@CFLAGS@"
				' FIXME: Not the complete list of CFLAGS --- only some listed
				str = Replace(str, "@CFLAGS@", "/O2 /Ob1 /Oi /Oy /W4")
			Case "@CXX@"
				str = Replace(str, "@CXX@", "cl.exe")
			Case "@CXXFLAGS@" 
				' FIXME: Not the complete list of CXXFLAGS --- only some listed
				str = Replace(str, "@CXXFLAGS@", "/O2 /Ob1 /Oi /Oy /W4")
			Case "@F77@"
				str = Replace(str, "@F77@", "ifort.exe")
			Case "@FFLAGS@"
				' FIXME: Not the complete list of FFLAGS --- only some listed
				str = Replace(str, "@FFLAGS@", "/names:lowercase /iface:cref /assume:underscore")
			Case "@FC@"
				str = Replace(str, "@FC@", "ifort.exe")
			Case "@FCFLAGS@"
				' FIXME: Not the complete list of FCFLAGS --- only some listed
				str = Replace(str, "@FCFLAGS@", "/names:lowercase /iface:cref /assume:underscore")
			Case "@MPICH2_VERSION@"
				str = Replace(str, "@MPICH2_VERSION@", mpich2Version)
			Case "@MPICH2_NUMVERSION@"
				str = Replace(str, "@MPICH2_NUMVERSION@", mpich2NumVersion)
			Case "@nemesis_nets_macro_defs@"
				str = Replace(str, "@nemesis_nets_macro_defs@", "#define MPIDI_NEM_NEWTCP_MODULE 0" + vbCrLf + "#define MPIDI_NEM_ND_MODULE 1")
			Case "@nemesis_nets_func_decl@"
				str = Replace(str, "@nemesis_nets_func_decl@", "MPIDI_nem_newtcp_module_funcs, MPIDI_Nem_nd_funcs, MPIDI_nem_none_funcs")
			Case "@nemesis_nets_array_sz@"
				str = Replace(str, "@nemesis_nets_array_sz@", "3")
			Case "@nemesis_nets_func_array@"
				str = Replace(str, "@nemesis_nets_func_array@", "&MPIDI_nem_newtcp_module_funcs, &MPIDI_Nem_nd_funcs, &MPIDI_nem_none_funcs")
			Case "@nemesis_nets_strings@"
				str = Replace(str, "@nemesis_nets_strings@", """newtcp"",""nd"", ""none""")
			Case Else
			'	unhandled_ats = unhandled_ats & Match & vbNewLine
			'	unhandled_ats_count = unhandled_ats_count + 1
				If appendUniqueString(unhandled_ats, Match) Then
					unhandled_ats_count = unhandled_ats_count + 1
				End If	
				unhandled_ats_instances = unhandled_ats_instances + 1
		End Select
	Next
	ReplaceAts = str
End Function


' FIXME: We should add functionality to add prefixes to AddDefinitions and get rid
' of common code in AddOPADefinitions
Sub AddOPADefinitions( fout, filename, b64 )
    If f.FileExists( filename ) Then
    Set f2 = f.OpenTextFile( filename )
    Dim regEx, Match, Matches, define, comment, macroname

    contents = f2.ReadAll()

    Set regEx = New RegExp
    regEx.Pattern = "/\*([^\*]|\*(?!/))*\*/[\r\n]*#undef(\b).+[\r\n]*"
    regEx.IgnoreCase = True
    regEx.Global = True
    Set Matches = regEx.Execute(contents)

    For Each Match in Matches
        comment = RegExpFind("/\*(.|[\r\n])*\*/", Match.Value)
        define = RegExpFind("#undef.*", Match.Value)
        macroname = RegExpFind("(\s).+", define)
        macroname = RegExpFind("(\S)+", macroname)
        fout.WriteLine(comment)
        Select Case macroname
            Case "HAVE_ATOMIC_H"
                fout.WriteLine("/* #undef HAVE_ATOMIC_H */")
            Case "HAVE_GCC_AND_IA64_ASM"
                fout.WriteLine("/* #undef HAVE_GCC_AND_IA64_ASM */")
            Case "HAVE_GCC_AND_POWERPC_ASM"
                fout.WriteLine("/* #undef HAVE_GCC_AND_POWERPC_ASM */")
            Case "HAVE_GCC_AND_SICORTEX_ASM"
                fout.WriteLine("/* #undef HAVE_GCC_AND_SICORTEX_ASM */")
            Case "HAVE_GCC_ATTRIBUTE"
                fout.WriteLine("/* #undef HAVE_GCC_ATTRIBUTE */")
            Case "HAVE_GCC_INTRINSIC_ATOMICS"
                fout.WriteLine("/* #undef HAVE_GCC_INTRINSIC_ATOMICS */")
            Case "HAVE_GCC_X86_32_64"
                fout.WriteLine("/* #undef HAVE_GCC_X86_32_64 */")
            Case "HAVE_GCC_X86_32_64_P3"
                fout.WriteLine("/* #undef HAVE_GCC_X86_32_64_P3 */")
            Case "HAVE_INTRIN_H"
                fout.WriteLine("/* #undef HAVE_INTRIN_H */")
            Case "HAVE_INTTYPES_H"
                fout.WriteLine("/* #undef HAVE_INTTYPES_H */")
            Case "HAVE_LIBPTHREAD"
                fout.WriteLine("/* #undef HAVE_LIBPTHREAD */")
            Case "HAVE_MEMORY_H"
                fout.WriteLine("/* #undef HAVE_MEMORY_H */")
            Case "HAVE_NT_INTRINSICS"
                fout.WriteLine("#define OPA_HAVE_NT_INTRINSICS 1")
            Case "USE_UNSAFE_PRIMITIVES"
                fout.WriteLine("/* #undef USE_UNSAFE_PRIMITIVES */")
            Case "HAVE_PTHREAD_H"
                fout.WriteLine("/* #undef HAVE_PTHREAD_H */")
            Case "HAVE_PTHREAD_YIELD"
                fout.WriteLine("/* #undef HAVE_PTHREAD_YIELD */")
            Case "HAVE_SCHED_YIELD"
                fout.WriteLine("/* #undef HAVE_SCHED_YIELD */")
            Case "HAVE_STDINT_H"
                fout.WriteLine("/* #undef HAVE_STDINT_H */")
            Case "HAVE_STDLIB_H"
                fout.WriteLine("#define OPA_HAVE_STDLIB_H 1")
            Case "HAVE_STRINGS_H"
                fout.WriteLine("/* #undef HAVE_STRINGS_H */")
            Case "HAVE_STRING_H"
                fout.WriteLine("#define OPA_HAVE_STRING_H 1")
            Case "STDC_HEADERS"
                fout.WriteLine("#define OPA_STDC_HEADERS 1")
            Case "HAVE_SUN_ATOMIC_OPS"
                fout.WriteLine("/* #undef HAVE_SUN_ATOMIC_OPS */")
            Case "HAVE_SYS_STAT_H"
                fout.WriteLine("/* #undef HAVE_SYS_STAT_H */")
            Case "HAVE_SYS_TYPES_H"
                fout.WriteLine("#define OPA_HAVE_SYS_TYPES_H 1")
            Case "HAVE_UNISTD_H"
                fout.WriteLine("/* #undef HAVE_UNISTD_H */")
            Case "HAVE_STDDEF_H"
                fout.WriteLine("#define HAVE_STDDEF_H 1")
            Case "HAVE_DLFCN_H"
                fout.WriteLine("/* #undef HAVE_DLFCN_H */")
            Case "LIMIT_THREADS"
                fout.WriteLine("/* #undef LIMIT_THREADS */")
            ' Just using the default value in the unix build for max nthreads
            Case "MAX_NTHREADS"
                fout.WriteLine("#define MAX_NTHREADS 100")
            Case "NDEBUG"
                fout.WriteLine("/* #undef NDEBUG */")
            ' By default allow threads to yield
            ' FIXME: However OPA_TEST_YIELD() is not defined on windows...
            Case "HAVE_STRICT_FAIRNESS_CHECKS"
                fout.WriteLine("/* #undef HAVE_STRICT_FAIRNESS_CHECKS */")
            Case "PACKAGE"
                fout.WriteLine("#define OPA_PACKAGE ""openpa""")
            Case "PACKAGE_TARNAME"
                fout.WriteLine("#define OPA_PACKAGE ""openpa""")
            Case "PACKAGE_BUGREPORT"
                fout.WriteLine("#define OPA_PACKAGE_BUGREPORT ""https://trac.mcs.anl.gov/projects/openpa/tickets""")
            Case "PACKAGE_NAME"
                fout.WriteLine("#define OPA_PACKAGE_NAME ""OpenPA""")
            ' FIXME: Find a better way to update the version of OpenPA package
            Case "PACKAGE_STRING"
                fout.WriteLine("#define OPA_PACKAGE_STRING ""OpenPA 0.0.1""")
            Case "PACKAGE_VERSION"
                fout.WriteLine("#define OPA_PACKAGE_VERSION ""0.0.1""")
            Case "VERSION"
                fout.WriteLine("#define OPA_VERSION ""0.0.1""")
            Case "SIZEOF_INT"
                fout.WriteLine("#define OPA_SIZEOF_INT 4")
            Case "SIZEOF_VOID_P"
                If b64 Then
                    fout.WriteLine("#define OPA_SIZEOF_VOID_P 8")
                Else
                    fout.WriteLine("#define OPA_SIZEOF_VOID_P 4")
                End If
            Case "inline"
                fout.WriteLine("#define inline __inline")
            Case "restrict"
                fout.WriteLine("#define restrict")
            Case "const"
                fout.WriteLine("/* #undef const */")
            Case "USE_LOCK_BASED_PRIMITIVES"
                fout.WriteLine("/* #undef USE_LOCK_BASED_PRIMITIVES */")
            Case "EXPLICIT_EMULATION"
                fout.WriteLine("/* #undef EXPLICIT_EMULATION */")
            ' Windows builds don't rely on libtool - so no need to define
            ' LT_OBJDIR
            Case "LT_OBJDIR"
                fout.WriteLine("/* #undef LT_OBJDIR */")
            Case Else
                'MsgBox("Unhandled definition <" & define & ">")
                If appendUniqueString(unhandled_definitions, macroname) Then
                    unhandled_definitions_count = unhandled_definitions_count + 1
                End If
                unhandled_definitions_instances = unhandled_definitions_instances + 1
                fout.WriteLine("/* unknown definition: " & macroname & " */")
            End Select
            fout.WriteLine("")
        Next
    End If
End Sub

Function CreateMPLDefDict()
    Set customDefDict = Nothing
    Set customDefDict = CreateObject("Scripting.Dictionary")
    customDefDict.Add "PACKAGE", "MPL"
    customDefDict.Add "VERSION", "0.1"
    CreateMPLDefDict = True
End Function

Function FreeMPLDefDict()
    Set customDefDict = Nothing
    FreeMPLDefDict = True
End Function

Function IsLowerCaseChar(c)
    Set regEx = New RegExp
    regEx.Pattern = "[a-z]"
    regEx.IgnoreCase = False
    regEx.Global = True
    If regEx.Test(c) Then
        IsLowerCaseChar = True
    Else
        IsLowerCaseChar = False
    End If
End Function

Function AddPrefixToDefinitions(filename, prefix_str)
    temp_filename = filename & "_temp"
    If f.FileExists(temp_filename) Then
        f.DeleteFile temp_filename, "True"
    End If
    f.MoveFile filename, temp_filename

    Set prefix_file = f.CreateTextFile(filename, true)
    Set temp_file = f.OpenTextFile(temp_filename)
    
    Do While temp_file.AtEndOfStream <> True
        Dim str, define, macroname_val
        str = temp_file.ReadLine()

        define = RegExpFind("(#define|#ifndef)(\b).+[\r\n]*", str)
        Select Case Left(define, 7)
            Case "#define"
                macroname_val = RegExpFind("(\s).+", define)
                str = RegExpFind("(\S).+", macroname_val)
                If IsLowerCaseChar(Left(str, 1)) Then
                    str = "#define " & "_" & LCase(prefix_str) & str
                Else
                    str = "#define " & UCase(prefix_str) & str
                End If
    
            Case "#ifndef"
                macroname_val = RegExpFind("(\s).+", define)
                str = RegExpFind("(\S).+", macroname_val)
                If IsLowerCaseChar(Left(str, 1)) Then
                    str = "#ifndef " & LCase(prefix_str) & str
                Else
                    str = "#ifndef " & UCase(prefix_str) & str
                End If
            Case Else
                ' Just print the line as it is
        End Select        
        prefix_file.WriteLine(str)
    Loop
    
    temp_file.Close()
    prefix_file.Close()
    f.DeleteFile temp_filename, "True"
    AddPrefixToDefinitions = True
End Function

Sub AddDefinitions( fout, filename, b64 )
	If f.FileExists( filename ) Then
		Set f2 = f.OpenTextFile( filename )
		Dim regEx, Match, Matches, define, comment, macroname
		Set regEx = New RegExp
		contents = f2.ReadAll()
        regEx.Pattern = "/\*([^\*]|\*(?!/))*\*/[\r\n]*#undef(\b).+[\r\n]*"
		regEx.IgnoreCase = True
		regEx.Global = True
		Set Matches = regEx.Execute(contents)
		For Each Match in Matches
			comment = RegExpFind("/\*(.|[\r\n])*\*/", Match.Value)
			define = RegExpFind("#undef.*", Match.Value)
			macroname = RegExpFind("(\s).+", define)
			macroname = RegExpFind("(\S)+", macroname)
			fout.WriteLine(comment)
			Select Case macroname
				Case "HAVE_INT8_T"
					fout.WriteLine("#define HAVE_INT8_T 1")
				Case "HAVE_INT16_T"
					fout.WriteLine("#define HAVE_INT16_T 1")
				Case "HAVE_INT32_T"
					fout.WriteLine("#define HAVE_INT32_T 1")
				Case "HAVE_INT64_T"
					fout.WriteLine("#define HAVE_INT64_T 1")
				Case "HAVE_UINT8_T"
					fout.WriteLine("#define HAVE_UINT8_T 1")
				Case "HAVE_UINT16_T"
					fout.WriteLine("#define HAVE_UINT16_T 1")
				Case "HAVE_UINT32_T"
					fout.WriteLine("#define HAVE_UINT32_T 1")
				Case "HAVE_UINT64_T"
					fout.WriteLine("#define HAVE_UINT64_T 1")
                                Case "HAVE__BOOL"
                                        fout.WriteLine("/* #undef HAVE__BOOL */")
                                Case "HAVE__COMPLEX"
                                        fout.WriteLine("/* #undef HAVE__COMPLEX */")
                                Case "HAVE___TYPEOF"
                                        fout.WriteLine("#define HAVE___TYPEOF 1")
                                Case "HAVE_FLOAT__COMPLEX"
                                        fout.WriteLine("/* #undef HAVE_FLOAT__COMPLEX */")
                                Case "HAVE_DOUBLE__COMPLEX"
                                        fout.WriteLine("/* #undef HAVE_DOUBLE__COMPLEX */")
                                Case "HAVE_LONG_DOUBLE__COMPLEX"
                                        fout.WriteLine("/* #undef HAVE_LONG_DOUBLE__COMPLEX */")
				Case "int8_t"
					fout.WriteLine("#define int8_t __int8")
				Case "int16_t"
					fout.WriteLine("#define int16_t __int16")
				Case "int32_t"
					fout.WriteLine("#define int32_t __int32")
				Case "int64_t"
					fout.WriteLine("#define int64_t __int64")
				Case "uint8_t"
					fout.WriteLine("#define uint8_t unsigned __int8")
				Case "_UINT8_T"
					' Needed only for SOLARIS machines
					fout.WriteLine("/* #undef _UINT8_T */")
				Case "uint16_t"
					fout.WriteLine("#define uint16_t unsigned __int16")
				Case "_UINT16_T"
					' Needed only for SOLARIS machines
					fout.WriteLine("/* #undef _UINT16_T */")
				Case "uint32_t"
					fout.WriteLine("#define uint32_t unsigned __int32")
				Case "_UINT32_T"
					' Needed only for SOLARIS machines
					fout.WriteLine("/* #undef _UINT32_T */")
				Case "uint64_t"
					fout.WriteLine("#define uint64_t unsigned __int64")
				Case "_UINT64_T"
					' Needed only for SOLARIS machines
					fout.WriteLine("/* #undef _UINT64_T */")
				Case "u_char"
                                        ' Needed only on unix builds where --enable-strict
                                        ' option removes these types
                                        fout.WriteLine("/* #undef u_char */")
				Case "u_int"
                                        ' Needed only on unix builds where --enable-strict
                                        ' option removes these types
                                        fout.WriteLine("/* #undef u_int */")
				Case "u_long"
                                        ' Needed only on unix builds where --enable-strict
                                        ' option removes these types
                                        fout.WriteLine("/* #undef u_long */")
				Case "u_short"
                                        ' Needed only on unix builds where --enable-strict
                                        ' option removes these types
                                        fout.WriteLine("/* #undef u_short */")
				Case "POINTERINT_t"
					If b64 Then
						fout.WriteLine("#define POINTERINT_t __int64")
					Else
						fout.WriteLine("#define POINTERINT_t __int32")
					End If
				Case "MPIR_Pint"
					If b64 Then
						fout.WriteLine("#define MPIR_Pint __int64")
					Else
						fout.WriteLine("#define MPIR_Pint __int32")
					End If
				Case "MPIR_Upint"
					If b64 Then
						fout.WriteLine("#define MPIR_Upint unsigned __int64")
					Else
						fout.WriteLine("#define MPIR_Upint unsigned __int32")
					End If
				Case "const"
					fout.WriteLine("/* #undef const */")
				Case "inline"
					fout.WriteLine("#define inline __inline")
				Case "STDC_HEADERS"
					fout.WriteLine("#define STDC_HEADERS 1")
				Case "SIZEOF_DOUBLE"
					fout.WriteLine("#define SIZEOF_DOUBLE 8")
				Case "SIZEOF_FLOAT"
					fout.WriteLine("#define SIZEOF_FLOAT 4")
				Case "SIZEOF_INT"
					fout.WriteLine("#define SIZEOF_INT 4")
				Case "SIZEOF_LONG"
					fout.WriteLine("#define SIZEOF_LONG 4")
				Case "SIZEOF_LONG_DOUBLE"
					fout.WriteLine("#define SIZEOF_LONG_DOUBLE 12")
				Case "SIZEOF_LONG_LONG"
					fout.WriteLine("#define SIZEOF_LONG_LONG 8")
				Case "SIZEOF_SHORT"
					fout.WriteLine("#define SIZEOF_SHORT 2")
				Case "SIZEOF_UNSIGNED_CHAR"
					fout.WriteLine("#define SIZEOF_UNSIGNED_CHAR 1")
				Case "SIZEOF_UNSIGNED_INT"
					fout.WriteLine("#define SIZEOF_UNSIGNED_INT 4")
				Case "SIZEOF_UNSIGNED_LONG"
					fout.WriteLine("#define SIZEOF_UNSIGNED_LONG 4")
				Case "SIZEOF_UNSIGNED_LONG_LONG"
					fout.WriteLine("#define SIZEOF_UNSIGNED_LONG_LONG 8")
				Case "SIZEOF_UNSIGNED_SHORT"
					fout.WriteLine("#define SIZEOF_UNSIGNED_SHORT 2")
				Case "SIZEOF_VOID_P"
					If b64 Then
						fout.WriteLine("#define SIZEOF_VOID_P 8")
					Else
						fout.WriteLine("#define SIZEOF_VOID_P 4")
					End If
				Case "SIZEOF_WCHAR_T"
					fout.WriteLine("#define SIZEOF_WCHAR_T 2")
                                ' Now autoconf handles non-built-in types too. So we need to
                                ' define the sizeof these types here
                                Case "SIZEOF_DOUBLE_INT"
                                        fout.WriteLine("#define SIZEOF_DOUBLE_INT " + len_double_int)
                                Case "SIZEOF_FLOAT_INT"
                                        fout.WriteLine("#define SIZEOF_FLOAT_INT " + len_float_int)
                                Case "SIZEOF_LONG_DOUBLE_INT"
                                        fout.WriteLine("#define SIZEOF_LONG_DOUBLE_INT " + len_long_double_int)
                                Case "SIZEOF_LONG_INT"
                                        fout.WriteLine("#define SIZEOF_LONG_INT " + len_long_int)
                                Case "SIZEOF_SHORT_INT"
                                        fout.WriteLine("#define SIZEOF_SHORT_INT " + len_short_int)
                                Case "SIZEOF_TWO_INT"
                                        fout.WriteLine("#define SIZEOF_TWO_INT " + len_two_int)
                                Case "SIZEOF__BOOL"
                                        fout.WriteLine("#define SIZEOF__BOOL " + len__Bool)
                                Case "SIZEOF_FLOAT__COMPLEX"
                                        fout.WriteLine("#define SIZEOF__COMPLEX " + len_float__Complex)
                                Case "SIZEOF_DOUBLE__COMPLEX"
                                        fout.WriteLine("#define SIZEOF_DOUBLE__COMPLEX " + len_double__Complex)
                                Case "SIZEOF_LONG_DOUBLE__COMPLEX"
                                        fout.WriteLine("#define SIZEOF_LONG_DOUBLE__COMPLEX " + len_long_double__Complex)
                                ' FIXME: Ugly hack - the sizeof MPIR_Bsend_data_t can change !
                                Case "SIZEOF_MPIR_BSEND_DATA_T"
                                        If b64 Then
                                            fout.WriteLine("#define SIZEOF_MPIR_BSEND_DATA_T " + BSEND_OVERHEAD64)
                                        Else
                                            fout.WriteLine("#define SIZEOF_MPIR_BSEND_DATA_T " + BSEND_OVERHEAD32)
                                        End If
				Case "HAVE_GETCWD"
					fout.WriteLine("#define HAVE_GETCWD 1")
				Case "HAVE_GETHOSTNAME"
					fout.WriteLine("#define HAVE_GETHOSTNAME 1")
				Case "HAVE_PUTENV"
					fout.WriteLine("#define HAVE_PUTENV 1")
				Case "HAVE_SETENV"
					fout.WriteLine("/* #undef HAVE_SETENV */")
				Case "HAVE_SELECT"
					fout.WriteLine("#define HAVE_SELECT 1")
				Case "HAVE_SLEEP"
					fout.WriteLine("#define HAVE_SLEEP 1")
				Case "HAVE_SOCKET"
					fout.WriteLine("#define HAVE_SOCKET 1")
				Case "HAVE_STRDUP"
					fout.WriteLine("#define HAVE_STRDUP 1")
                                Case "HAVE_STRNCMP"
                                        fout.WriteLine("#define HAVE_STRNCMP 1")
                                Case "NEEDS_STRNCMP_DECL"
                                        fout.WriteLine("/* #undef NEEDS_STRNCMP_DECL */")
				Case "HAVE_STRNCASECMP"
					fout.WriteLine("/* #undef HAVE_STRNCASECMP */")
				Case "HAVE_ERRNO_H"
					fout.WriteLine("#define HAVE_ERRNO_H 1")
                                Case "HAVE_MATH_H"
                                        fout.WriteLine("#define HAVE_MATH_H 1")
				Case "HAVE_FCNTL_H"
					fout.WriteLine("#define HAVE_FCNTL_H 1")
				Case "HAVE_STDLIB_H"
					fout.WriteLine("#define HAVE_STDLIB_H 1")
				Case "HAVE_STDIO_H"
					fout.WriteLine("#define HAVE_STDIO_H")
				Case "HAVE_ERROR_CHECKING"
                                    ' FIXME: Ideally we should enable the error checking level
                                    ' for 32-bit builds in vsprojs
                                    If b64 Then
                                        ' On the 64-bit builds the level of error checking is
                                        ' controlled from the makefile
                                        fout.WriteLine("/* #undef HAVE_ERROR_CHECKING */")
                                    Else
                                        fout.WriteLine("#define HAVE_ERROR_CHECKING MPID_ERROR_LEVEL_ALL")
                                    End If
				Case "HAVE_TIMING MPID_TIMING_KIND_LOG"
					fout.WriteLine("/*#define HAVE_TIMING MPID_TIMING_KIND_LOG*/")
				Case "HAVE_TIMING MPID_TIMING_KIND_ALL"
					fout.WriteLine("/*#define HAVE_TIMING MPID_TIMING_KIND_ALL*/")
				Case "USE_LOGGING MPID_LOGGING_RLOG"
					fout.WriteLine("/*#define USE_LOGGING MPID_LOGGING_RLOG*/")
				Case "USE_LOGGING MPID_LOGGING_DLOG"
					fout.WriteLine("/*#define USE_LOGGING MPID_LOGGING_DLOG*/")
				Case "MPICH_SINGLE_THREADED"
					fout.WriteLine("#define MPICH_SINGLE_THREADED ")
				Case "USE_MEMORY_TRACING"
					fout.WriteLine("/* #undef USE_MEMORY_TRACING */")
				Case "restrict"
					fout.WriteLine("#define restrict")
				Case "CHAR_PTR_IS_BYTE"
					fout.WriteLine("/* #undef CHAR_PTR_IS_BYTE */")
				Case "HAVE_GCC_AND_PENTIUM_ASM"
					fout.WriteLine("/* #undef HAVE_GCC_AND_PENTIUM_ASM */")
				Case "HAVE_INTTYPES_H"
					fout.WriteLine("/* #undef HAVE_INTTYPES_H */")
				Case "HAVE_MEMORY_H"
					fout.WriteLine("/* #undef HAVE_MEMORY_H */")
				Case "HAVE_PRAGMA_CRI_DUP"
					fout.WriteLine("/* #undef HAVE_PRAGMA_CRI_DUP */")
				Case "HAVE_PRAGMA_HP_SEC_DEF"
					fout.WriteLine("/* #undef HAVE_PRAGMA_HP_SEC_DEF */")
				Case "HAVE_PRAGMA_WEAK"
					fout.WriteLine("/* #undef HAVE_PRAGMA_WEAK */")
                                Case "HAVE_SIGACTION"
                                        fout.WriteLine("/* #undef HAVE_SIGACTION */")
				Case "HAVE_PTHREAD_CREATE"
					fout.WriteLine("/* #undef HAVE_PTHREAD_CREATE */")
                                Case "HAVE_PTHREAD_BARRIER_INIT"
					fout.WriteLine("/* #undef HAVE_PTHREAD_BARRIER_INIT */")
                                Case "HAVE_PTHREAD_BARRIER_WAIT"
					fout.WriteLine("/* #undef HAVE_PTHREAD_BARRIER_WAIT */")
				Case "USE_PTHREAD_STDIN_REDIRECTION"
					fout.WriteLine("/* #undef USE_PTHREAD_STDIN_REDIRECTION */")
                                Case "HAVE_TERMIOS_H"
                                        fout.WriteLine("/* #undef HAVE_TERMIOS_H */")
				Case "HAVE_STDINT_H"
					fout.WriteLine("/* #undef HAVE_STDINT_H */")
				Case "HAVE_STRINGS_H"
					fout.WriteLine("/* #undef HAVE_STRINGS_H */")
				Case "HAVE_STRING_H"
					fout.WriteLine("#define HAVE_STRING_H")
				Case "HAVE_SYS_STAT_H"
					fout.WriteLine("/* #undef HAVE_SYS_STAT_H */")
				Case "HAVE_SYS_TYPES_H"
					fout.WriteLine("#define HAVE_SYS_TYPES_H 1")
				Case "HAVE_SYS_ATTR_H"
					fout.WriteLine("/* #undef HAVE_SYS_ATTR_H */")
				Case "HAVE_THR_CREATE"
					fout.WriteLine("/* #undef HAVE_THR_CREATE */")
				Case "HAVE_TIMING"
					fout.WriteLine("/* #undef HAVE_TIMING */")
				Case "HAVE_UNISTD_H"
					fout.WriteLine("/* #undef HAVE_UNISTD_H */")
				Case "SIZEOF_INT_IS_AINT"
					If b64 then
						fout.WriteLine("/* #undef SIZEOF_INT_IS_AINT */")
					Else
						fout.WriteLine("#define SIZEOF_INT_IS_AINT")
					End If
				Case "volatile"
					fout.WriteLine("/* #undef volatile */")
				Case "HAVE_GETTIMEOFDAY"
					fout.WriteLine("/*#define HAVE_GETTIMEOFDAY 1*/")
				Case "HAVE_MUTEX_INIT"
					fout.WriteLine("/* #undef HAVE_MUTEX_INIT */")
				Case "HAVE_PTHREAD_MUTEXATTR_INIT"
					fout.WriteLine("/*#define HAVE_PTHREAD_MUTEXATTR_INIT 1*/")
				Case "HAVE_PTHREAD_MUTEXATTR_SETPSHARED"
					fout.WriteLine("/*#define HAVE_PTHREAD_MUTEXATTR_SETPSHARED 1*/")
                                Case "PTHREAD_MUTEX_ERRORCHECK_VALUE"
                                        fout.WriteLine("/* #undef PTHREAD_MUTEX_ERRORCHECK_VALUE */")
				Case "HAVE_SCHED_YIELD"
					fout.WriteLine("/*#define HAVE_SCHED_YIELD 1*/")
				Case "HAVE_SHMAT"
					fout.WriteLine("/* #undef HAVE_SHMAT */")
				Case "HAVE_SHMCTL"
					fout.WriteLine("/* #undef HAVE_SHMCTL */")
				Case "HAVE_SHMDT"
					fout.WriteLine("/* #undef HAVE_SHMDT */")
				Case "HAVE_SHMGET"
					fout.WriteLine("/* #undef HAVE_SHMGET */")
				Case "HAVE_USLEEP"
					fout.WriteLine("/*#define HAVE_USLEEP 1*/")
				Case "HAVE_YIELD"
					fout.WriteLine("/* #undef HAVE_YIELD */")
				Case "HAVE_LINUX_UNISTD_H"
					fout.WriteLine("/* #undef HAVE_LINUX_UNISTD_H */")
				Case "HAVE_NETDB_H"
					fout.WriteLine("/*#define HAVE_NETDB_H 1*/")
				Case "HAVE_NETINET_IN_H"
					fout.WriteLine("/*#define HAVE_NETINET_IN_H 1*/")
				Case "HAVE_NETINET_TCP_H"
					fout.WriteLine("/*#define HAVE_NETINET_TCP_H 1*/")
				Case "HAVE_PTHREAD_H"
					fout.WriteLine("/*#define HAVE_PTHREAD_H 1*/")
				Case "HAVE_SCHED_H"
					fout.WriteLine("/*#define HAVE_SCHED_H 1*/")
				Case "HAVE_SYS_FILIO_H"
					fout.WriteLine("/* #undef HAVE_SYS_FILIO_H */")
				Case "HAVE_SYS_IOCTL_H"
					fout.WriteLine("/*#define HAVE_SYS_IOCTL_H 1*/")
				Case "HAVE_SYS_IPC_H"
					fout.WriteLine("/* #undef HAVE_SYS_IPC_H */")
				Case "HAVE_SYS_PARAM_H"
					fout.WriteLine("/*#define HAVE_SYS_PARAM_H 1*/")
				Case "HAVE_SYS_PTRACE_H"
					fout.WriteLine("/* #undef HAVE_SYS_PTRACE_H */")
				Case "HAVE_SYS_SELECT_H"
					fout.WriteLine("/*#define HAVE_SYS_SELECT_H 1*/")
				Case "HAVE_SYS_SEM_H"
					fout.WriteLine("/* #undef HAVE_SYS_SEM_H */")
				Case "HAVE_SYS_SHM_H"
					fout.WriteLine("/* #undef HAVE_SYS_SHM_H */")
				Case "HAVE_SYS_SOCKET_H"
					fout.WriteLine("/*#define HAVE_SYS_SOCKET_H 1*/")
				Case "HAVE_SYS_TIME_H"
					fout.WriteLine("/*#define HAVE_SYS_TIME_H 1*/")
				Case "HAVE_SYS_UIO_H"
					fout.WriteLine("/*#define HAVE_SYS_UIO_H 1*/")
				Case "HAVE_SYS_WAIT_H"
					fout.WriteLine("/*#define HAVE_SYS_WAIT_H 1*/")
				Case "HAVE_VALUES_H"
					fout.WriteLine("/* #undef HAVE_VALUES_H */")
				Case "HAVE_LIBTHREAD"
					fout.WriteLine("/* #undef HAVE_LIBTHREAD */")
				Case "HAVE_ASSERT_H"
					fout.WriteLine("#define HAVE_ASSERT_H 1")
				Case "HAVE_LIMITS_H"
					fout.WriteLine("#define HAVE_LIMITS_H")
				Case "COLLECT_STATS"
					fout.WriteLine("/* #undef COLLECT_STATS */")
				Case "FILE_NAMEPUB_BASEDIR"
					fout.WriteLine("/* #undef FILE_NAMEPUB_BASEDIR */")
				Case "HAVE_CXX_BINDING"
					fout.WriteLine("#define HAVE_CXX_BINDING 1")
				Case "HAVE_DEBUGGER_SUPPORT"
					fout.WriteLine("/* #undef HAVE_DEBUGGER_SUPPORT */")
				Case "HAVE_DGETTEXT"
					fout.WriteLine("/* #undef HAVE_DGETTEXT */")
				Case "HAVE_FORTRAN_BINDING"
					fout.WriteLine("/* #undef HAVE_FORTRAN_BINDING */")
				Case "HAVE_GCC_ATTRIBUTE"
					fout.WriteLine("/* #undef HAVE_GCC_ATTRIBUTE */")
				Case "HAVE_GETTEXT"
					fout.WriteLine("/* #undef HAVE_GETTEXT */")
				Case "HAVE_LIBINTL_H"
					fout.WriteLine("/* #undef HAVE_LIBINTL_H */")
				Case "HAVE_LONG_DOUBLE"
					fout.WriteLine("#define HAVE_LONG_DOUBLE 1")
				Case "HAVE_LONG_LONG_INT"
					fout.WriteLine("#define HAVE_LONG_LONG_INT 1")
				Case "HAVE_C_ATTR_ALIGNED"
					fout.WriteLine("/* #undef HAVE_C_ATTR_ALIGNED */")
				Case "HAVE_C_MULTI_ATTR_ALIAS"
					fout.WriteLine("/* #undef HAVE_C_MULTI_ATTR_ALIAS */")
				Case "HAVE_MAX_STRUCT_ALIGNMENT"
					'fout.WriteLine("/* #undef HAVE_MAX_STRUCT_ALIGNMENT */")
					'If bWin64 Then
					'	fout.WriteLine("#define HAVE_MAX_STRUCT_ALIGNMENT 8")
					'Else
					'	fout.WriteLine("#define HAVE_MAX_STRUCT_ALIGNMENT 4")
					'End If
					fout.WriteLine("#define HAVE_MAX_STRUCT_ALIGNMENT 8")
				Case "HAVE_MAX_FP_ALIGNMENT"
					fout.WriteLine("#define HAVE_MAX_FP_ALIGNMENT 8")
				Case "HAVE_MAX_INTEGER_ALIGNMENT"
					fout.WriteLine("#define HAVE_MAX_INTEGER_ALIGNMENT 4")
				Case "HAVE_LARGEST_STRUCT_ALIGNMENT"
					fout.WriteLine("/* #undef HAVE_LARGEST_STRUCT_ALIGNMENT */")
				Case "HAVE_DOUBLE_POS_ALIGNMENT"
					fout.WriteLine("/* #undef HAVE_DOUBLE_POS_ALIGNMENT */")
				Case "HAVE_LLINT_POS_ALIGNMENT"
					fout.WriteLine("/* #undef HAVE_LLINT_POS_ALIGNMENT */")
				Case "HAVE_NAMEPUB_SERVICE"
					fout.WriteLine("#define HAVE_NAMEPUB_SERVICE 1")
				Case "HAVE_NO_FORTRAN_MPI_TYPES_IN_C"
					fout.WriteLine("/* #undef HAVE_NO_FORTRAN_MPI_TYPES_IN_C */")
				Case "HAVE_ROMIO"
					fout.WriteLine("/* #undef HAVE_ROMIO */")
				Case "HAVE_SEARCH"
					fout.WriteLine("/* #undef HAVE_SEARCH */")
				Case "HAVE_SNPRINTF"
					fout.WriteLine("#define HAVE_SNPRINTF")
				Case "HAVE_STDARG_H"
					fout.WriteLine("#define HAVE_STDARG_H")
				Case "HAVE_SYS_BITYPES_H"
					fout.WriteLine("/* #undef HAVE_SYS_BITYPES_H */")
				Case "HAVE_THREAD_H"
					fout.WriteLine("/* #undef HAVE_THREAD_H */")
				Case "HAVE_THR_YIELD"
					fout.WriteLine("/* #undef HAVE_THR_YIELD */")
				Case "HAVE_TSEARCH"
					fout.WriteLine("/* #undef HAVE_TSEARCH */")
				Case "HAVE_VA_COPY"
					fout.WriteLine("/* #undef HAVE_VA_COPY */")
				Case "HAVE_VSNPRINTF"
					fout.WriteLine("#define HAVE_VSNPRINTF")
				Case "HAVE_VSPRINTF"
					fout.WriteLine("#define HAVE_VSPRINTF")
				Case "HAVE_PVFS2_CREATE_WITHOUT_LAYOUT"
					fout.WriteLine("/* #undef HAVE_PVFS2_CREATE_WITHOUT_LAYOUT */")
				Case "MPICH_DEBUG_HANDLES"
					fout.WriteLine("/* #undef HAVE_MPICH_DEBUG_HANDLES */")
				Case "MPICH_DEBUG_INTERNAL"
					fout.WriteLine("/* #undef MPICH_DEBUG_INTERNAL */")
				Case "MPICH_DEBUG_NESTING"
					fout.WriteLine("/* #undef MPICH_DEBUG_NESTING */")
				Case "MPICH_ERROR_MSG_LEVEL"
					fout.WriteLine("#define MPICH_ERROR_MSG_LEVEL MPICH_ERROR_MSG_ALL")
				Case "MPICH_INFODLL_LOC"
					fout.WriteLine("/* #undef MPICH_INFODLL_LOC */")
				' After migrating to autoconf 2.62 we no longer use MPIU_[U]INT*
				'Case "MPIU_INT8_T"
				'	fout.WriteLine("#define MPIU_INT8_T __int8")
				'Case "MPIU_INT16_T"
				'	fout.WriteLine("#define MPIU_INT16_T __int16")
				'Case "MPIU_INT32_T"
				'	fout.WriteLine("#define MPIU_INT32_T __int32")
				'Case "MPIU_INT64_T"
				'	fout.WriteLine("#define MPIU_INT64_T __int64")
				'Case "MPIU_UINT8_T"
				'	fout.WriteLine("#define MPIU_UINT8_T unsigned __int8")
				'Case "MPIU_UINT16_T"
				'	fout.WriteLine("#define MPIU_UINT16_T unsigned __int16")
				'Case "MPIU_UINT32_T"
				'	fout.WriteLine("#define MPIU_UINT32_T unsigned __int32")
				'Case "MPIU_UINT64_T"
				'	fout.WriteLine("#define MPIU_UINT64_T unsigned __int64")
				Case "MPIU_SIZE_T"
					fout.WriteLine("#define MPIU_SIZE_T unsigned int")
				Case "NDEBUG"
					fout.WriteLine("/* #undef NDEBUG */")
				Case "NEEDS_POINTER_ALIGNMENT_ADJUST"
					fout.WriteLine("/* #undef NEEDS_POINTER_ALIGNMENT_ADJUST */")
				Case "NEEDS_SNPRINTF_DECL"
					fout.WriteLine("/* #undef NEEDS_SNPRINTF_DECL */")
				Case "NEEDS_STRDUP_DECL"
					fout.WriteLine("/* #undef NEEDS_STRDUP_DECL */")
				Case "NEEDS_PUTENV_DECL"
					fout.WriteLine("/* #undef NEEDS_PUTENV_DECL */")
				Case "PACKAGE_BUGREPORT"
					fout.WriteLine("/* #undef PACKAGE_BUGREPORT */")
				Case "PACKAGE_NAME"
					fout.WriteLine("/* #undef PACKAGE_NAME */")
				Case "PACKAGE_STRING"
					fout.WriteLine("/* #undef PACKAGE_STRING */")
				Case "PACKAGE_TARNAME"
					fout.WriteLine("/* #undef PACKAGE_TARNAME */")
				Case "PACKAGE_VERSION"
					fout.WriteLine("/* #undef PACKAGE_VERSION */")
				Case "USE_COVERAGE"
					fout.WriteLine("/* #undef USE_COVERAGE */")
				Case "USE_FILE_FOR_NAMEPUB"
					fout.WriteLine("/* #undef USE_FILE_FOR_NAMEPUB */")
				Case "USE_GETTEXT"
					fout.WriteLine("/* #undef USE_GETTEXT */")
				Case "USE_LDAP_FOR_NAMEPUB"
					fout.WriteLine("/* #undef USE_LDAP_FOR_NAMEPUB */")
				Case "USE_LOGGING"
					fout.WriteLine("/* #undef USE_LOGGING */")
				Case "USE_TSEARCH_WITH_CHARP"
					fout.WriteLine("/* #undef USE_TSEARCH_WITH_CHARP */")
				Case "USE_WEAK_SYMBOLS"
					fout.WriteLine("/* #undef USE_WEAK_SYMBOLS */")
				Case "HAVE_CPP_VARARGS"
					fout.WriteLine("/* #undef HAVE_CPP_VARARGS */")
				Case "HAVE_CLOCK_GETRES"
					fout.WriteLine("/* #undef HAVE_CLOCK_GETRES */")
				Case "HAVE_CLOCK_GETTIME"
					fout.WriteLine("/* #undef HAVE_CLOCK_GETTIME */")
				Case "HAVE_GETHRTIME"
					fout.WriteLine("/* #undef HAVE_GETHRTIME */")
				Case "HAVE_MPI_WIN_CREATE"
					fout.WriteLine("#define HAVE_MPI_WIN_CREATE 1")
				Case "HAVE_COMPARE_AND_SWAP"
					fout.WriteLine("/* #undef HAVE_COMPARE_AND_SWAP */")
				Case "HAVE_DLFCN_H"
					fout.WriteLine("/* #undef HAVE_DLFCN_H */")
				Case "HAVE_UUID_UUID_H"
					fout.WriteLine("/* #undef HAVE_UUID_UUID_H */")
				Case "HAVE_GCC_ASM_AND_X86_LFENCE"
					fout.WriteLine("/* #undef HAVE_GCC_ASM_AND_X86_LFENCE */")
				Case "HAVE_GCC_ASM_AND_X86_MFENCE"
					fout.WriteLine("/* #undef HAVE_GCC_ASM_AND_X86_MFENCE */")
				Case "HAVE_GCC_ASM_AND_X86_SFENCE"
					fout.WriteLine("/* #undef HAVE_GCC_ASM_AND_X86_SFENCE */")
				Case "HAVE_MMAP"
					fout.WriteLine("/* #undef HAVE_MMAP */")
				Case "HAVE_MPP_SHMEM_H"
					fout.WriteLine("/* #undef HAVE_MPP_SHMEM_H */")
				Case "HAVE_SHM_OPEN"
					fout.WriteLine("/* #undef HAVE_SHM_OPEN */")
				Case "HAVE_SHM_UNLINK"
					fout.WriteLine("/* #undef HAVE_SHM_UNLINK */")
				Case "HAVE_SYS_MMAN_H"
					fout.WriteLine("/* #undef HAVE_SYS_MMAN_H */")
				Case "HAVE_SYSCONF"
					fout.WriteLine("/* #undef HAVE_SYSCONF */")
				Case "HAVE_NET_IF_H"
					fout.WriteLine("/* #undef HAVE_NET_IF_H */")
				Case "HAVE_SYS_SOCKIO_H"
					fout.WriteLine("/* #undef HAVE_SYS_SOCKIO_H */")
				Case "HAVE_ARPA_INET_H"
					fout.WriteLIne("/* #undef HAVE_ARPA_INET_H */")
				Case "HAVE_CTYPE_H"
					fout.WriteLine("#define HAVE_CTYPE_H")
				Case "HAVE_GETPAGESIZE"
					fout.WriteLine("/* #undef HAVE_GETPAGESIZE */")
				Case "HAVE_MQUEUE_H"
					fout.WriteLine("/* #undef HAVE_MQUEUE_H */")
				Case "HAVE_MQ_OPEN"
					fout.WriteLine("/* #undef HAVE_MQ_OPEN */")
				Case "HAVE_MSGGET"
					fout.WriteLine("/* #undef HAVE_MSGGET */")
				Case "HAVE_PROCESS_H"
					fout.WriteLine("#define HAVE_PROCESS_H")
				Case "HAVE_MULTIPLE_PRAGMA_WEAK"
					fout.WriteLine("/* #undef HAVE_MULTIPLE_PRAGMA_WEAK */")
				Case "MPICH_CPU_TICK_TYPE"
					fout.WriteLine("#define MPICH_CPU_TICK_TYPE USE_WIN_X86_CYCLE_ASM")
				Case "USE_BUSY_LOCKS"
					fout.WriteLine("/* #undef USE_BUSY_LOCKS */")
				Case "USE_MQSHM"
					fout.WriteLine("/* #undef USE_MQSHM */")
				Case "USE_ATOMIC_UPDATES"
					fout.WriteLine("/* #undef USE_ATOMIC_UPDATES */")
				Case "F77_FALSE_VALUE"
					fout.WriteLine("#define F77_FALSE_VALUE 0")
				Case "F77_TRUE_VALUE"
					' Intel Fotran uses -1
					' Compaq Visual Fortran uses 1
					fout.WriteLine("#define F77_TRUE_VALUE -1")
				Case "F77_TRUE_VALUE_SET"
					fout.WriteLine("#define F77_TRUE_VALUE_SET 1")
				Case "F77_RUNTIME_VALUES"
					fout.WriteLine("/* #undef F77_RUNTIME_VALUES */")
				Case "HAVE_AINT_LARGER_THAN_FINT"
					fout.WriteLine("/* #undef HAVE_AINT_LARGER_THAN_FINT */")
				Case "HAVE_FINT_IS_INT"
					fout.WriteLine("/* #undef HAVE_FINT_IS_INT */")
				Case "HAVE_LONG_LONG"
					fout.WriteLine("/* #undef HAVE_LONG_LONG */")
				Case "HAVE_WEAK_SYMBOLS"
					fout.WriteLine("/* #undef HAVE_WEAK_SYMBOLS */")
				Case "SIZEOF_CHAR"
					fout.WriteLine("#define SIZEOF_CHAR 1")
				Case "SIZEOF_F77_DOUBLE_PRECISION"
					fout.WriteLine("#define SIZEOF_F77_DOUBLE_PRECISION 8")
				Case "SIZEOF_F77_INTEGER"
					fout.WriteLine("#define SIZEOF_F77_INTEGER 4")
				Case "SIZEOF_F77_REAL"
					fout.WriteLine("#define SIZEOF_F77_REAL 4")
				Case "SIZEOF_VOIDP"
					If b64 Then
						fout.WriteLine("#define SIZEOF_VOIDP 8")
					Else
						fout.WriteLine("#define SIZEOF_VOIDP 4")
					End If
				Case "USE_GCC_G77_DECLS"
					fout.WriteLine("/* #undef USE_GCC_G77_DECLS */")
				Case "USE_POINTER_FOR_BOTTOM"
					fout.WriteLine("/* #undef USE_POINTER_FOR_BOTTOM */")
				Case "_TWO_WORD_FCD"
					fout.WriteLine("/* #undef _TWO_WORD_FCD */")
				Case "FORTRAN_SPECIAL_FUNCTION_PTR"
					fout.WriteLine("/* #undef FORTRAN_SPECIAL_FUNCTION_PTR */")
				Case "F77_NAME_LOWER"
					If bf77_name_lower Then
						fout.WriteLine("#define F77_NAME_LOWER")
					Else
						fout.WriteLine("/* #undef F77_NAME_LOWER */")
					End If
				Case "F77_NAME_LOWER_USCORE"
					If bf77_name_lower_uscore Then
						fout.WriteLine("#define F77_NAME_LOWER_USCORE")
					Else
						fout.WriteLine("/* #undef F77_NAME_LOWER_USCORE */")
					End If
				Case "F77_NAME_LOWER_2USCORE"
					If bf77_name_lower_2uscore Then
						fout.WriteLine("#define F77_NAME_LOWER_2USCORE 1")
					Else
						fout.WriteLine("/* #undef F77_NAME_LOWER_2USCORE */")
					End If
				Case "F77_NAME_UPPER"
					if bf77_name_upper Then
						fout.WriteLine("#define F77_NAME_UPPER")
					Else
						fout.WriteLine("/* #undef F77_NAME_UPPER */")
					End If
				Case "F77_NAME_MIXED"
					if bf77_name_mixed Then
						fout.WriteLine("#define F77_NAME_MIXED 1")
					Else
						fout.WriteLine("/* #undef F77_NAME_MIXED */")
					End If
				Case "F77_NAME_MIXED_USCORE"
					if bf77_name_mixed_uscore Then
						fout.WriteLine("#define F77_NAME_MIXED_USCORE 1")
					Else
						fout.WriteLine("/* #undef F77_NAME_MIXED_USCORE */")
					End If
				Case "HAVE_NSLINKMODULE"
					fout.WriteLine("/* #undef HAVE_NSLINKMODULE */")
				Case "HAVE_DLOPEN"
					fout.WriteLine("/* #undef HAVE_DLOPEN */")
				Case "HAVE_MACH_O_DYLD_H"
					fout.WriteLine("/* #undef HAVE_MACH_O_DYLD_H */")
				Case "USE_HUMAN_READABLE_TOKENS"
					fout.WriteLine("#define USE_HUMAN_READABLE_TOKENS 1")
				Case "HAVE_STRERROR"
					fout.WriteLine("#ifndef HAVE_STRERROR")
					fout.WriteLine("#define HAVE_STRERROR 1")
					fout.WriteLine("#endif")
                                Case "HAVE_STRERROR_R"
                                        fout.WriteLine("/* #undef HAVE_STRERROR_R */")
                                Case "STRERROR_R_CHAR_P"
                                        fout.WriteLine("/* #undef STRERROR_R_CHAR_P */")
                                Case "NEEDS_STRERROR_R_DECL"
                                        fout.WriteLine("/* #undef NEEDS_STRERROR_R_DECL */")
                                Case "HAVE_DECL_STRERROR_R"
                                        fout.WriteLine("/* #undef HAVE_DECL_STRERROR_R */")
				Case "HAVE_ASM_AND_X86_LFENCE"
					fout.WriteLine("/* #undef HAVE_ASM_AND_X86_LFENCE */")
				Case "HAVE_ASM_AND_X86_MFENCE"
					fout.WriteLine("/* #undef HAVE_ASM_AND_X86_MFENCE */")
				Case "HAVE_ASM_AND_X86_SFENCE"
					fout.WriteLine("/* #undef HAVE_ASM_AND_X86_SFENCE */")
				Case "HAVE___ASM_AND_X86_LFENCE"
					fout.WriteLine("/* #undef HAVE___ASM_AND_X86_LFENCE */")
				Case "HAVE___ASM_AND_X86_MFENCE"
					fout.WriteLine("/* #undef HAVE___ASM_AND_X86_MFENCE */")
				Case "HAVE___ASM_AND_X86_SFENCE"
					fout.WriteLine("/* #undef HAVE___ASM_AND_X86_SFENCE */")
				Case "HAVE__INTERLOCKEDEXCHANGE"
					fout.WriteLine("/* #undef HAVE__INTERLOCKEDEXCHANGE */")
				Case "HAVE_GCC_AND_X86_64_ASM"
					fout.WriteLine("/* #undef HAVE_GCC_AND_X86_64_ASM */")
				Case "HAVE_GCC_AND_IA64_ASM"
					fout.WriteLine("/* #undef HAVE_GCC_AND_IA64_ASM */")
				Case "HAVE_GCC_AND_SICORTEX_ASM"
					fout.WriteLine("/* #undef HAVE_GCC_AND_SICORTEX_ASM */")
				Case "HAVE_GCC_INTRINSIC_ATOMICS"
					fout.WriteLine("/* #undef HAVE_GCC_INTRINSIC_ATOMICS */")
				Case "HAVE_SUN_ATOMIC_OPS"
					fout.WriteLine("/* #undef HAVE_SUN_ATOMIC_OPS */")
				Case "SYNC_LOCK_TEST_AND_SET_IS_SWAP"
					fout.WriteLine("/* #undef SYNC_LOCK_TEST_AND_SET_IS_SWAP */")
				Case "NEEDS_SYS_TIME_H"
					fout.WriteLine("/* #undef NEEDS_SYS_TIME_H */")
				Case "HAVE_ALARM"
					fout.WriteLine("/* #undef HAVE_ALARM */")
				Case "HAVE_SETITIMER"
					fout.WriteLine("/* #undef HAVE_SETITIMER */")
				Case "USE_MPI_FOR_NMPI"
					fout.WriteLine("/* #undef USE_MPI_FOR_NMPI */")
				Case "USE_MACROS_FOR_WTIME"
					fout.WriteLine("/* #undef USE_MACROS_FOR_WTIME */")
				Case "HAVE_CSHARP_BINDING"
					fout.WriteLine("/* #undef HAVE_CSHARP_BINDING */")
				Case "MPIR_REAL4_CTYPE"
					fout.WriteLine("#define MPIR_REAL4_CTYPE float")
				Case "MPIR_REAL8_CTYPE"
					fout.WriteLine("#define MPIR_REAL8_CTYPE double")
				Case "MPIR_REAL16_CTYPE"
					fout.WriteLine("/* #undef MPIR_REAL16_CTYPE */")
				Case "MPIR_INTEGER1_CTYPE"
					fout.WriteLine("/* #undef MPIR_INTEGER1_CTYPE */")
				Case "MPIR_INTEGER2_CTYPE"
					fout.WriteLine("/* #undef MPIR_INTEGER2_CTYPE */")
				Case "MPIR_INTEGER4_CTYPE"
					fout.WriteLine("/* #undef MPIR_INTEGER4_CTYPE */")
				Case "MPIR_INTEGER8_CTYPE"
					fout.WriteLine("/* #undef MPIR_INTEGER8_CTYPE */")
				Case "MPIR_INTEGER16_CTYPE"
					fout.WriteLine("/* #undef MPIR_INTEGER16_CTYPE */")
				Case "MPIR_CXX_BOOL_CTYPE"
					fout.WriteLine("#define MPIR_CXX_BOOL_CTYPE unsigned char")
				Case "MPIR_CXX_BOOL_VALUE"
					fout.WriteLIne("#define MPIR_CXX_BOOL_VALUE "+ MPIR_CXX_BOOL)
				Case "MPIR_CXX_COMPLEX_VALUE"
					fout.WriteLIne("#define MPIR_CXX_COMPLEX_VALUE "+ MPIR_CXX_COMPLEX)
				Case "MPIR_CXX_DOUBLE_COMPLEX_VALUE"
					fout.WriteLIne("#define MPIR_CXX_DOUBLE_COMPLEX_VALUE "+ MPIR_CXX_DOUBLE_COMPLEX)
				Case "MPIR_CXX_LONG_DOUBLE_COMPLEX_VALUE"
					fout.WriteLIne("#define MPIR_CXX_LONG_DOUBLE_COMPLEX_VALUE "+ MPIR_CXX_LONG_DOUBLE_COMPLEX)
                                Case "MPIR_PINT_FMT_DEC_SPEC"
                                        If b64 Then
                                            fout.WriteLine("#define MPIR_PINT_FMT_DEC_SPEC "+ MPIR_PINT64_FMT_DEC_SPEC)
                                        Else
                                            fout.WriteLine("#define MPIR_PINT_FMT_DEC_SPEC "+ MPIR_PINT32_FMT_DEC_SPEC)
                                        End If
                                Case "MPIR_UPINT_FMT_DEC_SPEC"
                                        If b64 Then
                                            fout.WriteLine("#define MPIR_UPINT_FMT_DEC_SPEC "+ MPIR_UPINT64_FMT_DEC_SPEC)
                                        Else
                                            fout.WriteLine("#define MPIR_UPINT_FMT_DEC_SPEC "+ MPIR_UPINT32_FMT_DEC_SPEC)
                                        End If
				Case "HAVE___VA_COPY"
					fout.WriteLine("/* #undef HAVE___VA_COPY */")
				Case "HAVE_IOSTREAM"
					fout.WriteLine("#define HAVE_IOSTREAM 1")
				Case "HAVE_NAMESPACES"
					fout.WriteLine("#define HAVE_NAMESPACES 1")
				Case "HAVE_NAMESPACE_STD"
					fout.WriteLine("#define HAVE_NAMESPACE_STD 1")
				Case "HAVE_STDDEF_H"
					fout.WriteLine("#define HAVE_STDDEF_H 1")
				Case "HAVE_RUNTIME_THREADCHECK"
					fout.WriteLine("#ifdef MPICH_MULTITHREADED")
					fout.WriteLine("#define HAVE_RUNTIME_THREADCHECK 1")
					fout.WriteLine("#else")
					fout.WriteLine("/* #undef HAVE_RUNTIME_THREADCHECK */")
					fout.WriteLine("#endif")
				Case "MPICH_THREAD_LEVEL"
					fout.WriteLine("#ifdef MPICH_MULTITHREADED")
					fout.WriteLine("#define MPICH_THREAD_LEVEL MPI_THREAD_MULTIPLE")
					fout.WriteLine("#else")
					fout.WriteLine("#define MPICH_THREAD_LEVEL MPI_THREAD_SINGLE")
					fout.WriteLine("#endif")
                                Case "USE_THREAD_IMPL"
                                        fout.WriteLine("#ifdef MPICH_MULTITHREADED")
                                        fout.WriteLine("#define USE_THREAD_IMPL MPICH_THREAD_IMPL_GLOBAL_MUTEX")
                                        fout.WriteLine("#else")
                                        fout.WriteLine("#define USE_THREAD_IMPL MPICH_THREAD_IMPL_NONE")
                                        fout.WriteLine("#endif")
                                Case "MPIU_THREAD_PACKAGE_NAME"
                                        fout.WriteLine("#define MPIU_THREAD_PACKAGE_NAME MPIU_THREAD_PACKAGE_WIN")
				Case "MPIU_THREAD_REFCOUNT"
					fout.WriteLine("#define MPIU_THREAD_REFCOUNT MPIU_REFCOUNT_NONE")
				Case "MPIU_THREAD_GRANULARITY"
					fout.WriteLine("#ifdef MPICH_MULTITHREADED")
					fout.WriteLine("#define MPIU_THREAD_GRANULARITY MPIU_THREAD_GRANULARITY_GLOBAL")
					fout.WriteLine("#else")
					fout.WriteLine("#define MPIU_THREAD_GRANULARITY MPIU_THREAD_GRANULARITY_SINGLE")
					fout.WriteLine("#endif")
                                Case "MPIU_THREAD_SUPPRESS_PREDEFINED_REFCOUNTS"
                                        ' Currently we only build MPICH2 with global lock 
                                        ' -Introduce this option when building lock-free version
                                        fout.WriteLine("/* #undef MPIU_THREAD_SUPPRESS_PREDEFINED_REFCOUNTS */")
                                Case "MPIU_TLS_SPECIFIER"
                                        fout.WriteLine("/* #undef MPIU_TLS_SPECIFIER */")
				Case "MPIU_HANDLE_ALLOCATION_METHOD"
					fout.WriteLine("#define MPIU_HANDLE_ALLOCATION_METHOD MPIU_HANDLE_ALLOCATION_MUTEX")
				Case "MPIU_MUTEX_WAIT_TIME"
					fout.WriteLine("/* #undef MPIU_MUTEX_WAIT_TIME */")
				Case "_REENTRANT"
					fout.WriteLine("/* #undef _REENTRANT */")
				Case "_THREAD_SAFE"
					fout.WriteLine("/* #undef _THREAD_SAFE */")
				Case "HAVE_SYS_POLL_H"
					fout.WriteLine("/* #undef HAVE_SYS_POLL_H */")
				Case "USE_IB_IBAL"
					fout.WriteLine("/* #undef USE_IB_IBAL */")
					fout.WriteLine("/* This is set in the project settings */")
				Case "USE_IB_VAPI"
					fout.WriteLine("/* #define USE_IB_VAPI */")
					fout.WriteLine("/* This is set in the project settings */")
				Case "MPID_IBU_TYPE_UNIX"
					fout.WriteLine("/* #undef MPID_IBU_TYPE_UNIX */")
					'fout.WriteLine("#define MPID_IBU_TYPE_WINDOWS 1")
				Case "HAVE_MALLOC_H"
					fout.WriteLine("#define HAVE_MALLOC_H 1")
				Case "MPICH_DEBUG_MEMINIT"
					fout.WriteLine("/* #undef MPICH_DEBUG_MEMINIT */")
				Case "C_ALLOCA"
					fout.WriteLine("/* #undef C_ALLOCA */")
				Case "HAVE_ALLOCA"
					fout.WriteLine("#define HAVE_ALLOCA 1")
					fout.WriteLine("#define alloca _alloca")
				Case "HAVE_ALLOCA_H"
					fout.WriteLine("/* #undef HAVE_ALLOCA_H */")
				Case "HAVE_PTHREAD_YIELD"
					fout.WriteLine("/* #undef HAVE_PTHREAD_YIELD */")
				Case "HAVE_PTHREAD_MUTEX_RECURSIVE"
					fout.WriteLine("/* #undef HAVE_PTHREAD_MUTEX_RECURSIVE */")
				Case "HAVE_PTHREAD_MUTEX_RECURSIVE_NP"
					fout.WriteLine("/* #undef HAVE_PTHREAD_MUTEX_RECURSIVE_NP */")
				Case "HAVE_MKSTEMP"
					fout.WriteLine("/* #undef HAVE_MKSTEMP */")
				Case "HAVE_O_BINARY"
					fout.WriteLine("#define HAVE_O_BINARY 1")
				Case "_FILE_OFFSET_BITS"
					fout.WriteLine("/* #undef _FILE_OFFSET_BITS */")
				Case "_LARGEFILE64_SOURCE"
					fout.WriteLine("/* #undef _LARGEFILE64_SOURCE */")
				Case "HAVE_MPI_COMM_F2C"
					fout.WriteLine("#define HAVE_MPI_COMM_F2C 1")
				Case "HAVE_MPI_ERRHANDLER_F2C"
					fout.WriteLine("#define HAVE_MPI_ERRHANDLER_F2C 1")
				Case "HAVE_MPI_GROUP_F2C"
					fout.WriteLine("#define HAVE_MPI_GROUP_F2C 1")
				Case "HAVE_MPI_IO"
					fout.WriteLine("#define HAVE_MPI_IO 1")
				Case "HAVE_MPI_OP_F2C"
					fout.WriteLine("#define HAVE_MPI_OP_F2C 1")
				Case "HAVE_MPI_REQUEST_F2C"
					fout.WriteLine("#define HAVE_MPI_REQUEST_F2C 1")
				Case "HAVE_MPI_RMA"
					fout.WriteLine("#define HAVE_MPI_RMA 1")
				Case "HAVE_MPI_STATUSES_IGNORE"
					fout.WriteLine("#define HAVE_MPI_STATUSES_IGNORE 1")
				Case "HAVE_MPI_STATUS_BROKEN_ON_PROC_NULL"
					fout.WriteLine("/* #undef HAVE_MPI_STATUS_BROKEN_ON_PROC_NULL */")
				Case "HAVE_MPI_STATUS_F2C"
					fout.WriteLine("#define HAVE_MPI_STATUS_F2C 1")
				Case "HAVE_MPI_STATUS_IGNORE"
					fout.WriteLine("#define HAVE_MPI_STATUS_IGNORE 1")
				Case "HAVE_MPI_TYPE_F2C"
					fout.WriteLine("#define HAVE_MPI_TYPE_F2C 1")
                                Case "HAVE_MPI_F_INIT_WORKS_WITH_C"
                                        fout.WriteLine("/* #undef HAVE_MPI_F_INIT_WORKS_WITH_C */")
				Case "HAVE_NO_MPIO_REQUEST"
					fout.WriteLine("/* #undef HAVE_NO_MPIO_REQUEST */")
				Case "HAVE_PROTOTYPES"
					fout.WriteLine("#define HAVE_PROTOTYPES 1")
				Case "MPE_F77_FALSE_VALUE"
					fout.WriteLine("#define MPE_F77_FALSE_VALUE 0")
				Case "MPE_F77_TRUE_VALUE"
					fout.WriteLine("#define MPE_F77_TRUE_VALUE -1")
				Case "MPI_Fint"
					fout.WriteLine("/* #undef MPI_Fint */")
				Case "MPI_STATUS_SIZE"
					fout.WriteLine("#define MPI_STATUS_SIZE 5")
				Case "USE_STDARG"
					fout.WriteLine("/* #undef USE_STDARG */")
				Case "HAVE_MPI_WTIME"
					fout.WriteLine("#define HAVE_MPI_WTIME 1")
				Case "STDCALL"
					fout.WriteLine("/* #undef STDCALL */")
				Case "MPICH_DEBUG_FINE_GRAIN_NESTING"
					fout.WriteLine("/* #undef MPICH_DEBUG_FINE_GRAIN_NESTING */")
				Case "HAVE_SPARC_INLINE_PROCESS_LOCKS"
					fout.WriteLine("/* #undef HAVE_SPARC_INLINE_PROCESS_LOCKS */")
				Case "HAVE_IOSTREAM_H"
					fout.WriteLine("/* #undef HAVE_IOSTREAM_H */")
				Case "HAVE_CXX_EXCEPTIONS"
					fout.WriteLine("#define HAVE_CXX_EXCEPTIONS 1")
				Case "bool"
					fout.WriteLine("/* bool */")
				Case "HAVE_ENDIAN_H"
					fout.WriteLine("/* HAVE_ENDIAN_H */")
				Case "WORDS_UNIVERSAL_ENDIAN"
					fout.WriteLine("#undef WORDS_UNIVERSAL_ENDIAN")
				Case "NEEDS_VSNPRINTF_DECL"
					fout.WriteLine("/* NEEDS_VSNPRINTF_DECL */")
				Case "NEEDS_GETHOSTNAME_DECL"
					fout.WriteLine("/* NEEDS_GETHOSTNAME_DECL */")
				Case "NEEDS_MKSTEMP_DECL"
					fout.WriteLine("/* NEEDS_MKSTEMP_DECL */")
				Case "HAVE_MPI_RMA_LOCK"
					fout.WriteLine("#define HAVE_MPI_RMA_LOCK 1")
				Case "HAVE_MPI_RMA_TEST"
					fout.WriteLine("#define HAVE_MPI_RMA_TEST 1")
				Case "HAVE_MPI_F_STATUS_IGNORE"
					fout.WriteLine("#define HAVE_MPI_F_STATUS_IGNORE 1")
				Case "HAVE_MPI_F_STATUSES_IGNORE"
					fout.WriteLine("#define HAVE_MPI_F_STATUSES_IGNORE 1")
				Case "AIO_SIGNOTIFY_NONE"
					fout.WriteLine("/* #undef AIO_SIGNOTIFY_NONE */")
				Case "AIX"
					fout.WriteLine("/* #undef AIX */")
				Case "CRAY"
					fout.WriteLine("/* #undef CRAY */")
				Case "HAVE_AIO_H"
					fout.WriteLine("/* #undef HAVE_AIO_H */")
				Case "HAVE_FSYNC"
					fout.WriteLine("/* #undef HAVE_FSYNC */")
				Case "HAVE_FTRUNCATE"
					fout.WriteLine("/* #undef HAVE_FTRUNCATE */")
				Case "HAVE_LONG_LONG_64"
					fout.WriteLine("/* #undef HAVE_LONG_LONG_64 */")
				Case "HAVE_LSTAT"
					fout.WriteLine("/* #undef HAVE_LSTAT */")
				Case "HAVE_MEMALIGN"
					fout.WriteLine("/* #undef HAVE_MEMALIGN */")
				Case "HAVE_MPI_COMBINERS"
					fout.WriteLine("/* #undef HAVE_MPI_COMBINERS */")
				Case "HAVE_MPI_DARRAY_SUBARRAY"
					fout.WriteLine("#define HAVE_MPI_DARRAY_SUBARRAY 1")
				Case "HAVE_MPI_GREQUEST"
					fout.WriteLine("#define HAVE_MPI_GREQUEST 1")
				Case "HAVE_MPI_INFO"
					fout.WriteLine("#define HAVE_MPI_INFO 1")
				Case "HAVE_MPI_LONG_LONG_INT"
					fout.WriteLine("/* #undef HAVE_MPI_LONG_LONG_INT */")
				Case "HAVE_PREAD64"
					fout.WriteLine("/* #undef HAVE_PREAD64 */")
				Case "HAVE_PVFS2_H"
					fout.WriteLine("/* #undef HAVE_PVFS2_H */")
				Case "HAVE_PVFS2_SUPER_MAGIC"
					fout.WriteLine("/* #undef HAVE_PVFS2_SUPER_MAGIC */")
				Case "HAVE_PVFS_H"
					fout.WriteLine("/* #undef HAVE_PVFS_H */")
				Case "HAVE_PVFS_SUPER_MAGIC"
					fout.WriteLine("/* #undef HAVE_PVFS_SUPER_MAGIC */")
				Case "HAVE_READLINK"
					fout.WriteLine("/* #undef HAVE_READLINK */")
				Case "HAVE_SIGNAL_H"
					fout.WriteLine("/* #undef HAVE_SIGNAL_H */")
				Case "HAVE_SIGNAL"
					fout.WriteLine("/* #undef HAVE_SIGNAL */")
				Case "HAVE_STAT"
					fout.WriteLine("/* #undef HAVE_STAT */")
				Case "HAVE_STATUS_SET_BYTES"
					fout.WriteLine("#define HAVE_STATUS_SET_BYTES 1")
				Case "HAVE_STATVFS"
					fout.WriteLine("/* #undef HAVE_STATVFS */")
				Case "HAVE_STRUCT_STATFS"
					fout.WriteLine("/* #undef HAVE_STRUCT_STATFS */")
				Case "HAVE_SYS_AIO_H"
					fout.WriteLine("/* #undef HAVE_SYS_AIO_H */")
				Case "HAVE_SYS_MOUNT_H"
					fout.WriteLine("/* #undef HAVE_SYS_MOUNT_H */")
				Case "HAVE_SYS_STATVFS_H"
					fout.WriteLine("/* #undef HAVE_SYS_STATVFS_H */")
				Case "HAVE_SYS_VFS_H"
					fout.WriteLine("/* #undef HAVE_SYS_VFS_H */")
				Case "HPUX"
					fout.WriteLine("/* #undef HPUX */")
				Case "INT_LT_POINTER"
					fout.WriteLine("/* #undef INT_LT_POINTER */")
				Case "IRIX"
					fout.WriteLine("/* #undef IRIX */")
				Case "MPICH"
					fout.WriteLine("/* #undef MPICH */")
				Case "MPIHP"
					fout.WriteLine("/* #undef MPIHP */")
				Case "MPILAM"
					fout.WriteLine("/* #undef MPILAM */")
				Case "MPISGI"
					fout.WriteLine("/* #undef MPISGI */")
				Case "MPI_OFFSET_IS_INT"
					fout.WriteLine("/* #undef MPI_OFFSET_IS_INT */")
				Case "SIZEOF_MPI_OFFSET"
					fout.WriteLine("/* #undef SIZEOF_MPI_OFFSET */")
				Case "NEEDS_FSYNC_DECL"
					fout.WriteLine("/* #undef NEEDS_FSYNC_DECL */")
				Case "NEEDS_FTRUNCATE_DECL"
					fout.WriteLine("/* #undef NEEDS_FTRUNCATE_DECL */")
				Case "NEEDS_INT_CAST_WITH_FLOCK"
					fout.WriteLine("/* #undef NEEDS_INT_CAST_WITH_FLOCK */")
				Case "NEEDS_LSTAT_DECL"
					fout.WriteLine("/* #undef NEEDS_LSTAT_DECL */")
				Case "NEEDS_MPI_TEST"
					fout.WriteLine("/* #undef NEEDS_MPI_TEST */")
				Case "NEEDS_READLINK_DECL"
					fout.WriteLine("/* #undef NEEDS_READLINK_DECL */")
				Case "NO_MPI_SGI_type_is_contig"
					fout.WriteLine("/* #undef NO_MPI_SGI_type_is_contig */")
				Case "PRINT_ERR_MSG"
					fout.WriteLine("/* #undef PRINT_ERR_MSG */")
				Case "ROMIO_GRIDFTP"
					fout.WriteLine("/* #undef ROMIO_GRIDFTP */")
				Case "ROMIO_HAVE_AIO_CALLS_NEED_FILEDES"
					fout.WriteLine("/* #undef ROMIO_HAVE_AIO_CALLS_NEED_FILEDES */")
				Case "ROMIO_HAVE_AIO_SUSPEND_TWO_ARGS"
					fout.WriteLine("/* #undef ROMIO_HAVE_AIO_SUSPEND_TWO_ARGS */")
				Case "ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_FILDES"
					fout.WriteLine("/* #undef ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_FILDES */")
				Case "ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_HANDLE"
					fout.WriteLine("/* #undef ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_HANDLE */")
				Case "ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_REQPRIO"
					fout.WriteLine("/* #undef ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_REQPRIO */")
				Case "ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_SIGEVENT"
					fout.WriteLine("/* #undef ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_SIGEVENT */")
				Case "ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_WHENCE"
					fout.WriteLine("/* #undef ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_WHENCE */")
				Case "ROMIO_HAVE_STRUCT_STATFS_WITH_F_FSTYPENAME"
					fout.WriteLine("/* #undef ROMIO_HAVE_STRUCT_STATFS_WITH_F_FSTYPENAME */")
				Case "ROMIO_HAVE_STRUCT_STATVFS_WITH_F_BASETYPE"
					fout.WriteLine("/* #undef ROMIO_HAVE_STRUCT_STATVFS_WITH_F_BASETYPE */")
				Case "ROMIO_HAVE_STRUCT_STAT_WITH_ST_FSTYPE"
					fout.WriteLine("/* #undef ROMIO_HAVE_STRUCT_STAT_WITH_ST_FSTYPE */")
				Case "ROMIO_HAVE_WORKING_AIO"
					fout.WriteLine("/* #undef ROMIO_HAVE_WORKING_AIO */")
				Case "ROMIO_HFS"
					fout.WriteLine("/* #undef ROMIO_HFS */")
				Case "ROMIO_INSIDE_MPICH2"
					fout.WriteLine("#define ROMIO_INSIDE_MPICH2 1")
				Case "ROMIO_NFS"
					fout.WriteLine("/* #undef ROMIO_NFS */")
				Case "ROMIO_PANFS"
					fout.WriteLine("/* #undef ROMIO_PANFS */")
				Case "ROMIO_PFS"
					fout.WriteLine("/* #undef ROMIO_PFS */")
				Case "ROMIO_PVFS"
					fout.WriteLine("/* #undef ROMIO_PVFS */")
				Case "ROMIO_PVFS2"
					fout.WriteLine("/* #undef ROMIO_PVFS2 */")
				Case "ROMIO_PVFS_NEEDS_INT64_DEFINITION"
					fout.WriteLine("/* #undef ROMIO_PVFS_NEEDS_INT64_DEFINITION */")
				Case "ROMIO_SFS"
					fout.WriteLine("/* #undef ROMIO_SFS */")
				Case "ROMIO_TESTFS"
					fout.WriteLine("/* #undef ROMIO_TESTFS */")
				Case "ROMIO_UFS"
					fout.WriteLine("/* #undef ROMIO_UFS */")
				Case "ROMIO_XFS"
					fout.WriteLine("/* #undef ROMIO_XFS */")
				Case "SPPUX"
					fout.WriteLine("/* #undef SPPUX */")
				Case "SX4"
					fout.WriteLine("/* #undef SX4 */")
                                Case "HAVE_LSEEK64"
                                        ' lseeki64 is available on windows
                                        fout.WriteLine("/* #undef HAVE_LSEEK64 */")
                                Case "NEEDS_LSEEK64_DECL"
                                        fout.WriteLine("/* #undef NEEDS_LSEEK64_DECL */")
				Case "USE_DBG_LOGGING"
					fout.WriteLine("/* #undef USE_DBG_LOGGING */")
				Case "HAVE_CFUUIDCREATE"
					fout.WriteLine("/* #undef HAVE_CFUUIDCREATE */")
				Case "HAVE_TIME"
					fout.WriteLine("#define HAVE_TIME 1")
				Case "HAVE_TIME_H"
					fout.WriteLine("#define HAVE_TIME_H 1")
				Case "HAVE_UUID_GENERATE"
					fout.WriteLine("/* #undef HAVE_UUID_GENERATE */")
				Case "HAVE_LRAND48"
					fout.WriteLine("/* #undef HAVE_LRAND48 */")
				Case "HAVE_SRAND48"
					fout.WriteLine("/* #undef HAVE_SRAND48 */")
				Case "NEEDS_LRAND48_DECL"
					fout.WriteLine("/* #undef NEEDS_LRAND48_DECL */")
				Case "NEEDS_SRAND48_DECL"
					fout.WriteLine("/* #undef NEEDS_SRAND48_DECL */")
				Case "HAVE_SHM_RW"
					fout.WriteLine("/* #undef HAVE_SHM_RW */")
				Case "HAVE_WORKING_SHMGET"
					fout.WriteLine("/* #undef HAVE_WORKING_SHMGET */")
				Case "HAVE_PMPI_COMM_CREATE_KEYVAL"
					fout.WriteLine("#define HAVE_PMPI_COMM_CREATE_KEYVAL 1")
				Case "HAVE_PMPI_COMM_FREE_KEYVAL"
					fout.WriteLine("#define HAVE_PMPI_COMM_FREE_KEYVAL 1")
				Case "HAVE_PMPI_COMM_GET_ATTR"
					fout.WriteLine("#define HAVE_PMPI_COMM_GET_ATTR 1")
				Case "HAVE_PMPI_COMM_SET_ATTR"
					fout.WriteLine("#define HAVE_PMPI_COMM_SET_ATTR 1")
				Case "_XOPEN_SOURCE"
					fout.WriteLine("/* #undef _XOPEN_SOURCE */")
				Case "HAVE_SYS_MSG_H"
					fout.WriteLine("/* #undef HAVE_SYS_MSG_H */")
				Case "HAVE_INET_PTON"
					fout.WriteLine("/* #undef HAVE_INET_PTON */")
				Case "_LARGE_FILES"
					fout.WriteLine("/* #undef _LARGE_FILES */")
				Case "HAVE_MAX_DOUBLE_FP_ALIGNMENT"
					fout.WriteLine("#define HAVE_MAX_DOUBLE_FP_ALIGNMENT 8")
				Case "HAVE_MAX_LONG_DOUBLE_FP_ALIGNMENT"
					fout.WriteLine("#define HAVE_MAX_LONG_DOUBLE_FP_ALIGNMENT 8")
				Case "SIZEOF_BOOL"
					fout.WriteLine("#define SIZEOF_BOOL 1")
				Case "SIZEOF_COMPLEX"
					fout.WriteLine("#define SIZEOF_COMPLEX 8")
				Case "SIZEOF_DOUBLECOMPLEX"
					fout.WriteLine("#define SIZEOF_DOUBLECOMPLEX 16")
				Case "SIZEOF_LONGDOUBLECOMPLEX"
					fout.WriteLine("#define SIZEOF_LONGDOUBLECOMPLEX 16")
				Case "size_t"
					fout.WriteLine("/* #define size_t unsigned */")
				Case "HAVE_UTIL_SHM"
					fout.WriteLine("#undef HAVE_UTIL_SHM")
				Case "HAVE_UTIL_SOCK"
					fout.WriteLine("#undef HAVE_UTIL_SOCK")
				Case "pid_t"
					fout.WriteLine("#define pid_t int")
				Case "CLOG_IMPL"
					fout.WriteLine("#undef CLOG_IMPL")
				Case "FIX_STDINT_ORDER"
					fout.WriteLine("#undef FIX_STDINT_ORDER")
				Case "HAVE_CRAY_FCD_STRING"
					fout.WriteLine("#undef HAVE_CRAY_FCD_STRING")
				Case "HAVE_CRAY_FCD_LOGICAL"
					fout.WriteLine("#undef HAVE_CRAY_FCD_LOGICAL")
				Case "HAVE_MPI_SPAWN"
					fout.WriteLine("#undef HAVE_MPI_SPAWN")
				Case "MAKE_SAFE_PMPI_CALL"
					fout.WriteLine("#undef MAKE_SAFE_PMPI_CALL")
				Case "HAVE_MPI_NAMING"
					fout.WriteLine("#undef HAVE_MPI_NAMING")
				Case "HAVE_INT_LT_POINTER"
					If b64 Then
						fout.WriteLine("#define HAVE_INT_LT_POINTER 1")
					Else
						fout.WriteLine("#undef HAVE_INT_LT_POINTER")
					End If
				Case "HAVE_ANY_INT32_T_ALIGNMENT"
					fout.WriteLine("#define HAVE_ANY_INT32_T_ALIGNMENT 1")
				Case "HAVE_ANY_INT64_T_ALIGNMENT"
					fout.WriteLine("#define HAVE_ANY_INT64_T_ALIGNMENT 1")
				Case "WORDS_LITTLEENDIAN"
					fout.WriteLine("#define WORDS_LITTLEENDIAN 1")
				Case "HAVE_STRUCT_IFCONF"
					fout.WriteLine("#undef HAVE_STRUCT_IFCONF")
				Case "USE_SVIDSOURCE_FOR_IFCONF"
					fout.WriteLine("#undef USE_SVIDSOURCE_FOR_IFCONF")
                                Case "USE_ALL_SOURCE_FOR_IFCONF"
                                        fout.WriteLine("/* #undef USE_ALL_SOURCE_FOR_IFCONF */")
				Case "HAVE_SYSCTL"
					fout.WriteLine("#undef HAVE_SYSCTL")
				Case "HAVE_SYS_SYSCTL_H"
					fout.WriteLine("#undef HAVE_SYS_SYSCTL_H")
				' Define to enable nemesis checkpointing
				Case "ENABLE_CHECKPOINTING"
					fout.WriteLine("/* #undef ENABLE_CHECKPOINTING */")
				' Define to disable shm communicn in nemesis 
				' - for debugging
				Case "ENABLED_NO_LOCAL"
					fout.WriteLine("/* #undef ENABLED_NO_LOCAL */")
				' Define to enable shm communicn btw even procs or
				' odd procs in nemesis - for debugging
				Case "ENABLED_ODD_EVEN_CLIQUES"
					fout.WriteLine("/* #undef ENABLED_ODD_EVEN_CLIQUES */")
				' Define to enable shared memory collectives in nemesis
				Case "ENABLED_SHM_COLLECTIVES"
					fout.WriteLine("/* #undef ENABLED_SHM_COLLECTIVES */")
				Case "ENABLE_COMM_OVERRIDES"
					fout.WriteLine("/* #undef ENABLE_COMM_OVERRIDES */")
				Case "USE_PIPE_COLLECTIVES"
					fout.WriteLine("#define USE_PIPE_COLLECTIVES")
				' Define to remove SwithToThread in polling loops in nemesis
				'Case "ENABLE_NO_SCHED_YIELD"
				'	fout.WriteLine("/* #undef ENABLE_NO_SCHED_YIELD */")
				Case "ENABLE_NO_YIELD"
					fout.WriteLine("/* #undef ENABLE_NO_YIELD */")
				' Define for lfence within _asm{} in nemesis
				Case "HAVE_ASM_AND_X86_LFENCE"
					fout.WriteLIne("/* #undef HAVE_ASM_AND_X86_LFENCE */")
				' Define for mfence within _asm{} in nemesis
				Case "HAVE_ASM_AND_X86_MFENCE"
					fout.WriteLIne("/* #undef HAVE_ASM_AND_X86_MFENCE */")
				' Define for sfence within _asm{} in nemesis
				Case "HAVE_ASM_AND_X86_SFENCE"
					fout.WriteLIne("/* #undef HAVE_ASM_AND_X86_SFENCE */")
				' Define for lfence within _asm{} +gcc in nemesis
				Case "HAVE_GCC_ASM_AND_X86_LFENCE"
					fout.WriteLIne("/* #undef HAVE_GCC_ASM_AND_X86_LFENCE */")
				' Define for mfence within _asm{} +gcc in nemesis
				Case "HAVE_GCC_ASM_AND_X86_MFENCE"
					fout.WriteLIne("/* #undef HAVE_GCC_ASM_AND_X86_MFENCE */")
				' Define for sfence within _asm{} in nemesis
				Case "HAVE_GCC_ASM_AND_X86_SFENCE"
					fout.WriteLIne("/* #undef HAVE_GCC_ASM_AND_X86_SFENCE */")
				' Define to turn on inline opt in nemesis
				Case "MPID_NEM_INLINE"
					fout.WriteLine("#define MPID_NEM_INLINE 1")
				' Choosing the net module in nemesis
				Case "MPID_NEM_NET_MODULE"
					fout.WriteLine("#define MPID_NEM_NET_MODULE MPID_NEM_NEWTCP_MODULE")
				Case "MPID_MAD_MODULE_MULTIRAIL"
					fout.WriteLine("/* #undef MPID_MAD_MODULE_MULTIRAIL */")
				' Define if SYSV shm available 
				Case "HAVE_SYSV_SHARED_MEM"
					fout.WriteLine("/* #undef HAVE_SYSV_SHARED_MEM */")
				' Define to turn on prefetching opt in nemesis
				Case "PREFETCH_CELL"
					fout.WriteLine("#define PREFETCH_CELL 1")
				' Define to use fastboxes in nemesis
				Case "USE_FASTBOX"
					fout.WriteLine("#define USE_FASTBOX 1")
				Case "HAVE_LIBCKPT"
					fout.WriteLine("/* #undef HAVE_LIBCKPT */")
				Case "HAVE_LIBCLI"
					fout.WriteLine("/* #undef HAVE_LIBCLI */")
				Case "HAVE_LIBELAN"
					fout.WriteLine("/* #undef HAVE_LIBELAN */")
				Case "HAVE_LIBGM"
					fout.WriteLine("/* #undef HAVE_LIBGM */")
				Case "HAVE_LIBIBVERBS"
					fout.WriteLine("/* #undef HAVE_LIBIBVERBS */")
				Case "HAVE_LIBMYRIEXPRESS"
					fout.WriteLine("/* #undef HAVE_LIBMYRIEXPRESS */")
				Case "HAVE_LIBPSM_INFINIPATH"
					fout.WriteLine("/* #undef HAVE_LIBPSM_INFINIPATH */")
				Case "HAVE_LIBNMAD"
					fout.WriteLine("/* #undef HAVE_LIBNMAD */")
				Case "HAVE_LIBCR"
					fout.WriteLine("/* #undef HAVE_LIBCR */")
				Case "HAVE_MUNMAP"
					fout.WriteLine("/* #undef HAVE_MUNMAP */")
				Case "HAVE_RAND"
					fout.WriteLIne("/* #undef HAVE_RAND */")
				Case "HAVE_SRAND"
					fout.WriteLine("/* #undef HAVE_SRAND */")
				Case "HAVE_STRTOLL"
					fout.WriteLine("/* #undef HAVE_STRTOLL */")
				Case "HAVE_ZOIDFS_H"
					fout.WriteLine("#undef HAVE_ZOIDFS_H")
				Case "HAVE_MPIU_FUNCS"
					fout.WriteLine("#define HAVE_MPIU_FUNCS 1")
				Case "ROMIO_BGL"
					fout.WriteLine("#undef ROMIO_BGL")
				Case "ROMIO_BGLOCKLESS"
					fout.WriteLine("#undef ROMIO_BGLOCKLESS")
				Case "ROMIO_LUSTRE"
					fout.WriteLine("#undef ROMIO_LUSTRE")
                                Case "HAVE_LUSTRE_LUSTRE_USER_H"
                                        fout.WriteLine("/* #undef HAVE_LUSTRE_LUSTRE_USER_H */")
				Case "ROMIO_ZOIDFS"
					fout.WriteLine("#undef ROMIO_ZOIDFS")
				Case "CRAY_STACKSEG_END"
					fout.WriteLine("#undef CRAY_STACKSEG_END")
				Case "HAVE_BINDPROCESSOR"
					fout.WriteLine("#undef HAVE_BINDPROCESSOR")
				Case "HAVE_CPU_SET_MACROS"
					fout.WriteLine("#undef HAVE_CPU_SET_MACROS")
				Case "HAVE_CPU_SET_T"
					fout.WriteLine("#undef HAVE_CPU_SET_T")
				Case "HAVE_CXX_COMPLEX"
					fout.WriteLine("#define HAVE_CXX_COMPLEX 1")
				Case "HAVE_DLSYM"
					fout.WriteLine("#undef HAVE_DLSYM")
				Case "HAVE_DOUBLE_ALIGNMENT_EXCEPTION"
					' FIXME: Doesn't windows 64-bit have alignment exception ? 
					fout.WriteLine("#undef HAVE_DOUBLE_ALIGNMENT_EXCEPTION")
				Case "HAVE_FC_TYPE_ROUTINES"
					fout.WriteLine("#define HAVE_FC_TYPE_ROUTINES")
				Case "HAVE_GETPID"
					fout.WriteLine("#undef HAVE_GETPID")
				Case "HAVE_MPICHCONF"
					fout.WriteLine("#define HAVE_MPICHCONF 1")
				Case "HAVE_OSX_THREAD_AFFINITY"
					fout.WriteLine("#undef HAVE_OSX_THREAD_AFFINITY")
				Case "HAVE_PTHREAD_CLEANUP_PUSH"
					fout.WriteLine("#undef HAVE_PTHREAD_CLEANUP_PUSH")
				Case "HAVE_PTHREAD_CLEANUP_PUSH_MACRO"
					fout.WriteLine("#undef HAVE_PTHREAD_CLEANUP_PUSH_MACRO")
				Case "HAVE_RUNTIME_THREADCHECK"
					fout.WriteLine("#define HAVE_RUNTIME_THREADCHECK 1")
				Case "HAVE_SCHED_GETAFFINITY"
					fout.WriteLine("#undef HAVE_SCHED_GETAFFINITY")
				Case "HAVE_SCHED_SETAFFINITY"
					fout.WriteLine("#undef HAVE_SCHED_SETAFFINITY")
				Case "HAVE_THREAD_POLICY_SET"
					fout.WriteLine("#undef HAVE_THREAD_POLICY_SET")
				Case "LINUX86_CYCLE_CPUID_RDTSC"
					fout.WriteLine("#undef LINUX86_CYCLE_CPUID_RDTSC")
				Case "LINUX86_CYCLE_RDTSC"
					fout.WriteLine("#undef LINUX86_CYCLE_RDTSC")
				Case "LINUX86_CYCLE_RDTSCP"
					fout.WriteLine("#undef LINUX86_CYCLE_RDTSCP")
                                Case "LINUX86_CYCLE_CPUID_RDTSC32"
                                        fout.WriteLine("/* #undef LINUX86_CYCLE_CPUID_RDTSC32 */")
                                Case "LINUX86_CYCLE_CPUID_RDTSC64"
                                        fout.WriteLine("/* #undef LINUX86_CYCLE_CPUID_RDTSC64 */")
                                Case "HAVE_MACH_ABSOLUTE_TIME"
                                        fout.WriteLine("/* #undef HAVE_MACH_ABSOLUTE_TIME */")
				Case "MPICH2_LIBDIR"
					fout.WriteLine("#undef MPICH2_LIBDIR")
                                Case "MPICH_DEBUG_MUTEXNESTING"
                                        fout.WriteLine("/* #undef MPICH_DEBUG_MUTEXNESTING */")
				Case "MPICH_DEBUG_MEMARENA"
					fout.WriteLine("#undef MPICH_DEBUG_MEMARENA")
				Case "MPICH_DEBUG_MUTEX"
					fout.WriteLine("#undef MPICH_DEBUG_MUTEX")
				Case "MPICH_DEBUG_HANDLEALLOC"
					fout.WriteLine("/* #undef MPICH_DEBUG_HANDLEALLOC */")
				Case "STACK_DIRECTION"
					fout.WriteLine("#undef STACK_DIRECTION")
				Case "USE_ALLOCA"
					fout.WriteLine("#undef USE_ALLOCA")
				Case "USE_DYNAMIC_LIBRARIES"
					fout.WriteLine("#undef USE_DYNAMIC_LIBRARIES")
				Case "HAVE_MPIDI_CH3_CONF"
					fout.WriteLine("#define HAVE_MPIDI_CH3_CONF 1")
				Case "USE_NOPOSIX_FOR_IFCONF"
					fout.WriteLine("#undef USE_NOPOSIX_FOR_IFCONF")
				Case "HAVE_MPIDI_CH3SOCKCONF"
					fout.WriteLine("#define HAVE_MPIDI_CH3SOCKCONF")
				Case "HAVE_GCC_ASM_SPARC_MEMBAR"
					fout.WriteLine("#undef HAVE_GCC_ASM_SPARC_MEMBAR")
				Case "HAVE_GCC_ASM_SPARC_STBAR"
					fout.WriteLine("#undef HAVE_GCC_ASM_SPARC_STBAR")
				Case "HAVE_SOLARIS_ASM_SPARC_MEMBAR"
					fout.WriteLine("#undef HAVE_SOLARIS_ASM_SPARC_MEMBAR")
				Case "HAVE_SOLARIS_ASM_SPARC_STBAR"
					fout.WriteLine("#undef HAVE_SOLARIS_ASM_SPARC_STBAR")
				Case "GCC_X86_CYCLE_CPUID_RDTSC"
					fout.WriteLine("/* #undef GCC_X86_CYCLE_CPUID_RDTSC */")
				Case "GCC_X86_CYCLE_RDTSC"
					fout.WriteLine("/* #undef GCC_X86_CYCLE_RDTSC */")
				Case "GCC_X86_CYCLE_RDTSCP"
					fout.WriteLine("/* #undef GCC_X86_CYCLE_RDTSCP */")
				Case "HAVE_LIBPTHREAD"
					fout.WriteLine("#undef HAVE_LIBPTHREAD")
				Case "HAVE_O_LARGEFILE"
					fout.WriteLine("#undef HAVE_O_LARGEFILE")
				Case "HAVE_MPI_INIT_THREAD"
					fout.WriteLine("#define HAVE_MPI_INIT_THREAD 1")
				Case "HAVE_EXECINFO_H"
					fout.WriteLine("#undef HAVE_EXECINFO_H")
				Case "HAVE_FDOPEN"
					fout.WriteLine("#undef HAVE_FDOPEN")
				Case "HAVE_UCONTEXT_H"
					fout.WriteLine("#undef HAVE_UCONTEXT_H")
				Case "NEEDS_FDOPEN_DECL"
					fout.WriteLine("/* #undef NEEDS_FDOPEN_DECL */")
				Case "HAVE_H_ADDR_LIST"
					fout.WriteLine("#define HAVE_H_ADDR_LIST 1")
				Case "HAVE_CAP__FUNC__"
					fout.WriteLine("/* #undef HAVE_CAP__FUNC__ */")
				Case "HAVE__FUNC__"
					fout.WriteLine("/* #undef HAVE__FUNC__ */")
				Case "HAVE__FUNCTION__"
					fout.WriteLine("#define HAVE__FUNCTION__ 1")
				Case "HAVE_MEMCHECK_H"
					fout.WriteLine("/* #undef HAVE_MEMCHECK_H */")
                                Case "HAVE_VALGRIND_MEMCHECK_H"
                                        fout.WriteLine("/* #undef HAVE_VALGRIND_MEMCHECK_H */")
                                Case "HAVE_HELGRIND_H"
                                        fout.WriteLine("/* #undef HAVE_HELGRIND_H */")
				Case "HAVE_VALGRIND_H"
					fout.WriteLine("/* #undef HAVE_VALGRIND_H */")
				Case "HAVE_BROKEN_VALGRIND"
					fout.WriteLine("/* #undef HAVE_BROKEN_VALGRIND */")
                                Case "HAVE_VALGRIND_VALGRIND_H"
                                        fout.WriteLine("/* #undef HAVE_VALGRIND_VALGRIND_H */")
                                Case "HAVE_VALGRIND_HELGRIND_H"
                                        fout.WriteLine("/* #undef HAVE_VALGRIND_HELGRIND_H */")
                                Case "HAVE_DRD_H"
                                        fout.WriteLine("/* #undef HAVE_DRD_H */")
                                Case "HAVE_VALGRIND_DRD_H"
                                        fout.WriteLine("/* #undef HAVE_VALGRIND_DRD_H */")
				Case "USE_SMP_COLLECTIVES"
					fout.WriteLine("#define USE_SMP_COLLECTIVES 1")
				Case "CH3_RANK_BITS"
					fout.WriteLine("#define CH3_RANK_BITS 16")
                                Case "NEEDS_STRNCASECMP_DECL"
                                        fout.WriteLine("/* #undef NEEDS_STRNCASECMP_DECL */")
                                Case "HAVE_KNEM_IO_H"
                                        fout.WriteLine("/* #undef HAVE_KNEM_IO_H */")
                                Case "MPID_NEM_LOCAL_LMT_IMPL"
                                        fout.WriteLine("#define MPID_NEM_LOCAL_LMT_IMPL MPID_NEM_LOCAL_LMT_SHM_COPY")
                                Case "MPID_NEM_USE_LOCK_FREE_QUEUES"
                                        fout.WriteLine("#define MPID_NEM_USE_LOCK_FREE_QUEUES 1")
                                Case "USE_MMAP_SHM"
                                        fout.WriteLine("/* #undef USE_MMAP_SHM */")
                                Case "USE_SYSV_SHM"
                                        fout.WriteLine("/* #undef USE_SYSV_SHM */")
                                Case "HAVE_MPI_2DOUBLE_COMPLEX"
                                        fout.WriteLine("#define HAVE_MPI_2DOUBLE_COMPLEX 1")
                                Case "HAVE_MPI_2COMPLEX"
                                        fout.WriteLine("#define HAVE_MPI_2COMPLEX 1")
                                Case "HAVE_MPI_INTEGER16"
                                        fout.WriteLine("#define HAVE_MPI_INTEGER16 1")
                                Case "MPIO_USES_MPI_REQUEST"
                                        fout.WriteLine("#define MPIO_USES_MPI_REQUEST 1")
                                Case "USE_STRICT_MPI"
                                        fout.WriteLine("/* #undef USE_STRICT_MPI */")
                                Case "USE_PMI2_API"
                                        ' SMPD does not support PMI2
                                        fout.WriteLine("/* #undef USE_PMI2_API */")
                                Case "HAVE_MD5_H"
                                        fout.WriteLine("/* #undef HAVE_MD5_H */")
                                Case "HAVE_OPENSSL_MD5_H"
                                        fout.WriteLine("/* #undef HAVE_OPENSSL_MD5_H */")
                                Case "HAVE_MD5"
                                        fout.WriteLine("/* #undef HAVE_MD5 */")
                                Case "HAVE_MD5_CALC"
                                        fout.WriteLine("/* #undef HAVE_MD5_CALC */")
                                Case "HAVE_MACRO_VA_ARGS"
                                        fout.WriteLine("#define HAVE_MACRO_VA_ARGS")
                                ' On windows sizeof(void *p) == sizeof(aint) . So we don't
                                '  have to rely on aint to store attrval
                                Case "USE_AINT_FOR_ATTRVAL"
                                        fout.WriteLine("/* #undef USE_AINT_FOR_ATTRVAL */")
                                Case "AC_APPLE_UNIVERSAL_BUILD"
                                        fout.WriteLine("/* #undef AC_APPLE_UNIVERSAL_BUILD */")
                                ' The following option is related to unix build system, whether
                                '  it accepts -c -o
                                ' Not applicable on windows
                                Case "NO_MINUS_C_MINUS_O"
                                        fout.WriteLine("/* #undef NO_MINUS_C_MINUS_O */")
                                ' Disable falut tolerance code on windows
                                Case "ENABLE_FTB"
                                        fout.WriteLine("/* #undef ENABLE_FTB */")
                                Case "HAVE_LIBFTB"
                                        fout.WriteLine("/* #undef HAVE_LIBFTB */")
                                ' FIXME: The size of openpa ptr should not be hardcoded...
                                Case "SIZEOF_OPA_PTR_T"
                                        If b64 Then
                                            fout.WriteLine("#define SIZEOF_OPA_PTR_T 8")
                                        Else
                                            fout.WriteLine("#define SIZEOF_OPA_PTR_T 4")
                                        End if
                                Case "USE_ASYNC_PROGRESS"
                                        fout.WriteLine("/* #undef USE_ASYNC_PROGRESS */")
                                ' Windows builds don't rely on libtool - so no need to define
                                ' LT_OBJDIR
                                Case "LT_OBJDIR"
                                        fout.WriteLine("/* #undef LT_OBJDIR */")
                                Case "USE_MPIU_INSTR"
                                        fout.WriteLine("/* #undef USE_MPIU_INSTR */")
                                Case "HAVE_QSORT"
                                        fout.WriteLine("#define HAVE_QSORT 1")
				Case Else
                                    Dim useCustomDefDict
                                    useCustomDefDict = False
                                    If Not (customDefDict Is Nothing) Then
                                        If customDefDict.Exists(macroname) Then
                                            useCustomDefDict = True
                                        End If
                                    End If
                                    If useCustomDefDict Then
                                        fout.WriteLine("#define " & macroname & " " & customDefDict.Item(macroname))
                                    Else
					'MsgBox("Unhandled definition <" & define & ">")
					If appendUniqueString(unhandled_definitions, macroname) Then
						unhandled_definitions_count = unhandled_definitions_count + 1
					End If
					unhandled_definitions_instances = unhandled_definitions_instances + 1
					fout.WriteLine("/* unknown definition: " & macroname & " */")
                                    End If
			End Select
			fout.WriteLine("")
		Next
	End If
End Sub

printMsg "STATUS", "Checking MPICH2 dependencies..."
if not f.FolderExists("C:\Program Files\Microsoft HPC Pack 2008 SDK") then
    printMsg "ERROR", "Unable to find Microsoft HPC SDK"
    WScript.Quit
else
    printMsg "VERBOSE", "Found MS HPC SDK "
end if
printMsg "STATUS", "Creating MPICH2 header files..."
printMsg "STATUS", "Creating generic header files..."

'
' Generate mpi.h
'
if not f.FolderExists("src\include\win64") then
	f.CreateFolder("src\include\win64")
end if
printMsg "VERBOSE", "Creating src\include\win64\mpi.h"
set fout64 = f.CreateTextFile("src\include\win64\mpi.h")
if not f.FolderExists("src\include\win32") then
	f.CreateFolder("src\include\win32")
end if
printMsg "VERBOSE", "Creating src\include\win32\mpi.h"
set fout32 = f.CreateTextFile("src\include\win32\mpi.h")
set fin = f.OpenTextFile("src\include\mpi.h.in")

contents32=""
contents64=""
do until fin.AtEndOfStream = True
    line = fin.ReadLine()
    contents32 = contents32 + ReplaceAtsWithDecoration(line, false, false) + vbCrLf
    contents64 = contents64 + ReplaceAtsWithDecoration(line, false, true) + vbCrLf
loop

fin.Close()

contents32 = ReplaceAts(contents32, false, false)
contents64 = ReplaceAts(contents64, false, true)
if bAddDllDecoration then
	contents32 = DecorateMPIFuncs(contents32)
	contents64 = DecorateMPIFuncs(contents64)
'	' uncomment out the HAVE_EXPORTS_MPI_API block
'	'contents = ReplaceBetweenTags(contents, "/*", "HAVE_EXPORT_MPI_API", "*/", "#ifdef MPICH2_STATIC_LIBRARY" & vbCrLf & "#define EXPORT_MPI_API" & vbCrLf & "#else" & vbCrLf & "#ifdef MPICH2_EXPORTS" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllexport)" & vbCrLf & "#else" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllimport)" & vbCrLf & "#endif" & vbCrLf & "#endif" & vbCrLf & "#ifndef MPI_CALL" & vbCrLf & "#define MPI_CALL __cdecl" & vbCrLf & "#endif" & vbCrLf)
'	contents = Replace(contents, "/* --Insert Additional Definitions Here-- */", "#ifdef MPICH2_STATIC_LIBRARY" & vbCrLf & "#define EXPORT_MPI_API" & vbCrLf & "#else" & vbCrLf & "#ifdef MPICH2_EXPORTS" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllexport)" & vbCrLf & "#else" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllimport)" & vbCrLf & "#endif" & vbCrLf & "#endif" & vbCrLf & "#ifndef MPI_CALL" & vbCrLf & "#define MPI_CALL __cdecl" & vbCrLf & "#endif" & vbCrLf)
'	' add dllspec and calling convention to the MPI api
'	first_index = InStr(contents, "#ifndef MPICH_SUPPRESS_PROTOTYPES")
'	last_index = InStr(contents, "#endif /* MPICH_SUPPRESS_PROTOTYPES */")
'	if first_index <> 0 and last_index <> 0 then
'		prototypes = Mid(contents, first_index, last_index - first_index)
'		prototypes = Replace(prototypes, "int MPI_", "EXPORT_MPI_API int MPI_CALL MPI_")
'		prototypes = Replace(prototypes, "double PMPI_Wtime", "EXPORT_MPI_API double MPI_CALL PMPI_Wtime")
'		prototypes = Replace(prototypes, "double PMPI_Wtick", "EXPORT_MPI_API double MPI_CALL PMPI_Wtick")
'		prototypes = Replace(prototypes, "double MPI_Wtime", "EXPORT_MPI_API double MPI_CALL MPI_Wtime")
'		prototypes = Replace(prototypes, "double MPI_Wtick", "EXPORT_MPI_API double MPI_CALL MPI_Wtick")
'		contents = ReplaceBetweenTags(contents, "#ifndef MPICH_SUPPRESS_PROTOTYPES", "MPI_Send", "#endif /* MPICH_SUPPRESS_PROTOTYPES */", prototypes & "#endif /* MPICH_SUPPRESS_PROTOTYPES */")
'	end if
'	' add dllspec and calling convention to the PMPI api
'	first_index = InStr(contents, "#if !defined(MPI_BUILD_PROFILING)")
'	last_index = InStr(contents, "#endif  /* MPI_BUILD_PROFILING */")
'	if first_index <> 0 and last_index <> 0 then
'		prototypes = Mid(contents, first_index, last_index - first_index)
'		prototypes = Replace(prototypes, "int PMPI_", "EXPORT_MPI_API int MPI_CALL PMPI_")
'		prototypes = Replace(prototypes, "double PMPI_Wtime", "EXPORT_MPI_API double MPI_CALL PMPI_Wtime")
'		prototypes = Replace(prototypes, "double PMPI_Wtick", "EXPORT_MPI_API double MPI_CALL PMPI_Wtick")
'		contents = ReplaceBetweenTags(contents, "#if", "MPI_BUILD_PROFILING", "#endif  /* MPI_BUILD_PROFILING */", prototypes & "#endif  /* MPI_BUILD_PROFILING */")
'	end if
end if
fout32.Write(contents32)
fout64.Write(contents64)
fout32.Close()
fout64.Close()

Function internalFindCFiles(ByRef key, ByRef files, folder)
	For Each sub_folder in folder.SubFolders
		internalFindCFiles key, files, sub_folder
	Next
	For Each file in folder.Files
		If Right(file.Name, 2) = ".c" Then
			files.Add key, file.Path
			key = key + 1
		End If
	Next
End Function
Function FindCFiles(ByRef files, folder)
	files.RemoveAll()
	key = 0
	internalFindCFiles key, files, folder
End Function

' Add the dll decorations to the source files
if bAddDllDecoration then
	set c_files = CreateObject("Scripting.Dictionary")
	FindCFiles c_files, f.GetFolder("src\mpi")
	' replace "int MPI_" with "EXPORT_MPI_API int MPI_CALL MPI_"
	' fixup MPI_Fint MPI_
	a = c_files.Items
	If c_files.Count > 0 Then
		For i = 0 to c_files.Count - 1
			'cEcho a(i)
			set fin = f.OpenTextFile(a(i))
			contents = fin.ReadAll()
			fin.Close()
			new_contents = Replace(contents, "int MPI_", "EXPORT_MPI_API int MPI_CALL MPI_")
			new_contents = Replace(new_contents, "MPI_FEXPORT_MPI_API int", "EXPORT_MPI_API MPI_Fint")
			if new_contents <> contents then
				'cEcho new_contents
				'cEcho "Modifying file: " & a(i)
				gEcho "Modifying file: " & a(i)
				set fout = f.CreateTextFile(a(i))
				fout.Write(new_contents)
				fout.Close()
			end if
		Next
	End If
end if

Function FindMPIFuncs()
	Dim index, index2, right_str, result
	set c_files = CreateObject("Scripting.Dictionary")
	FindCFiles c_files, f.GetFolder("src\mpi")
	' replace "int MPI_" with "EXPORT_MPI_API int MPI_CALL MPI_"
	' fixup MPI_Fint MPI_
	a = c_files.Items
	If c_files.Count > 0 Then
		For i = 0 to c_files.Count - 1
			'cEcho a(i)
			set fin = f.OpenTextFile(a(i))
			contents = fin.ReadAll()
			fin.Close()
			index = InStr(contents, "int MPI_")
			If index <> 0 Then
				right_str = Right(contents, Len(contents) - index + 1)
				index2 = InStr(right_str, ")")
				If index2 <> 0 Then
					If Mid(contents, index-5, 5) = "MPI_F" then
						result = "MPI_F"
					else
						result = ""
					end if
					result = result & Left(right_str, index2) & vbCrLf & "{" & vbCrLf & "    return MPI_SUCCESS;" & vbCrLf & "}" & vbCrLf
					gEcho result
				End If
			End If
		Next
	End If	
End Function

Function internalPrintFortranInterface(dir)
	Dim index, index2, right_str, result
	set c_files = CreateObject("Scripting.Dictionary")
	FindCFiles c_files, f.GetFolder(dir)
	' replace "int MPI_" with "EXPORT_MPI_API int MPI_CALL MPI_"
	' fixup MPI_Fint MPI_
	a = c_files.Items
	If c_files.Count > 0 Then
		For i = 0 to c_files.Count - 1
			'cEcho a(i)
			set fin = f.OpenTextFile(a(i))
			contents = fin.ReadAll()
			fin.Close()
			index = InStr(contents, "int MPI_")
			If index <> 0 Then
				right_str = Right(contents, Len(contents) - index + 1)
				index2 = InStr(right_str, ")")
				If index2 <> 0 Then
					If Mid(contents, index-5, 5) = "MPI_F" then
						result = "MPI_F"
					else
						result = ""
					end if
					result = result & Left(right_str, index2)' & vbCrLf & "{" & vbCrLf & "    return MPI_SUCCESS;" & vbCrLf & "}" & vbCrLf
					'cEcho result
					gEcho result
				End If
			End If
		Next
	End If	
End Function

Function PrintFortranInterface()
	internalPrintFortranInterface("src\mpi\coll")
	internalPrintFortranInterface("src\mpi\pt2pt")
	internalPrintFortranInterface("src\mpi\rma")
End Function

'Function PrintFortranInterface()
'	Dim index, index2, right_str, result
'	set c_files = CreateObject("Scripting.Dictionary")
'	FindCFiles c_files, f.GetFolder("src\binding\f77")
'	a = c_files.Items
'	If c_files.Count > 0 Then
'		For i = 0 to c_files.Count - 1
'			set fin = f.OpenTextFile(a(i))
'			contents = fin.ReadAll()
'			fin.Close()
'			index = InStrRev(contents, "FORT_DLL_SPEC void FORT_CALL mpi_")
'			If index <> 0 Then
'				right_str = Right(contents, Len(contents) - index + 1)
'				index2 = InStr(right_str, ")")
'				If index2 <> 0 Then
'					result = Left(right_str, index2)' & vbCrLf & "{" & vbCrLf & "    return MPI_SUCCESS;" & vbCrLf & "}" & vbCrLf
'					cEcho result
'				End If
'			End If
'		Next
'	End If	
'End Function

Function internalFindFCFiles(ByRef key, ByRef files, folder)
	For Each sub_folder in folder.SubFolders
		internalFindFCFiles key, files, sub_folder
	Next
	For Each file in folder.Files
		If Right(file.Name, 3) = "f.c" Then
			files.Add key, file.Path
			key = key + 1
		End If
	Next
End Function
Function FindFCFiles(ByRef files, folder)
	files.RemoveAll()
	key = 0
	internalFindFCFiles key, files, folder
End Function

Function FindStr(pattern, str)
   Dim regEx, Match, Matches           ' Create variable.
   Set regEx = New RegExp              ' Create a regular expression.
   regEx.Pattern = pattern             ' Set pattern.
   regEx.IgnoreCase = True             ' Set case insensitivity.
   regEx.Global = True                 ' Set global applicability.
   Set Matches = regEx.Execute(str)    ' Execute search.
   For Each Match in Matches           ' Return the first match
      FindStr = Match.Value
      Exit Function
   Next
   FindStr = ""
End Function

Function AddStringLengthParameters(str)
	Dim result, index, cur_arg, match, end_str
	cur_arg = 1
	result = ""
	end_str = ""
	match = FindStr("void\s*\*\s*\w+,", str)
	while match <> ""
		index = InStr(str, match)
		result = result & Left(str, index + Len(match) - 2) & " FORT_MIXED_LEN(d" & cur_arg & ")"
		end_str = end_str & " FORT_END_LEN(d" & cur_arg & ")"
		cur_arg = cur_arg + 1
		str = Right(str, Len(str) - index - Len(match) + 2)
		match = FindStr("void\s*\*\s*\w+,", str)
	wend
	AddStringLengthParameters = result & str & end_str
End Function

Function CreateStdcallFortranInterface()
	Dim index, index2, right_str, result, prototype, filename
	set c_files = CreateObject("Scripting.Dictionary")
	printMsg "VERBOSE", "Creating src\binding\f77\fprotos.h"
	set fprotos = f.CreateTextFile("src\binding\f77\fprotos.h")
	fprotos.WriteLine( "/* -*- Mode: C; c-basic-offset:4 ; -*- */" & vbNewLine & "/*" & vbNewLine & " *  (C) 2001 by Argonne National Laboratory." & vbNewLine & " *      See COPYRIGHT in top-level directory." & vbNewLine & " */" )
	fprotos.WriteLine("")
	fprotos.WriteLine("#ifndef FPROTOS_H")
	fprotos.WriteLine("#define FPROTOS_H")
	fprotos.WriteLine("")
	fprotos.WriteLine("/* fprotos.h.  Generated automatically by winconfigure.  */")
	fprotos.WriteLine("")
	'fnames = Split("MPI_Allgather MPI_Allgatherv MPI_Allreduce MPI_Alltoall MPI_Alltoallv MPI_Alltoallw MPI_Bcast MPI_Exscan MPI_Gather MPI_Gatherv MPI_Reduce MPI_Reduce_scatter MPI_Scan MPI_Scatter MPI_Scatterv MPI_Bsend MPI_Bsend_init MPI_Buffer_attach MPI_Buffer_detach MPI_Ibsend MPI_Irecv MPI_Irsend MPI_Isend MPI_Issend MPI_Recv MPI_Recv_init MPI_Rsend MPI_Rsend_init MPI_Send MPI_Sendrecv MPI_Sendrecv_replace MPI_Send_init MPI_Ssend MPI_Ssend_init MPI_Accumulate MPI_Get MPI_Put MPI_Win_create")
	fnames = Split("mpi_allgather_ +mpi_allgatherv_ +mpi_allreduce_ +mpi_alltoall_ +mpi_alltoallv_ +mpi_alltoallw_ +mpi_bcast_ +mpi_exscan_ +mpi_gather_ +mpi_gatherv_ +mpi_reduce_ +mpi_reduce_scatter_ +mpi_scan_ +mpi_scatter_ +mpi_scatterv_ +mpi_bsend_ +mpi_bsend_init_ +mpi_buffer_attach_ +mpi_buffer_detach_ +mpi_ibsend_ +mpi_irecv_ +mpi_irsend_ +mpi_isend_ +mpi_issend_ +mpi_recv_ +mpi_recv_init_ +mpi_rsend_ +mpi_rsend_init_ +mpi_send_ +mpi_sendrecv_ +mpi_sendrecv_replace_ +mpi_send_init_ +mpi_ssend_ +mpi_ssend_init_ +mpi_accumulate_ +mpi_get_ +mpi_put_ +mpi_win_create_ ", "+")
	FindFCFiles c_files, f.GetFolder("src\binding\f77")
	a = c_files.Items
	If c_files.Count > 0 Then
		For i = 0 to c_files.Count - 1
			set fin = f.OpenTextFile(a(i))
			contents = fin.ReadAll()
			fin.Close()
			found = false
			for each name in fnames
				if InStr(contents, name) then
					'cEcho "found " & name & " in: " & vbCrLf & contents
					found = true
					exit for
				end if
			next
			if found = true then
				index = InStrRev(contents, "FORT_DLL_SPEC void FORT_CALL mpi_")
				If index <> 0 Then
					result = Left(contents, index - 1)
					right_str = Right(contents, Len(contents) - index + 1)
					index2 = InStr(right_str, ")")
					If index2 <> 0 Then
						result = result & AddStringLengthParameters(Left(right_str, index2 - 1)) & Right(right_str, Len(right_str) - index2 + 1)
						result = Replace(result, "fproto.h", "fprotos.h")
						index = InStrRev(result, "FORT_DLL_SPEC void FORT_CALL mpi_")
						right_str = Right(result, Len(result) - index + 1)
						index2 = InStr(right_str, "))")
						prototype = "extern " & Left(right_str, index2 + 1) & ";"
						'prototype = Replace(prototype, "FORT_MIXED_LEN", "FORT_MIXED_LEN_DECL")
						'prototype = Replace(prototype, "FORT_END_LEN", "FORT_END_LEN_DECL")
						filename = Replace(a(i), ".c", "s.c")
						'cEcho "filename: " & filename
						'cEcho "prototype: " & prototype
						'cEcho result
						printMsg "VERBOSE", "Creating file: " & filename
						set file = f.CreateTextFile(filename)
						file.Write(result)
						file.Close()
						fprotos.WriteLine(prototype)
					End If
				End If
			End If
		Next
	End If
	fprotos.WriteLine("")
	fprotos.WriteLine("#endif")
	fprotos.Close()
End Function

'
' Generate mpichtimer.h
'

printMsg "VERBOSE", "Creating src\include\win32\mpichtimer.h"
set fout = f.CreateTextFile("src\include\win32\mpichtimer.h")
'set fin = f.OpenTextFile("src\mpi\timer\mpichtimer.h.in")
set fin = f.OpenTextFile("src\include\mpichtimer.h.in")

contents = fin.ReadAll()
contents = ReplaceAts(contents, false, false)
fout.Write(contents)
fin.Close()
fout.Close()

printMsg "VERBOSE", "Creating src\include\win64\mpichtimer.h"
set fout = f.CreateTextFile("src\include\win64\mpichtimer.h")
'set fin = f.OpenTextFile("src\mpi\timer\mpichtimer.h.in")
set fin = f.OpenTextFile("src\include\mpichtimer.h.in")


contents = fin.ReadAll()
contents = ReplaceAts(contents, false, true)
fout.Write(contents)
fin.Close()
fout.Close()

'
' Generate mpich2info.h
'
printMsg "VERBOSE", "Creating src\include\mpich2info.h"
set fout = f.CreateTextFile("src\include\mpich2info.h")
set fin  = f.OpenTextFile("src\include\mpich2info.h.in")
contents = fin.ReadAll()
contents = ReplaceAts(contents, false, false)
fout.Write(contents)
fin.Close()
fout.Close()

'
' mpid_thread.h
'
If f.FileExists("src\mpid\common\thread\mpid_thread.h.in") Then
	printMsg "VERBOSE", "Creating src\include\win32\mpid_thread.h"
	Set fout = f.CreateTextFile("src\include\win32\mpid_thread.h")
	Set fin = f.OpenTextFile("src\mpid\common\thread\mpid_thread.h.in")
	contents = fin.ReadAll()
	contents = ReplaceAts(contents, false, false)
	fout.Write(contents)
	fin.Close()
	fout.Close()
	printMsg "VERBOSE", "Creating src\include\win64\mpid_thread.h"
	Set fout = f.CreateTextFile("src\include\win64\mpid_thread.h")
	Set fin = f.OpenTextFile("src\mpid\common\thread\mpid_thread.h.in")
	contents = fin.ReadAll()
	contents = ReplaceAts(contents, false, true)
	fout.Write(contents)
	fin.Close()
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: mpid_thread.h"
End If

'
' trace_impl.h
'
printMsg "VERBOSE", "Creating src\util\logging\rlog\trace_impl.h"
Set fout = f.CreateTextFile("src\util\logging\rlog\trace_impl.h")
Call WriteHeader(fout, "trace_impl")
'Call AddDefinitions(fout, "src\util\logging\rlog\trace_impl.h.in", false)
fout.WriteLine("#define HAVE_CTYPE_H")
fout.WriteLine("#define HAVE_STDLIB_H")
fout.WriteLine("#define HAVE_STRING_H")
Call WriteFooter(fout)
fout.Close()

printMsg "STATUS", "Creating MPE header files..."
'
' Generate mpe_log_thread.h
'
printMsg "VERBOSE", "Creating src\mpe2\src\logging\include\mpe_log_thread.h"
set fout = f.CreateTextFile("src\mpe2\src\logging\include\mpe_log_thread.h")
set fin  = f.OpenTextFile("src\mpe2\src\logging\include\mpe_log_thread.h.in")
contents = fin.ReadAll()
contents = ReplaceAts(contents, false, false)
fout.Write(contents)
fin.Close()
fout.Close()

'
' Generate mpe_callstack.h
'
printMsg "VERBOSE", "Creating src\mpe2\src\callstack\include\mpe_callstack.h"
set fout = f.CreateTextFile("src\mpe2\src\callstack\include\mpe_callstack.h")
set fin  = f.OpenTextFile("src\mpe2\src\callstack\include\mpe_callstack.h.in")
contents = fin.ReadAll()
contents = ReplaceAts(contents, false, false)
fout.Write(contents)
fin.Close()
fout.Close()

If f.FolderExists("src\mpe2\src\logging\include") Then
        '
        ' clog_inttypes.h
        ' 

	If f.FileExists("src\mpe2\src\logging\include\clog_inttypes.h.in") Then
		printMsg "VERBOSE", "Creating src\mpe2\src\logging\include\clog_inttypes.h"
		Set fin = f.OpenTextFile("src\mpe2\src\logging\include\clog_inttypes.h.in")
		Set fout = f.CreateTextFile("src\mpe2\src\logging\include\clog_inttypes.h")
		contents = fin.ReadAll()
		contents = ReplaceAts(contents, false, false)
		fout.Write(contents)
		fin.Close()
		fout.Close()	
	End If
End If

printMsg "STATUS", "Creating IO header files..."
'
' Generate mpio.h
'

printMsg "VERBOSE", "Creating src\include\mpio.h"
set fout = f.CreateTextFile("src\include\mpio.h")
set fin = f.OpenTextFile("src\mpi\romio\include\mpio.h.in")

contents = fin.ReadAll()
contents = ReplaceAts(contents, false, false)
if bAddDllDecoration then
	contents = ReplaceBetweenTags(contents, "/* MPI-IO function prototypes */", "HAVE_PRAGMA_HP_SEC_DEF", "#if defined(__cplusplus)", "#if defined(__cplusplus)")
end if
fout.Write(contents)
fin.Close()
fout.Close()


'cEcho "Creating src\include\win64\mpio.h"
'set fout = f.CreateTextFile("src\include\win64\mpio.h")
'set fin = f.OpenTextFile("src\mpi\romio\include\mpio.h.in")
'
'contents = fin.ReadAll()
'contents = ReplaceAts(contents, false, true)
'if bAddDllDecoration then
'	contents = ReplaceBetweenTags(contents, "/* MPI-IO function prototypes */", "HAVE_PRAGMA_HP_SEC_DEF", "#if defined(__cplusplus)", "#if defined(__cplusplus)")
'end if
'fout.Write(contents)
'fin.Close()
'fout.Close()

'
' Generate romioconf.h
'

If f.FileExists("src\mpi\romio\adio\include\romioconf.h.in") Then

	printMsg "VERBOSE", "Creating src\mpi\romio\adio\include\romioconf.h"
	set fout = f.CreateTextFile("src\mpi\romio\adio\include\romioconf.h")
	Call WriteHeader(fout, "romio")
	Call AddDefinitions(fout, "src\mpi\romio\adio\include\romioconf.h.in", false)
	fout.WriteLine("#ifndef ROMIO_NTFS")
	fout.WriteLine("#define ROMIO_NTFS 1")
	fout.WriteLine("#endif")
	fout.WriteLine("#ifndef HAVE_INT64")
	fout.WriteLine("#define HAVE_INT64 1")
	fout.WriteLine("#endif")
	fout.WriteLine("#ifndef FORTRANDOUBLEUNDERSCORE")
	fout.WriteLine("#define FORTRANCAPS")
	fout.WriteLine("#endif")
	fout.WriteLine("#define HAVE_IO_H 1")
	fout.WriteLine("#define snprintf _snprintf")
    fout.WriteLine("#define strtok_r strtok_s")
	Call WriteFooter(fout)
	fout.Close()

Else

	printMsg "VERBOSE", "Creating src\mpi\romio\adio\include\romioconf.h"
	set fout = f.CreateTextFile("src\mpi\romio\adio\include\romioconf.h")

	fout.WriteLine("/* -*- Mode: C; c-basic-offset:4 ; -*- */")
	fout.WriteLine("/*")
	fout.WriteLine(" *  (C) 2001 by Argonne National Laboratory.")
	fout.WriteLine(" *      See COPYRIGHT in top-level directory.")
	fout.WriteLine(" */")
	fout.WriteLine("#ifndef ROMIOCONF_H")
	fout.WriteLine("#define ROMIOCONF_H")
	fout.WriteLine("")
	fout.WriteLine("/* Define if `sys_siglist' is declared by <signal.h>.  */")
	fout.WriteLine("#undef SYS_SIGLIST_DECLARED")
	fout.WriteLine("")
	fout.WriteLine("#undef AIO_HANDLE_IN_AIOCB")
	fout.WriteLine("#undef AIO_PRIORITY_DEFAULT")
	fout.WriteLine("#undef AIO_SIGNOTIFY_NONE")
	fout.WriteLine("#undef AIO_SUN")
	fout.WriteLine("#undef FREEBSD")
	fout.WriteLine("#undef HAVE_LONG_LONG_64")
	fout.WriteLine("#undef HAVE_MOUNT_NFS")
	fout.WriteLine("#undef HAVE_MPI_COMBINERS")
	fout.WriteLine("#undef HAVE_MPI_DARRAY_SUBARRAY")
	fout.WriteLine("#ifndef HAVE_MPI_INFO")
	fout.WriteLine("#define HAVE_MPI_INFO")
	fout.WriteLine("#endif")
	fout.WriteLine("#undef HAVE_MPI_LONG_LONG_INT")
	fout.WriteLine("#undef HAVE_PRAGMA_CRI_DUP")
	fout.WriteLine("#undef HAVE_PRAGMA_HP_SEC_DEF")
	fout.WriteLine("#undef HAVE_PRAGMA_WEAK")
	fout.WriteLine("#undef HAVE_PREAD64")
	fout.WriteLine("#ifndef HAVE_STATUS_SET_BYTES")
	fout.WriteLine("#define HAVE_STATUS_SET_BYTES")
	fout.WriteLine("#endif")
	fout.WriteLine("#ifndef HAVE_STRERROR")
	fout.WriteLine("#define HAVE_STRERROR")
	fout.WriteLine("#endif")
	fout.WriteLine("#undef HAVE_SYSERRLIST")
	fout.WriteLine("#undef HAVE_WEAK_SYMBOLS")
	fout.WriteLine("#undef HFS")
	fout.WriteLine("#undef HPUX")
	fout.WriteLine("#undef INT_LT_POINTER")
	fout.WriteLine("#undef IRIX")
	fout.WriteLine("#undef LINUX")
	fout.WriteLine("#ifndef MPICH")
	fout.WriteLine("#define MPICH")
	fout.WriteLine("#endif")
	fout.WriteLine("#undef MPIHP")
	fout.WriteLine("#undef MPILAM")
	fout.WriteLine("#undef MPISGI")
	fout.WriteLine("#undef MPI_OFFSET_IS_INT")
	fout.WriteLine("#undef NEEDS_MPI_TEST")
	fout.WriteLine("#undef NFS")
	fout.WriteLine("#undef NO_AIO")
	fout.WriteLine("#undef NO_FD_IN_AIOCB")
	fout.WriteLine("#undef NO_MPI_SGI_type_is_contig")
	fout.WriteLine("#undef PARAGON")
	fout.WriteLine("#undef PFS")
	fout.WriteLine("#undef PIOFS")
	fout.WriteLine("#undef PRINT_ERR_MSG")
	fout.WriteLine("#undef ROMIO_PVFS")
	fout.WriteLine("#undef ROMIO_TESTFS")
	fout.WriteLine("#undef SFS")
	fout.WriteLine("#undef SOLARIS")
	fout.WriteLine("#undef SPPUX")
	fout.WriteLine("#undef SX4")
	fout.WriteLine("#undef UFS")
	fout.WriteLine("#undef XFS")
	fout.WriteLine("")
	fout.WriteLine("#ifndef ROMIO_NTFS")
	fout.WriteLine("#define ROMIO_NTFS")
	fout.WriteLine("#endif")
	fout.WriteLine("#ifndef HAVE_INT64")
	fout.WriteLine("#define HAVE_INT64 1")
	fout.WriteLine("#endif")
	fout.WriteLine("")
	fout.WriteLine("#ifndef HAS_MPIR_ERR_SETMSG")
	fout.WriteLine("#define HAS_MPIR_ERR_SETMSG")
	fout.WriteLine("#endif")
	fout.WriteLine("")
	fout.WriteLine("#ifndef FORTRANDOUBLEUNDERSCORE")
	fout.WriteLine("#define FORTRANCAPS")
	fout.WriteLine("#endif")
	fout.WriteLine("")
	fout.WriteLine("#define restrict")
	fout.WriteLine("")
	fout.WriteLine("#define HAVE_IO_H 1")
	fout.WriteLine("#define snprintf _snprintf")
    fout.WriteLine("#define strtok_r strtok_s")
	fout.WriteLine("#endif")

	fout.Close()

End If

'   Convert mpif.h - F77 header to F90 header
Function ConvertF77HeaderToF90(headerFileName)
	set fs = CreateObject("Scripting.FileSystemObject")
	set headerFileObj = fs.OpenTextFile(headerFileName)
	tmpFileName = fs.GetTempName()
	set tmpFileObj = fs.CreateTextFile(tmpFileName, true)
	Do Until headerFileObj.AtEndOfStream = True
		contents = headerFileObj.ReadLine()
		posCommentChar = InStr(1, contents, "C", 1)
		If posCommentChar = 1 Then
			contents = Replace(contents, "C", "!", 1, 1, 1)
		End If
		tmpFileObj.WriteLine(contents)
	Loop
	headerFileObj.Close()
	tmpFileObj.Close()

	set headerFileObj = fs.GetFile(headerFileName)
	set tmpFileObj = fs.GetFile(tmpFileName)
	headerFileObj.Delete(True)
	tmpFileObj.Move(headerFileName)
	ConvertF77HeaderToF90 = True
End Function 

Function BuildIFaces()

	Dim WshShell
	set f = WScript.CreateObject("Scripting.FileSystemObject")

	'
	' Generate mpicxx.h
	'
	If bForce Or Not f.FileExists("src\binding\cxx\mpicxx.h.in") Then

		Set WshShell = CreateObject("WScript.Shell")
                Set userEnv = WshShell.Environment("USER")
                userEnv("nodosfilewarning") = 1
		WshShell.CurrentDirectory = "src\binding\cxx"
		printMsg "VERBOSE", WshShell.CurrentDirectory & ">perl buildiface -nosep"
		WshShell.Run "perl buildiface -nosep", 0, true
		WshShell.CurrentDirectory = "..\..\.."
	
	End If

	If f.FileExists("src\binding\cxx\mpicxx.h.in") Then
	
	  set fin = f.OpenTextFile("src\binding\cxx\mpicxx.h.in")
	  printMsg "VERBOSE", "Creating src\include\mpicxx.h"
	  set fout = f.CreateTextFile("src\include\mpicxx.h")
	  contents = fin.ReadAll()
	  contents = ReplaceAts(contents, false, false)
	  if bCleanCode then
		printMsg "VERBOSE", "modifying the comm, win datatype classes to handle unreferenced variables."
		' Comm class
		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Comm &oldcomm", "}", "int NULL_COPY_FN( const Comm &oldcomm, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldcomm; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Comm &comm", "}", "int NULL_DELETE_FN( Comm &comm, int keyval, void * attr, void *ex ) { comm; keyval; attr; ex; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Comm &oldcomm", "}", "int DUP_FN( const Comm &oldcomm, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldcomm; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
		' Win class
		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Win &oldwin", "}", "int NULL_COPY_FN( const Win &oldwin, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldwin; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Win &win", "}", "int NULL_DELETE_FN( Win &win, int keyval, void * attr, void *ex ) { win; keyval; attr; ex; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Win &oldwin", "}", "int DUP_FN( const Win &oldwin, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldwin; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
		' Datatype class
		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Datatype &oldtype", "}", "int NULL_COPY_FN( const Datatype &oldtype, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldtype; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Datatype &type", "}", "int NULL_DELETE_FN( Datatype &type, int keyval, void * attr, void *ex ) { type; keyval; attr; ex; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Datatype &oldtype", "}", "int DUP_FN( const Datatype &oldtype, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldtype; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
	  end if	
	  fout.Write(contents)
	  fin.Close()
	  fout.Close()
	
'	  set fin = f.OpenTextFile("src\binding\cxx\mpicxx.h.in")
'	  cEcho "Creating src\include\win64\mpicxx.h"
'	  set fout = f.CreateTextFile("src\include\win64\mpicxx.h")
'	  contents = fin.ReadAll()
'	  contents = ReplaceAts(contents, false, true)
'	  if bCleanCode then
'		' Comm class
'		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Comm &oldcomm", "}", "int NULL_COPY_FN( const Comm &oldcomm, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldcomm; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Comm &comm", "}", "int NULL_DELETE_FN( Comm &comm, int keyval, void * attr, void *ex ) { comm; keyval; attr; ex; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Comm &oldcomm", "}", "int DUP_FN( const Comm &oldcomm, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldcomm; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
'		' Win class
'		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Win &oldwin", "}", "int NULL_COPY_FN( const Win &oldwin, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldwin; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Win &win", "}", "int NULL_DELETE_FN( Win &win, int keyval, void * attr, void *ex ) { win; keyval; attr; ex; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Win &oldwin", "}", "int DUP_FN( const Win &oldwin, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldwin; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
'		' Datatype class
'		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Datatype &oldtype", "}", "int NULL_COPY_FN( const Datatype &oldtype, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldtype; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Datatype &type", "}", "int NULL_DELETE_FN( Datatype &type, int keyval, void * attr, void *ex ) { type; keyval; attr; ex; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Datatype &oldtype", "}", "int DUP_FN( const Datatype &oldtype, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldtype; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
'	  end if	
'	  fout.Write(contents)
'	  fin.Close()
'	  fout.Close()

	Else
	
	  printMsg "ERROR", "Run ""perl buildiface -nosep"" from the src\binding\cxx directory before running winconfigure"
	  
	End IF
	
	
	'
	' Generate mpimcxx.h
	'
	If bMcxx Then
	
		If bForce Or Not f.FileExists("src\binding\mcxx\mpimcxx.h.in") Then
	
			Set WshShell = CreateObject("WScript.Shell")
                        Set userEnv = WshShell.Environment("USER")
                        userEnv("nodosfilewarning") = 1
			WshShell.CurrentDirectory = "src\binding\mcxx"
			printMsg "VERBOSE", WshShell.CurrentDirectory & ">perl buildiface -nosep"
			WshShell.Run "perl buildiface -nosep", 0, true
			WhShell.CurrentDirectory = "..\..\.."
	
		End If
	
		If f.FileExists("src\binding\mcxx\mpimcxx.h.in") Then

			set fin = f.OpenTextFile("src\binding\mcxx\mpimcxx.h.in")
			printMsg "VERBOSE", "Creating src\include\mpimcxx.h"
			set fout = f.CreateTextFile("src\include\mpimcxx.h")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

'			set fin = f.OpenTextFile("src\binding\mcxx\mpimcxx.h.in")
'			cEcho "Creating src\include\mpimcxx64.h"
'			set fout = f.CreateTextFile("src\include\mpimcxx64.h")
'			contents = fin.ReadAll()
'			contents = ReplaceAts(contents, false, true)
'			fout.Write(contents)
'			fin.Close()
'			fout.Close()

		Else
	
			printMsg "ERROR", "Run ""perl buildiface -nosep"" from the src\binding\mcxx directory before running winconfigure"
	  
		End If
		
	End If

	If Not bRemoveFortran Then
		'
		' Generate mpif.h
		'
		If bForce Or Not f.FileExists("src\binding\f77\mpif.h.in") Then

			Set WshShell = CreateObject("WScript.Shell")
                        Set userEnv = WshShell.Environment("USER")
                        userEnv("nodosfilewarning") = 1
			WshShell.CurrentDirectory = "src\binding\f77"
			printMsg "VERBOSE", WshShell.CurrentDirectory & ">perl buildiface"
			WshShell.Run "perl buildiface", 0, true
			WshShell.CurrentDirectory = "..\..\.."

		End If

		If f.FileExists("src\binding\f77\mpif.h.in") Then

			set fin = f.OpenTextFile("src\binding\f77\mpif.h.in")
			printMsg "VERBOSE", "Creating src\include\win32\mpif.h"
			set fout = f.CreateTextFile("src\include\win32\mpif.h")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, true, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()
			' Assume all windows fortran compilers are F90 compilers
			retVal = ConvertF77HeaderToF90("src\include\win32\mpif.h")

			set fin = f.OpenTextFile("src\binding\f77\mpif.h.in")
			printMsg "VERBOSE", "Creating src\include\win64\mpif.h"
			set fout = f.CreateTextFile("src\include\win64\mpif.h")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, true, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()
			' Assume all windows fortran compilers are F90 compilers
			retVal = ConvertF77HeaderToF90("src\include\win64\mpif.h")

		Else
	
			printMsg "ERROR", "Run ""perl buildiface"" from the src\binding\f77 directory before running winconfigure"
	
		End If

		'
		' Create the string versions of the fortran interface necessitated by the stdcall calling convention
		'
		CreateStdcallFortranInterface()
		
		'
		' Generate setbotf.f
		'
		If f.FileExists("src\binding\f77\setbotf.f.in") Then

			set fin = f.OpenTextFile("src\binding\f77\setbotf.f.in")
			printMsg "VERBOSE", "Creating src\binding\f77\setbotf.f"
			set fout = f.CreateTextFile("src\binding\f77\setbotf.f")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, true, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

'			set fin = f.OpenTextFile("src\binding\f77\setbotf.f.in")
'			cEcho "Creating src\binding\f77\setbotf64.f"
'			set fout = f.CreateTextFile("src\binding\f77\setbotf64.f")
'			contents = fin.ReadAll()
'			contents = ReplaceAts(contents, true, true)
'			fout.Write(contents)
'			fin.Close()
'			fout.Close()
			
		Else
			printMsg "VERBOSE", "Skipping file: src\binding\f77\setbotf.f"
		End If

                '
                ' Generate setbot.c
                '
                If f.FileExists("src\binding\f77\setbot.c.in") Then
                    set fin = f.OpenTextFile("src\binding\f77\setbot.c.in")
                    printMsg "VERBOSE", "Creating src\binding\f77\setbot.c"
                    set fout = f.CreateTextFile("src\binding\f77\setbot.c")
                    contents = fin.ReadAll()
                    contents = ReplaceAts(contents, true, false)
                    fout.Write(contents)
                    fin.Close()
                    fout.Close()
                Else
                    printMsg "VERBOSE", "Skipping file: src\binding\f77\setbot.c"
                End If

		'
		' Generate F90 module files
		'
		If bForce Or Not f.FileExists("src\binding\f90\mpi.f90") Then

			Set WshShell = CreateObject("WScript.Shell")
                        Set userEnv = WshShell.Environment("USER")
                        userEnv("nodosfilewarning") = 1
			WshShell.CurrentDirectory = "src\binding\f90"
			printMsg "VERBOSE", WshShell.CurrentDirectory & ">perl buildiface"
			WshShell.Run "perl buildiface", 0, true

			' Generate mpifnoext.h
			' - Remove EXTERNAL, DOUBLE PRECISION from mpif.h
			' - Change comment style in mpif.h from "C ..." to "! ..."
			printMsg "VERBOSE", "Creating src\include\win32\mpifnoext.h"
			set fs = CreateObject("Scripting.FileSystemObject")
			set fout = fs.CreateTextFile("..\..\include\win32\mpifnoext.h")
			set fin = fs.OpenTextFile("..\..\include\win32\mpif.h")
			Do Until fin.AtEndOfStream = True
				contents = fin.ReadLine()
				posExternal = InStr(1, contents, "EXTERNAL", 1)
				posDoubleP = InStr(1, contents, "DOUBLE PRECISION", 1)
				posCommentChar = InStr(1, contents, "C", 1)
				If posCommentChar = 1 Then
					contents = Replace(contents, "C", "!", 1, 1, 1)
				End If
				If (posExternal < 1) And (posDoubleP < 1) Then
					fout.WriteLine(contents)
				End If
			Loop
			fin.Close()
			fout.Close()
			printMsg "VERBOSE", "Creating src\include\win64\mpifnoext.h"
			set fout = fs.CreateTextFile("..\..\include\win64\mpifnoext.h")
			set fin = fs.OpenTextFile("..\..\include\win64\mpif.h")
			Do Until fin.AtEndOfStream = True
				contents = fin.ReadLine()
				posExternal = InStr(1, contents, "EXTERNAL", 1)
				posDoubleP = InStr(1, contents, "DOUBLE PRECISION", 1)
				posCommentChar = InStr(1, contents, "C", 1)
				If posCommentChar = 1 Then
					contents = Replace(contents, "C", "!", 1, 1, 1)
				End If
				If (posExternal < 1) And (posDoubleP < 1) Then
					fout.WriteLine(contents)
				End If
			Loop
			fin.Close()
			fout.Close()

			' Create mpi_sizeofs.f90 in arch dependent dirs
			If Not fs.FolderExists("win32") Then
				fs.CreateFolder("win32")
			End If
			printMsg "VERBOSE", "Creating src\binding\f90\win32\mpi_sizeofs.f90"
			set fout = fs.CreateTextFile("win32\mpi_sizeofs.f90" , True)
			set fin  = fs.OpenTextFile("mpi_sizeofs.f90.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			If Not fs.FolderExists("win64") Then
				fs.CreateFolder("win64")
			End If
			printMsg "VERBOSE", "Creating src\binding\f90\win64\mpi_sizeofs.f90"
			set fout = fs.CreateTextFile("win64\mpi_sizeofs.f90", True)
			set fin  = fs.OpenTextFile("mpi_sizeofs.f90.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()
			
			' Create mpif90model.h in arch dependent dirs
			printMsg "VERBOSE", "Creating src\binding\f90\mpif90model.h"
			set fout = fs.CreateTextFile("mpif90model.h" , True)
			set fin  = fs.OpenTextFile("mpif90model.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			' Create mpi_base.f90 
			printMsg "VERBOSE", "Creating src\binding\f90\mpi_base.f90"
			set fout = fs.CreateTextFile("mpi_base.f90" , True)
			set fin  = fs.OpenTextFile("mpi_base.f90.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			WshShell.CurrentDirectory = "..\..\.."

		End If

		If Not f.FileExists("src\binding\f90\mpi.f90") Then

			printMsg "ERROR", "Run ""perl buildiface"" from the src\binding\f90 directory to generate the F90 modules"

		End If
	
	End If

End Function

printMsg "STATUS", "Building C++ and Fortran interfaces..."
BuildIFaces()


'
' Generate defmsg.h
'
'Function RunCmd(cmd_line)
'	Set oExec = WshShell.Exec("cmd /C " & cmd_line & " 2>&1")
'	cmd_output = oExec.StdOut.ReadAll()
'	RunCmd = cmd_output
'End Function
'Function RunCmd(cmd_line)
'	Dim results(2), runcmd_done
'	Set WshShell = CreateObject("WScript.Shell")
'	cEcho WshShell.CurrentDirectory & ">" & cmd_line
'	Set oExec = WshShell.Exec(cmd_line)
'	cmd_output = ""
'	err_output = ""
'	runcmd_more = true
'	Do While runcmd_more
'		runcmd_more = false
'		If Not oExec.StdOut.AtEndOfStream Then
'			runcmd_more = true
'			cmd_output = cmd_output & oExec.StdOut.ReadLine & vbCrLf
'		End If
'		If Not oExec.StdErr.AtEndOfStream Then
'			runcmd_more = true
'			err_output = err_output & oExec.StdErr.ReadLine & vbCrLf
'		End If
'	Loop
'	Do While oExec.Status <> 1
'		WScript.Sleep 10
'	Loop
'	results(0) = cmd_output
'	results(1) = err_output
'	RunCmd = results
'End Function
Function RunCmd(cmd_line)
	Dim results(2)
	Set WshShell = CreateObject("WScript.Shell")
	printMsg "VERBOSE", WshShell.CurrentDirectory & ">" & cmd_line
	Set oExec = WshShell.Exec(cmd_line)
	cmd_output = ""
    err_output = ""
	If Not oExec.StdOut.AtEndOfStream Then
		cmd_output = cmd_output & oExec.StdOut.ReadAll
	End If
    If Not oExec.StdErr.AtEndOfStream Then
		err_output = err_output & oExec.StdErr.ReadAll
	End If
    Do While oExec.Status <> 1
        WScript.Sleep 10
    Loop
    results(0) = cmd_output
    results(1) = err_output
    RunCmd = results
End Function

Function RemoveWarnings(str)
	lines = Split(str, vbCrLf)
	result = ""
	for each line in lines
		line = Trim(line)
		if Len(line) > 0 and (not Left(line, 7) = "Warning") then
			result = result & line & vbCrLf
		end if
	next
	RemoveWarnings = result
End Function

Function GenerateDefmsg()
	set f = WScript.CreateObject("Scripting.FileSystemObject")
	set fin = f.OpenTextFile("maint\errmsgdirs")
	contents = fin.ReadAll()
	fin.Close()
	contents = Trim(contents)
	contents = Replace(contents, "/", "\")
	contents = Replace(contents, vbCrLf, "")
	cmd_line = "perl maint\extracterrmsgs -skip=src\util/multichannel/mpi.c " & contents
	'WScript.Echo(cmd_line)
	output = RunCmd(cmd_line)
	output(1) = RemoveWarnings(output(1))
	If Len(output(1)) > 0 Then
		printMsg "ERROR", output(1)
		printMsg "ERROR", "Because of errors in extracting error messages, the file src\mpi\errhan\defmsg.h was not updated."
	Else
		set fout = f.OpenTextFile("src\mpi\errhan\defmsg.h", 2, True)
		fout.Write(output(0))
		fout.Close()
	End If
End Function

If bForce Then
	GenerateDefmsg()
End If

'
' Generate mpiallstates.h and describe_states.c
'
'Function GenerateStatesFiles()
'	set f = WScript.CreateObject("Scripting.FileSystemObject")
'	If f.FileExists("maint\genstates.in") Then
'
'		set fin = f.OpenTextFile("maint\genstates.in")
'		cEcho "Creating maint\genstates"
'		set fout = f.CreateTextFile("maint\genstates")
'		contents = fin.ReadAll()
'		contents = Replace(contents, "@PERL@", "perl")
'		fout.Write(contents)
'		fin.Close()
'		fout.Close()
'		Set WshShell = CreateObject("WScript.Shell")
'		cEcho WshShell.CurrentDirectory & ">perl maint\genstates"
'		WshShell.Run "perl maint\genstates", 0, true
'
'	Else
'
'		If InStr(1, LCase(WScript.FullName), "cscript") > 0 Then
'			WScript.Echo("Missing file: maint\genstates.in")
'		End If
' 
'	End If
'
'End Function

'
' Generate state_names.h
'
Function GenerateStatesFiles()
	set f = WScript.CreateObject("Scripting.FileSystemObject")
	If f.FileExists("maint\extractstates.in") Then

		set fin = f.OpenTextFile("maint\extractstates.in")
		printMsg "VERBOSE", "Creating maint\extractstates"
		set fout = f.CreateTextFile("maint\extractstates")
		contents = fin.ReadAll()
		contents = Replace(contents, "@PERL@", "perl")
		fout.Write(contents)
		fin.Close()
		fout.Close()
	
	End If
	
	If f.FileExists("maint\extractstrings.in") Then

		set fin = f.OpenTextFile("maint\extractstrings.in")
		printMsg "VERBOSE", "Creating maint\extractstrings"
		set fout = f.CreateTextFile("maint\extractstrings")
		contents = fin.ReadAll()
		contents = Replace(contents, "@PERL@", "perl")
		fout.Write(contents)
		fin.Close()
		fout.Close()
		
	End If
	
	If f.FileExists("maint\extractstates") And f.FileExists("maint\extractstrings") Then
		
		Set WshShell = CreateObject("WScript.Shell")
		printMsg "VERBOSE", WshShell.CurrentDirectory & ">perl maint\extractstates"
		WshShell.Run "perl maint\extractstates", 0, true

	Else

		If InStr(1, LCase(WScript.FullName), "cscript") > 0 Then
			printMsg "ERROR", "Missing files: maint\extractstates.in and maint\extractstrings.in"
		End If
 
	End If

End Function

If bForce Then
	GenerateStatesFiles()
End If

'
' Generate the c++ and fortran tests from their templates
'
Function GenerateTemplatedTests()

	set f = WScript.CreateObject("Scripting.FileSystemObject")
	If f.FileExists("test\mpi\maint\testmerge.in") Then

		set fin = f.OpenTextFile("test\mpi\maint\testmerge.in")
		printMsg "VERBOSE", "Creating test\mpi\maint\testmerge"
		set fout = f.CreateTextFile("test\mpi\maint\testmerge")
		contents = fin.ReadAll()
		contents = Replace(contents, "@PERL@", "perl")
		fout.Write(contents)
		fin.Close()
		fout.Close()
		Set WshShell = CreateObject("WScript.Shell")
		WshShell.CurrentDirectory = "test\mpi\cxx\io"
		printMsg "VERBOSE", WshShell.CurrentDirectory & ">perl ..\..\maint\testmerge -defn=..\..\maint\common.defn ioharness.defn ioharness.tlt"
		WshShell.Run "perl ..\..\maint\testmerge -defn=..\..\maint\common.defn ioharness.defn ioharness.tlt", 0, true
		WshShell.CurrentDirectory = "..\..\f77\io"
		printMsg "VERBOSE", WshShell.CurrentDirectory & ">perl ..\..\maint\testmerge -defn=..\..\maint\common.defn ioharness.defn ioharness.tlt"
		WshShell.Run "perl ..\..\maint\testmerge -defn=..\..\maint\common.defn ioharness.defn ioharness.tlt", 0, true
		WshShell.CurrentDirectory = "..\..\..\.."

	Else

		printMsg "VERBOSE", "Missing file: test\mpi\maint\testmerge.in"

	End If

End Function

If bForce Then
	GenerateTemplatedTests()
End If

'
' Validate .in files
'


printMsg "STATUS", "Creating *conf.h header files for MPICH2..."
'
' Generate the conf.h files
'

Sub WriteHeader( fout, str )
	fout.WriteLine( "/* -*- Mode: C; c-basic-offset:4 ; -*- */" & vbNewLine & "/*" & vbNewLine & " *  (C) 2001 by Argonne National Laboratory." & vbNewLine & " *      See COPYRIGHT in top-level directory." & vbNewLine & " */" )
	fout.WriteLine("")
	fout.WriteLine("#ifndef " & UCase(str) & "CONF_H_INCLUDED")
	fout.WriteLine("#define " & UCase(str) & "CONF_H_INCLUDED")
	fout.WriteLine("")
	fout.WriteLine("/* " & str & "conf.h.  Generated automatically by winconfigure.  */")
	fout.WriteLine("")
End Sub

Sub WriteFooter( fout )
	fout.WriteLine("")
	fout.WriteLine("#endif")
End Sub

'
' Write common VS pragmas to header file pointed to by fout
'
Sub WriteCommonVSPragmas(fout)
    ' Disable warnings for unsecure versions, eg: snprintf instead of snprintf_s, of funcs
    fout.WriteLine("#pragma warning( disable : 4996 )") 
    ' Disable warnings for do{}while(0) constructs - conditional expression is constant
    fout.WriteLine("#pragma warning( disable : 4127 )")
End Sub

'
' mpichconf.h
'
printMsg "VERBOSE", "Creating src\include\win32\mpichconf.h"
Set fout = f.CreateTextFile("src\include\win32\mpichconf.h")
Call WriteHeader(fout, "mpich")
Call AddDefinitions(fout, "src\include\mpichconf.h.in", false)
fout.WriteLine("#define HAVE_PROCESS_H")
fout.WriteLine("#ifndef HAVE_WINDOWS_H")
fout.WriteLine("#define HAVE_WINDOWS_H")
fout.WriteLine("#endif")
fout.WriteLine("#ifndef HAVE_WINNT_H")
fout.WriteLine("#define HAVE_WINNT_H")
fout.WriteLine("#endif")
fout.WriteLine("#define HAVE_WINDOWS_SOCKET")
fout.WriteLine("#define HAVE_WINSOCK2_H")
fout.WriteLine("#define HAVE_INTSAFE_H")
fout.WriteLine("#define HAVE_WIN32_SLEEP")
fout.WriteLine("#define HAVE_NT_LOCKS")
fout.WriteLine("#define HAVE_MAPVIEWOFFILE")
fout.WriteLine("#define HAVE_CREATEFILEMAPPING")
fout.WriteLine("#define HAVE_INTERLOCKEDEXCHANGE")
fout.WriteLine("#define HAVE_BOOL")
fout.WriteLine("#define HAVE_CRTDBG_H")
fout.WriteLine("")
fout.WriteLine("#define snprintf _snprintf")
fout.WriteLine("#define inline __inline")
fout.WriteLine("")
fout.WriteLine("#define WITH_SOCK_TYPE SOCK_IOCP")
fout.WriteLine("")
fout.WriteLine("/* Define if building mpich in development mode */")
fout.WriteLine("#define MPICH_DEV_BUILD")
fout.WriteLine("#define MPICH_DBG_OUTPUT")
fout.WriteLine("")
fout.WriteLine("/*#define MPICH_MPI_FROM_PMPI*/")
fout.WriteLine("#define USE_PROCESS_LOCKS 1")
fout.WriteLine("#define USE_THREAD_PACKAGE")
fout.WriteLine("#define USE_WINTHREADS")
fout.WriteLine("#ifndef HAVE_INT64")
fout.WriteLine("#define HAVE_INT64 1")
fout.WriteLine("#define HAVE_PTRTOLONG")
fout.WriteLine("#define HAVE_PTRTOINT")
fout.WriteLine("#define HAVE_PTRTOAINT")
fout.WriteLine("#define HAVE_LONGTOPTR")
fout.WriteLine("#define HAVE_INTTOPTR")
fout.WriteLine("#define HAVE_AINTTOPTR")
fout.WriteLine("#endif")
fout.WriteLine("#ifndef HAVE_STRNICMP")
fout.WriteLine("	#define HAVE_STRNICMP")
fout.WriteLine("#endif")
fout.WriteLine("#ifndef _WIN32_WINNT")
fout.WriteLine("	#define _WIN32_WINNT 0x500")
fout.WriteLine("#endif")
fout.WriteLine("#define HAVE_SWITCHTOTHREAD	1")
fout.WriteLine("#define HAVE_GETLASTERROR 1")
fout.WriteLine("#define HAVE_FORMATMESSAGE 1")
fout.WriteLine("#define HAVE_SRAND 1")
fout.WriteLine("#define HAVE_QUERYPERFORMANCECOUNTER 1")
fout.WriteLine("#ifndef ENABLE_NO_MACRO_VARARG_NAME")
fout.WriteLine("	#define ENABLE_NO_MACRO_VARARG_NAME")
fout.WriteLine("#endif")
' Use Windows Intrinsics for atomics
fout.WriteLine("#define HAVE_NT_INTRINSICS")
' Use Windows SHM
fout.WriteLine("#define HAVE_NT_SHARED_MEM")
fout.WriteLine("#define USE_NT_SHM	1")
fout.WriteLine("#define USE_NT_SOCK 1")
fout.WriteLine("#define HAVE_EXECUTIVE_PE 1")
fout.WriteLine("#define HAVE__MKTEMP_S 1")
fout.WriteLine("#define HAVE_FOPEN_S 1")
WriteCommonVSPragmas(fout)
' Define so that we can test whether the mpichconf.h file has been included 
fout.WriteLine(" /* Define so that we can test whether the mpichconf.h has been included */")
fout.WriteLine("#define HAVE_MPICHCONF 1")
If Not bRemoveFortran Then
	fout.WriteLine("/* Define to #define MPIR_F_TRUE/FALSE to F77_TRUE/FALSE_VALUE */")
	fout.WriteLine("#define F77_USE_BOOLEAN_LITERALS 1")
End If
Call WriteFooter(fout)
fout.Close()
printMsg "VERBOSE", "Creating src\include\win64\mpichconf.h"
Set fout = f.CreateTextFile("src\include\win64\mpichconf.h")
Call WriteHeader(fout, "mpich")
Call AddDefinitions(fout, "src\include\mpichconf.h.in", true)
fout.WriteLine("#define HAVE_PROCESS_H")
fout.WriteLine("#ifndef HAVE_WINDOWS_H")
fout.WriteLine("#define HAVE_WINDOWS_H")
fout.WriteLine("#endif")
fout.WriteLine("#define HAVE_WINDOWS_SOCKET")
fout.WriteLine("#define HAVE_WINSOCK2_H")
fout.WriteLine("#define HAVE_INTSAFE_H")
fout.WriteLine("#define HAVE_WIN32_SLEEP")
fout.WriteLine("#define HAVE_NT_LOCKS")
fout.WriteLine("#define HAVE_MAPVIEWOFFILE")
fout.WriteLine("#define HAVE_CREATEFILEMAPPING")
fout.WriteLine("#define HAVE_INTERLOCKEDEXCHANGE")
fout.WriteLine("#define HAVE_BOOL")
fout.WriteLine("#define HAVE_CRTDBG_H")
fout.WriteLine("")
fout.WriteLine("#define snprintf _snprintf")
fout.WriteLine("#define inline __inline")
fout.WriteLine("")
fout.WriteLine("#define WITH_SOCK_TYPE SOCK_IOCP")
fout.WriteLine("")
fout.WriteLine("/* Define if building mpich in development mode */")
fout.WriteLine("#define MPICH_DEV_BUILD")
fout.WriteLine("#define MPICH_DBG_OUTPUT")
fout.WriteLine("")
fout.WriteLine("/*#define MPICH_MPI_FROM_PMPI*/")
fout.WriteLine("#define USE_PROCESS_LOCKS 1")
fout.WriteLine("#define USE_THREAD_PACKAGE")
fout.WriteLine("#define USE_WINTHREADS")
fout.WriteLine("#ifndef HAVE_INT64")
fout.WriteLine("#define HAVE_INT64 1")
fout.WriteLine("#define HAVE_PTRTOLONG")
fout.WriteLine("#define HAVE_PTRTOINT")
fout.WriteLine("#define HAVE_PTRTOAINT")
fout.WriteLine("#define HAVE_LONGTOPTR")
fout.WriteLine("#define HAVE_INTTOPTR")
fout.WriteLine("#define HAVE_AINTTOPTR")
fout.WriteLine("#endif")
fout.WriteLine("#ifndef HAVE_STRNICMP")
fout.WriteLine("	#define HAVE_STRNICMP")
fout.WriteLine("#endif")
fout.WriteLine("#ifndef _WIN32_WINNT")
fout.WriteLine("	#define _WIN32_WINNT 0x500")
fout.WriteLine("#endif")
fout.WriteLine("#define HAVE_SWITCHTOTHREAD	1")
fout.WriteLine("#define HAVE_GETLASTERROR 1")
fout.WriteLine("#define HAVE_FORMATMESSAGE 1")
fout.WriteLine("#define HAVE_SRAND 1")
fout.WriteLine("#define HAVE_QUERYPERFORMANCECOUNTER 1")
fout.WriteLine("#ifndef ENABLE_NO_MACRO_VARARG_NAME")
fout.WriteLine("	#define ENABLE_NO_MACRO_VARARG_NAME")
fout.WriteLine("#endif")
' Use Windows Intrinsics for atomics
fout.WriteLine("#define HAVE_NT_INTRINSICS")
' Use Windows SHM
fout.WriteLine("#define HAVE_NT_SHARED_MEM")
fout.WriteLine("#define USE_NT_SHM	1")
fout.WriteLine("#define USE_NT_SOCK 1")
fout.WriteLine("#define HAVE_EXECUTIVE_PE 1")
fout.WriteLine("#define HAVE__MKTEMP_S 1")
fout.WriteLine("#define HAVE_FOPEN_S 1")
WriteCommonVSPragmas(fout)
' Define so that we can test whether the mpichconf.h file has been included 
fout.WriteLine(" /* Define so that we can test whether the mpichconf.h has been included */")
fout.WriteLine("#define HAVE_MPICHCONF 1")

If Not bRemoveFortran Then
	fout.WriteLine("/* Define to #define MPIR_F_TRUE/FALSE to F77_TRUE/FALSE_VALUE */")
	fout.WriteLine("#define F77_USE_BOOLEAN_LITERALS 1")
End If
Call WriteFooter(fout)
fout.Close()

'
' mpidi_ch3_conf.h
'
printMsg "VERBOSE", "Creating src\include\win32\mpidi_ch3_conf.h"
Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3_conf.h")
Call WriteHeader(fout, "mpidi_ch3_")
Call AddDefinitions(fout, "src\mpid\ch3\include\mpidi_ch3_conf.h.in", false)
fout.WriteLine("#define EWOULDBLOCK EAGAIN")
fout.WriteLine("#define HAVE_WINTHREADS")
fout.WriteLine("#define MPICH_CPU_TICK_TYPE USE_WIN_X86_CYCLE_ASM")
Call WriteFooter(fout)
fout.Close()
printMsg "VERBOSE", "Creating src\include\win64\mpidi_ch3_conf.h"
Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3_conf.h")
Call WriteHeader(fout, "mpidi_ch3_")
Call AddDefinitions(fout, "src\mpid\ch3\include\mpidi_ch3_conf.h.in", true)
fout.WriteLine("#define EWOULDBLOCK EAGAIN")
fout.WriteLine("#define HAVE_WINTHREADS")
fout.WriteLine("#define MPICH_CPU_TICK_TYPE USE_WIN_X86_CYCLE_ASM")
Call WriteFooter(fout)
fout.Close()

'
' timerconf.h
'
printMsg "VERBOSE", "Creating src\include\win32\timerconf.h"
Set fout = f.CreateTextFile("src\include\win32\timerconf.h")
Call WriteHeader(fout, "timer")
Call AddDefinitions(fout, "src\mpi\timer\timerconf.h.in", false)
Call WriteFooter(fout)
fout.Close()
printMsg "VERBOSE", "Creating src\include\win64\timerconf.h"
Set fout = f.CreateTextFile("src\include\win64\timerconf.h")
Call WriteHeader(fout, "timer")
Call AddDefinitions(fout, "src\mpi\timer\timerconf.h.in", true)
Call WriteFooter(fout)
fout.Close()

'
' mpid_locksconf.h
'
printMsg "VERBOSE", "Creating src\include\win32\mpid_locksconf.h"
Set fout = f.CreateTextFile("src\include\win32\mpid_locksconf.h")
Call WriteHeader(fout, "mpid_locks")
Call AddDefinitions(fout, "src\mpid\common\locks\mpid_locksconf.h.in", false)
Call WriteFooter(fout)
fout.Close()
printMsg "VERBOSE", "Creating src\include\win64\mpid_locksconf.h"
Set fout = f.CreateTextFile("src\include\win64\mpid_locksconf.h")
Call WriteHeader(fout, "mpid_locks")
Call AddDefinitions(fout, "src\mpid\common\locks\mpid_locksconf.h.in", true)
Call WriteFooter(fout)
fout.Close()

'
' mpidu_sock_conf.h
'
printMsg "VERBOSE", "Creating src\include\win32\mpidu_sock_conf.h"
Set fout = f.CreateTextFile("src\include\win32\mpidu_sock_conf.h")
Call WriteHeader(fout, "mpidu_sock_")
Call AddDefinitions(fout, "src\mpid\common\sock\mpidu_sock_conf.h.in", false)
Call WriteFooter(fout)
fout.Close()
printMsg "VERBOSE", "Creating src\include\win64\mpidu_sock_conf.h"
Set fout = f.CreateTextFile("src\include\win64\mpidu_sock_conf.h")
Call WriteHeader(fout, "mpidu_sock_")
Call AddDefinitions(fout, "src\mpid\common\sock\mpidu_sock_conf.h.in", true)
Call WriteFooter(fout)
fout.Close()

'
' ch3u_sock_conf.h
'
printMsg "VERBOSE", "Creating src\include\win32\ch3usockconf.h"
Set fout = f.CreateTextFile("src\include\win32\ch3usockconf.h")
Call WriteHeader(fout, "mpidi_ch3usock")
Call AddDefinitions(fout, "src\mpid\ch3\util\sock\ch3usockconf.h.in", false)
Call WriteFooter(fout)
fout.Close()
printMsg "VERBOSE", "Creating src\include\win64\ch3usockconf.h"
Set fout = f.CreateTextFile("src\include\win64\ch3usockconf.h")
Call WriteHeader(fout, "mpidi_ch3usock")
Call AddDefinitions(fout, "src\mpid\ch3\util\sock\ch3usockconf.h.in", true)
Call WriteFooter(fout)
fout.Close()

'
' pmiconf.h
'
printMsg "VERBOSE", "Creating src\include\win32\pmiconf.h"
Set fout = f.CreateTextFile("src\include\win32\pmiconf.h")
Call WriteHeader(fout, "pmi")
Call AddDefinitions(fout, "src\pmi\smpd\pmiconf.h.in", false)
fout.WriteLine("#ifndef HAVE_WINDOWS_H")
fout.WriteLine("#define HAVE_WINDOWS_H")
fout.WriteLine("#endif")
Call WriteFooter(fout)
fout.Close()
printMsg "VERBOSE", "Creating src\include\win64\pmiconf.h"
Set fout = f.CreateTextFile("src\include\win64\pmiconf.h")
Call WriteHeader(fout, "pmi")
Call AddDefinitions(fout, "src\pmi\smpd\pmiconf.h.in", true)
fout.WriteLine("#ifndef HAVE_WINDOWS_H")
fout.WriteLine("#define HAVE_WINDOWS_H")
fout.WriteLine("#endif")
Call WriteFooter(fout)
fout.Close()

'
' mpiu_os_wrappers_conf.h
'
'If f.FileExists("src\util\wrappers\mpiu_os_wrappers_conf.h.in") Then
'	cEcho "Creating src\util\wrappers\mpiu_os_wrappers_conf.h"
'	Set fout = f.CreateTextFile("src\util\wrappers\mpiu_os_wrappers_conf.h")
'	Call WriteHeader(fout, "mpiu_os_wrappers")
'	Call AddDefinitions(fout, "src\util\wrappers\mpiu_os_wrappers_conf.h.in", false)
'	fout.WriteLine("#ifndef HAVE_WINDOWS_H")
'		fout.WriteLine("#define HAVE_WINDOWS_H")
'	fout.WriteLine("#endif")
'	fout.WriteLine("#define USE_NT_SHM	1")
'	fout.WriteLine("#define USE_NT_SOCK 1")
'	fout.WriteLine("#define HAVE_SWITCHTOTHREAD	1")
'	fout.WriteLine("#define HAVE_GETLASTERROR 1")
'	fout.WriteLine("#define HAVE_FORMATMESSAGE 1")
'	fout.WriteLine("#define HAVE_SRAND 1")
'	fout.WriteLine("#define HAVE_QUERYPERFORMANCECOUNTER 1")
'	fout.WriteLine("#define HAVE_DOUBLEUNDERSCOREINLINE 1")
'	fout.WriteLine("#ifndef __cplusplus")
'		fout.WriteLine("#define HAVE_NOINLINE 1")
'	fout.WriteLine("#endif")
'	Call WriteFooter(fout)
'	fout.Close()
'Else
'	cEcho "Skipping file: mpiu_os_wrappers_conf.h"
'End If

'
' mpidi_ch3i_rdma_conf.h
'
If f.FileExists("src\mpid\ch3\channels\rdma\include\mpidi_ch3i_rdma_conf.h.in") Then
	printMsg "VERBOSE", "Creating src\include\win32\mpidi_ch3i_rdma_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_rdma_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_rdma_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\rdma\include\mpidi_ch3i_rdma_conf.h.in", false)
	fout.WriteLine("#define USE_BUSY_LOCKS")
	Call WriteFooter(fout)
	fout.Close()
	printMsg "VERBOSE", "Creating src\include\win64\mpidi_ch3i_rdma_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_rdma_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_rdma_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\rdma\include\mpidi_ch3i_rdma_conf.h.in", true)
	fout.WriteLine("#define USE_BUSY_LOCKS")
	Call WriteFooter(fout)
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: mpidi_ch3i_rdma_conf.h"
End If

'
' mpidi_ch3i_shm_conf.h
'
If f.FileExists("src\mpid\ch3\channels\shm\include\mpidi_ch3i_shm_conf.h.in") Then
	printMsg "VERBOSE", "Creating src\include\win32\mpidi_ch3i_shm_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_shm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_shm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\shm\include\mpidi_ch3i_shm_conf.h.in", false)
	fout.WriteLine("#define USE_BUSY_LOCKS")
	fout.WriteLine("#define HAVE_SHARED_PROCESS_READ")
	fout.WriteLine("#define USE_RDMA_GET")
	fout.WriteLine("#define USE_SHM_RDMA_GET")
	Call WriteFooter(fout)
	fout.Close()
	printMsg "VERBOSE", "Creating src\include\win64\mpidi_ch3i_shm_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_shm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_shm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\shm\include\mpidi_ch3i_shm_conf.h.in", true)
	fout.WriteLine("#define USE_BUSY_LOCKS")
	fout.WriteLine("#define HAVE_SHARED_PROCESS_READ")
	fout.WriteLine("#define USE_RDMA_GET")
	fout.WriteLine("#define USE_SHM_RDMA_GET")
	Call WriteFooter(fout)
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: mpidi_ch3i_shm_conf.h"
End If

'
' mpidi_ch3i_sock_conf.h
'
If f.FileExists("src\mpid\ch3\channels\sock\include\mpidi_ch3i_sock_conf.h.in") Then
	printMsg "VERBOSE", "Creating src\include\win32\mpidi_ch3i_sock_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_sock_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_sock_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\sock\include\mpidi_ch3i_sock_conf.h.in", false)
	Call WriteFooter(fout)
	fout.Close()
	printMsg "VERBOSE", "Creating src\include\win64\mpidi_ch3i_sock_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_sock_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_sock_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\sock\include\mpidi_ch3i_sock_conf.h.in", true)
	Call WriteFooter(fout)
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: mpidi_ch3i_sock_conf.h"
End If

'
' mpidi_ch3i_ssm_conf.h
'
If f.FileExists("src\mpid\ch3\channels\ssm\include\mpidi_ch3i_ssm_conf.h.in") Then
	printMsg "VERBOSE", "Creating src\include\win32\mpidi_ch3i_ssm_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_ssm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_ssm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\ssm\include\mpidi_ch3i_ssm_conf.h.in", false)
	fout.WriteLine("#define USE_PERSISTENT_SHARED_MEMORY")
	fout.WriteLine("#define HAVE_SHARED_PROCESS_READ")
	fout.WriteLine("#define USE_RDMA_GET")
	fout.WriteLine("#define USE_SHM_RDMA_GET")
	Call WriteFooter(fout)
	fout.Close()
	printMsg "VERBOSE", "Creating src\include\win64\mpidi_ch3i_ssm_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_ssm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_ssm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\ssm\include\mpidi_ch3i_ssm_conf.h.in", true)
	fout.WriteLine("#define USE_PERSISTENT_SHARED_MEMORY")
	fout.WriteLine("#define HAVE_SHARED_PROCESS_READ")
	fout.WriteLine("#define USE_RDMA_GET")
	fout.WriteLine("#define USE_SHM_RDMA_GET")
	Call WriteFooter(fout)
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: mpidi_ch3i_ssm_conf.h"
End If

'
' mpidi_ch3i_nemesis_conf.h
'
If f.FileExists("src\mpid\ch3\channels\nemesis\include\mpidi_ch3i_nemesis_conf.h.in") Then
	printMsg "VERBOSE", "Creating src\mpid\ch3\channels\nemesis\include\mpidi_ch3i_nemesis_conf.h"
	Set fout = f.CreateTextFile("src\mpid\ch3\channels\nemesis\include\mpidi_ch3i_nemesis_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_nemesis_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\nemesis\include\mpidi_ch3i_nemesis_conf.h.in", false)
    ' Use Windows Intrinsics for atomics
	fout.WriteLine("#define HAVE_NT_INTRINSICS")
	Call WriteFooter(fout)
	fout.Close()
Else
	printMsg "VERBOSE","Skipping file: mpidi_ch3i_nemesis_conf.h"
End If
'
' mpidi_ch3i_essm_conf.h
'
'If f.FileExists("src\mpid\ch3\channels\essm\include\mpidi_ch3i_essm_conf.h.in") Then
'	cEcho "Creating src\include\win32\mpidi_ch3i_essm_conf.h"
'	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_essm_conf.h")
'	Call WriteHeader(fout, "mpidi_ch3i_essm_")
'	Call AddDefinitions(fout, "src\mpid\ch3\channels\essm\include\mpidi_ch3i_essm_conf.h.in", false)
'	Call WriteFooter(fout)
'	fout.Close()
'	cEcho "Creating src\include\win64\mpidi_ch3i_essm_conf.h"
'	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_essm_conf.h")
'	Call WriteHeader(fout, "mpidi_ch3i_essm_")
'	Call AddDefinitions(fout, "src\mpid\ch3\channels\essm\include\mpidi_ch3i_essm_conf.h.in", true)
'	Call WriteFooter(fout)
'	fout.Close()
'Else
'	cEcho "Skipping file: mpidi_ch3i_essm_conf.h"
'End If

'
' mpidi_ch3i_sshm_conf.h
'
If f.FileExists("src\mpid\ch3\channels\sshm\include\mpidi_ch3i_sshm_conf.h.in") Then
	printMsg "VERBOSE", "Creating src\include\win32\mpidi_ch3i_sshm_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_sshm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_sshm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\sshm\include\mpidi_ch3i_sshm_conf.h.in", false)
	fout.WriteLine("#define HAVE_MASM_AND_X86")
	fout.WriteLine("#define USE_PERSISTENT_SHARED_MEMORY")
	fout.WriteLine("#define HAVE_SHARED_PROCESS_READ")
	fout.WriteLine("#define USE_RDMA_GET")
	fout.WriteLine("#define USE_SHM_RDMA_GET")
	Call WriteFooter(fout)
	fout.Close()
	printMsg "VERBOSE", "Creating src\include\win64\mpidi_ch3i_sshm_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_sshm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_sshm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\sshm\include\mpidi_ch3i_sshm_conf.h.in", true)
	fout.WriteLine("#define HAVE_MASM_AND_X86")
	fout.WriteLine("#define USE_PERSISTENT_SHARED_MEMORY")
	fout.WriteLine("#define HAVE_SHARED_PROCESS_READ")
	fout.WriteLine("#define USE_RDMA_GET")
	fout.WriteLine("#define USE_SHM_RDMA_GET")
	Call WriteFooter(fout)
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: mpidi_ch3i_sshm_conf.h"
End If

'
' mpidi_ch3i_ib_conf.h
'
If f.FileExists("src\mpid\ch3\channels\ib\include\mpidi_ch3i_ib_conf.h.in") Then
	printMsg "VERBOSE", "Creating src\include\win32\mpidi_ch3i_ib_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_ib_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_ib_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\ib\include\mpidi_ch3i_ib_conf.h.in", false)
	fout.WriteLine("#define MPID_IBU_TYPE_WINDOWS")
	fout.WriteLine("#define __WIN__")
	fout.WriteLine("#define __i386__")
	If bUsePinCache Then
		fout.WriteLine("/*#define USE_NO_PIN_CACHE*/")
	else
		fout.WriteLine("#define USE_NO_PIN_CACHE")
	End If
	fout.WriteLine("/*#define USE_RDMA_GET*/")
	fout.WriteLine("#define USE_RDMA_PUT")
	Call WriteFooter(fout)
	fout.Close()
	printMsg "VERBOSE", "Creating src\include\win64\mpidi_ch3i_ib_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_ib_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_ib_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\ib\include\mpidi_ch3i_ib_conf.h.in", true)
	fout.WriteLine("#define MPID_IBU_TYPE_WINDOWS")
	fout.WriteLine("#define __WIN__")
	If x64 then
		fout.WriteLine("#define __x86_64__")
	else
		fout.WriteLine("#define __ia64__")
	End If
	If bUsePinCache Then
		fout.WriteLine("/*#define USE_NO_PIN_CACHE*/")
	else
		fout.WriteLine("#define USE_NO_PIN_CACHE")
	End If
	fout.WriteLine("/*#define USE_RDMA_GET*/")
	fout.WriteLine("#define USE_RDMA_PUT")
	Call WriteFooter(fout)
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: mpidi_ch3i_ib_conf.h"
End If

'
' Generate mpid_nem_net_module_defs.h
'
If f.FileExists("src\mpid\ch3\channels\nemesis\nemesis\include\mpid_nem_net_module_defs.h.in") Then
	printMsg "VERBOSE","Creating src\mpid\ch3\channels\nemesis\nemesis\include\mpid_nem_net_module_defs.h"
	set fout = f.CreateTextFile("src\mpid\ch3\channels\nemesis\nemesis\include\mpid_nem_net_module_defs.h")
	set fin  = f.OpenTextFile("src\mpid\ch3\channels\nemesis\nemesis\include\mpid_nem_net_module_defs.h.in")
	contents = fin.ReadAll()
	contents = ReplaceAts(contents, false, false)
	fout.Write(contents)
	fin.Close()
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: mpid_nem_net_module_defs.h"
End If

'
' Generate mpid_nem_net_array.c
'
If f.FileExists("src\mpid\ch3\channels\nemesis\nemesis\src\mpid_nem_net_array.c.in") Then
	printMsg "VERBOSE","Creating src\mpid\ch3\channels\nemesis\nemesis\src\mpid_nem_net_array.c"
	set fout = f.CreateTextFile("src\mpid\ch3\channels\nemesis\nemesis\src\mpid_nem_net_array.c")
	set fin  = f.OpenTextFile("src\mpid\ch3\channels\nemesis\nemesis\src\mpid_nem_net_array.c.in")
	contents = fin.ReadAll()
	contents = ReplaceAts(contents, false, false)
	fout.Write(contents)
	fin.Close()
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: mpid_nem_net_array.c"
End If

'
' mpiu_events_conf.h
'
'If f.FileExists("src\util\events\mpiu_events_conf.h.in") Then
'	cEcho "Creating src\include\win32\mpiu_events_conf.h"
'	Set fout = f.CreateTextFile("src\include\win32\mpiu_events_conf.h")
'	Call WriteHeader(fout, "mpiu_events_")
'	Call AddDefinitions(fout, "src\util\events\mpiu_events_conf.h.in", false)
'	fout.WriteLine("#ifndef USE_MPIU_EVENT_TYPE")
'	fout.WriteLine("#define USE_MPIU_EVENT_TYPE MPIU_EVENT_TYPE_WINDOWS")
'	fout.WriteLine("#endif")
'	Call WriteFooter(fout)
'	fout.Close()
'	cEcho "Creating src\include\win64\mpiu_events_conf.h"
'	Set fout = f.CreateTextFile("src\include\win64\mpiu_events_conf.h")
'	Call WriteHeader(fout, "mpiu_events_")
'	Call AddDefinitions(fout, "src\util\events\mpiu_events_conf.h.in", false)
'	fout.WriteLine("#ifndef USE_MPIU_EVENT_TYPE")
'	fout.WriteLine("#define USE_MPIU_EVENT_TYPE MPIU_EVENT_TYPE_WINDOWS")
'	fout.WriteLine("#endif")
'	Call WriteFooter(fout)
'	fout.Close()
'Else
'	Set fout = f.CreateTextFile("src\include\win32\mpiu_events_conf.h")
'	Call WriteHeader(fout, "mpiu_events_")
'	fout.WriteLine("#ifndef USE_MPIU_EVENT_TYPE")
'	fout.WriteLine("#define USE_MPIU_EVENT_TYPE MPIU_EVENT_TYPE_WINDOWS")
'	fout.WriteLine("#endif")
'	Call WriteFooter(fout)
'	fout.Close()
'	Set fout = f.CreateTextFile("src\include\win64\mpiu_events_conf.h")
'	Call WriteHeader(fout, "mpiu_events_")
'	fout.WriteLine("#ifndef USE_MPIU_EVENT_TYPE")
'	fout.WriteLine("#define USE_MPIU_EVENT_TYPE MPIU_EVENT_TYPE_WINDOWS")
'	fout.WriteLine("#endif")
'	Call WriteFooter(fout)
'	fout.Close()
'End If

'
' smpdconf.h
'
If f.FileExists("src\pm\smpd\smpdconf.h.in") Then
	printMsg "VERBOSE", "Creating src\pm\smpd\smpdconf.h"
	Set fout = f.CreateTextFile("src\pm\smpd\smpdconf.h")
        Call WriteHeader(fout, "smpd_")
	Call AddDefinitions(fout, "src\pm\smpd\smpdconf.h.in", false)
        fout.WriteLine("#ifndef HAVE_WINDOWS_H")
	fout.WriteLine("    #define HAVE_WINDOWS_H")
        fout.WriteLine("#endif")
'   Use human readable tokens in MPIU String funcs
'   - should be consistent with settings in mpichconf.h used in
'     compilation of string funcs, argstr.c
        fout.WriteLine("#ifndef USE_HUMAN_READABLE_TOKENS")
	fout.WriteLine("    #define USE_HUMAN_READABLE_TOKENS")
        fout.WriteLine("#endif")
	Call WriteFooter(fout)
	fout.Close()
Else
	cEcho "Skipping file: smpdconf.h"
End If

printMsg "STATUS", "Creating header files for MPL..."
If f.FileExists("src\mpl\include\config.h.in") Then
	printMsg "VERBOSE", "Creating src\mpl\include\mplconfig.h"
	Set fout = f.CreateTextFile("src\mpl\include\mplconfig.h")
	Call WriteHeader(fout, "mplconfig_")
        CreateMPLDefDict()
	Call AddDefinitions(fout, "src\mpl\include\config.h.in", false)
        FreeMPLDefDict()
	fout.Close()
        Call AddPrefixToDefinitions("src\mpl\include\mplconfig.h", "MPL_")
        Set fout = f.OpenTextFile("src\mpl\include\mplconfig.h", 8)
        fout.WriteLine("#define snprintf _snprintf")
        fout.WriteLine("#define inline __inline")
	Call WriteFooter(fout)
        fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: src\mpl\include\config.h.in"
End If

printMsg "STATUS", "Creating config.h header files for OpenPA..."
if not f.FolderExists("src\openpa\src\win32") then
        printMsg "VERBOSE", "Creating src\openpa\src\win32 directory"
	f.CreateFolder("src\openpa\src\win32")
end if
if not f.FolderExists("src\openpa\src\win64") then
        printMsg "VERBOSE", "Creating src\openpa\src\win64 directory"
	f.CreateFolder("src\openpa\src\win64")
end if

If f.FileExists("src\openpa\src\config.h.in") Then
	printMsg "VERBOSE", "Creating src\openpa\src\win32\opa_config.h"
	Set fout = f.CreateTextFile("src\openpa\src\win32\opa_config.h")
	Call WriteHeader(fout, "opa_config_")
	Call AddOPADefinitions(fout, "src\openpa\src\config.h.in", false)
	Call WriteFooter(fout)
	fout.Close()
	printMsg "VERBOSE", "Creating src\openpa\src\win64\opa_config.h"
	Set fout = f.CreateTextFile("src\openpa\src\win64\opa_config.h")
	Call WriteHeader(fout, "opa_config_")
	Call AddOPADefinitions(fout, "src\openpa\src\config.h.in", true)
	Call WriteFooter(fout)
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: src\openpa\src\config.h.in"
End If

printMsg "STATUS", "Creating *conf.h header files for MPE..."
If f.FolderExists("src\mpe2") Then

	'
	' mpe_logging_conf.h
	'
	If f.FileExists("src\mpe2\src\logging\mpe_logging_conf.h.in") Then
		printMsg "VERBOSE", "Creating src\include\win32\mpe_logging_conf.h"
		Set fout = f.CreateTextFile("src\include\win32\mpe_logging_conf.h")
		Call WriteHeader(fout, "mpe_logging_")
		Call AddDefinitions(fout, "src\mpe2\src\logging\mpe_logging_conf.h.in", false)
		fout.WriteLine("#define HAVE_IO_H 1")
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		fout.WriteLine("#define read _read")
		fout.WriteLine("/* #define write _write */")
		fout.WriteLine("#define open _open")
		fout.WriteLine("#define close _close")
		fout.WriteLine("#define mktemp _mktemp")
		fout.WriteLine("#define lseek _lseek")
		fout.WriteLine("#define snprintf _snprintf")
		fout.WriteLine("#define OPEN( a , b , c ) _open( a , b | O_BINARY , c )")
		' Define *_FILENO -- defined in unistd.h in unix
		fout.WriteLine("#define STDOUT_FILENO (_fileno( stdout ))")
		fout.WriteLine("#define STDIN_FILENO (_fileno( stdin ))")
		fout.WriteLine("#define STDERR_FILENO (_fileno( stderr ))")
		Call WriteFooter(fout)
		fout.Close()
		printMsg "VERBOSE", "Creating src\include\win64\mpe_logging_conf.h"
		Set fout = f.CreateTextFile("src\include\win64\mpe_logging_conf.h")
		Call WriteHeader(fout, "mpe_logging_")
		Call AddDefinitions(fout, "src\mpe2\src\logging\mpe_logging_conf.h.in", true)
		fout.WriteLine("#define HAVE_IO_H 1")
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		fout.WriteLine("#define read _read")
		fout.WriteLine("/* #define write _write */")
		fout.WriteLine("#define open _open")
		fout.WriteLine("#define close _close")
		fout.WriteLine("#define mktemp _mktemp")
		fout.WriteLine("#define lseek _lseek")
		fout.WriteLine("#define snprintf _snprintf")
		fout.WriteLine("#define OPEN( a , b , c ) _open( a , b | O_BINARY , c )")
		' Define *_FILENO -- defined in unistd.h in unix
		fout.WriteLine("#define STDOUT_FILENO (_fileno( stdout ))")
		fout.WriteLine("#define STDIN_FILENO (_fileno( stdin ))")
		fout.WriteLine("#define STDERR_FILENO (_fileno( stderr ))")
		Call WriteFooter(fout)
		fout.Close()
	Else
		printMsg "VERBOSE", "Skipping file: mpe_logging_conf.h"
	End If

	'/src/misc/mpe_misc_conf.h.in

	'
	' mpe_wrappers_conf.h
	'
	If f.FileExists("src\mpe2\src\wrappers\mpe_wrappers_conf.h.in") Then
		printMsg "VERBOSE", "Creating src\include\win32\mpe_wrappers_conf.h"
		Set fout = f.CreateTextFile("src\include\win32\mpe_wrappers_conf.h")
		Call WriteHeader(fout, "mpe_wrappers_")
		Call AddDefinitions(fout, "src\mpe2\src\wrappers\mpe_wrappers_conf.h.in", false)
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		Call WriteFooter(fout)
		fout.Close()
		printMsg "VERBOSE", "Creating src\include\win64\mpe_wrappers_conf.h"
		Set fout = f.CreateTextFile("src\include\win64\mpe_wrappers_conf.h")
		Call WriteHeader(fout, "mpe_wrappers_")
		Call AddDefinitions(fout, "src\mpe2\src\wrappers\mpe_wrappers_conf.h.in", true)
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		fout.WriteLine("#define HAVE___ARGV 1")
		Call WriteFooter(fout)
		fout.Close()
	Else
		printMsg "VERBOSE", "Skipping file: mpe_wrappers_conf.h"
	End If

	'/src/slog2sdk/trace_rlog/trace_impl.h.in
	'/src/slog2sdk/trace_sample/trace_impl.h.in

	'
	' mpe_conf.h
	'
	If f.FileExists("src\mpe2\mpe_conf.h.in") Then
		printMsg "VERBOSE", "Creating src\include\win32\mpe_conf.h"
		Set fout = f.CreateTextFile("src\include\win32\mpe_conf.h")
		Call WriteHeader(fout, "mpe_")
		Call AddDefinitions(fout, "src\mpe2\mpe_conf.h.in", false)
		fout.WriteLine("#define HAVE_IO_H 1")
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		fout.WriteLine("#define read _read")
		fout.WriteLine("/* #define write _write */")
		fout.WriteLine("#define open _open")
		fout.WriteLine("#define close _close")
		fout.WriteLine("#define mktemp _mktemp")
		fout.WriteLine("#define lseek _lseek")
		fout.WriteLine("#define snprintf _snprintf")
		fout.WriteLine("#define OPEN( a , b , c ) _open( a , b | O_BINARY , c )")
		Call WriteFooter(fout)
		fout.Close()
		printMsg "VERBOSE", "Creating src\include\win64\mpe_conf.h"
		Set fout = f.CreateTextFile("src\include\win64\mpe_conf.h")
		Call WriteHeader(fout, "mpe_")
		Call AddDefinitions(fout, "src\mpe2\mpe_conf.h.in", true)
		fout.WriteLine("#define HAVE_IO_H 1")
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		fout.WriteLine("#define read _read")
		fout.WriteLine("/* #define write _write */")
		fout.WriteLine("#define open _open")
		fout.WriteLine("#define close _close")
		fout.WriteLine("#define mktemp _mktemp")
		fout.WriteLine("#define lseek _lseek")
		fout.WriteLine("#define snprintf _snprintf")
		fout.WriteLine("#define OPEN( a , b , c ) _open( a , b | O_BINARY , c )")
		Call WriteFooter(fout)
		fout.Close()
	Else
		printMsg "VERBOSE", "Skipping file: mpe_conf.h"
	End If

End If

'
' mpe_callstack_conf.h
'
If f.FileExists("src\mpe2\src\callstack\mpe_callstack_conf.h.in") Then
	printMsg "VERBOSE", "Creating src\mpe2\src\callstack\mpe_callstack_conf.h"
	Set fout = f.CreateTextFile("src\mpe2\src\callstack\mpe_callstack_conf.h")
	Call WriteHeader(fout, "mpe_callstack_")
	Call AddDefinitions(fout, "src\mpe2\src\callstack\mpe_callstack_conf.h.in", false)
	fout.WriteLine("#define HAVE_WINDOWS_H 1")
	Call WriteFooter(fout)
	fout.Close()
Else
	printMsg "VERBOSE", "Skipping file: mpe_callstack_conf.h"
End If


Function ConfigureTestDir

	'
	' mpitestconf.h
	'
	If f.FileExists("test\mpi\include\mpitestconf.h.in") Then
		printMsg "VERBOSE", "Creating src\include\win32\mpitestconf.h"
		Set fout = f.CreateTextFile("src\include\win32\mpitestconf.h") ' Let's avoid adding a new include path to the test projects
		Call WriteHeader(fout, "mpitest")
		Call AddDefinitions(fout, "test\mpi\include\mpitestconf.h.in", false)
		fout.WriteLine("#ifndef HAVE_WINDOWS_H")
		fout.WriteLine("#define HAVE_WINDOWS_H")
		fout.WriteLine("#endif")
		Call WriteFooter(fout)
		fout.Close()
		printMsg "VERBOSE", "Creating src\include\win64\mpitestconf.h"
		Set fout = f.CreateTextFile("src\include\win64\mpitestconf.h") ' Let's avoid adding a new include path to the test projects
		Call WriteHeader(fout, "mpitest")
		Call AddDefinitions(fout, "test\mpi\include\mpitestconf.h.in", true)
		fout.WriteLine("#ifndef HAVE_WINDOWS_H")
		fout.WriteLine("#define HAVE_WINDOWS_H")
		fout.WriteLine("#endif")
		Call WriteFooter(fout)
		fout.Close()
	Else
		printMsg "VERBOSE", "Skipping file: mpitestconf.h"
	End If

	If Not bRemoveFortran Then
		'
		' attraints.h
		'
		If f.FileExists("test\mpi\f77\attr\attraints.h.in") Then
			'cEcho "Creating test\mpi\f77\attr\attraints.h"
			'Set fout = f.CreateTextFile("test\mpi\f77\attr\attraints.h")
			printMsg "VERBOSE", "Creating src\include\win32\attraints.h"
			Set fout = f.CreateTextFile("src\include\win32\attraints.h")
			Set fin = f.OpenTextFile("test\mpi\f77\attr\attraints.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			printMsg "VERBOSE", "Creating src\include\win64\attraints.h"
			Set fout = f.CreateTextFile("src\include\win64\attraints.h")
			Set fin = f.OpenTextFile("test\mpi\f77\attr\attraints.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()
		Else
			printMsg "VERBOSE", "Skipping file: attraints.h"
		End If
		'
		' attr1aints.h
		'
		If f.FileExists("test\mpi\f77\pt2pt\attr1aints.h.in") Then
			printMsg "VERBOSE", "Creating src\include\win32\attr1aints.h"
			Set fout = f.CreateTextFile("src\include\win32\attr1aints.h")
			Set fin = f.OpenTextFile("test\mpi\f77\pt2pt\attr1aints.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			printMsg "VERBOSE", "Creating src\include\win64\attr1aints.h"
			Set fout = f.CreateTextFile("src\include\win64\attr1aints.h")
			Set fin = f.OpenTextFile("test\mpi\f77\pt2pt\attr1aints.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()
		Else
			printMsg "VERBOSE", "Skipping file: attr1aints.h"
		End If

		'
		' typeaints.h
		'
		If f.FileExists("test\mpi\f77\datatype\typeaints.h.in") Then
			'cEcho "Creating test\mpi\f77\datatype\typeaints.h"
			'Set fout = f.CreateTextFile("test\mpi\f77\datatype\typeaints.h")
			printMsg "VERBOSE", "Creating src\include\win32\typeaints.h"
			Set fout = f.CreateTextFile("src\include\win32\typeaints.h")
			Set fin = f.OpenTextFile("test\mpi\f77\datatype\typeaints.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			printMsg "VERBOSE", "Creating src\include\win64\typeaints.h"
			Set fout = f.CreateTextFile("src\include\win64\typeaints.h")
			Set fin = f.OpenTextFile("test\mpi\f77\datatype\typeaints.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()
		Else
			printMsg "VERBOSE", "Skipping file: typeaints.h"
		End If

		'
		' ioaint.h
		'
		If f.FileExists("test\mpi\f77\io\ioaint.h.in") Then
			'cEcho "Creating test\mpi\f77\io\ioaint.h"
			'Set fout = f.CreateTextFile("test\mpi\f77\io\ioaint.h")
			printMsg "VERBOSE", "Creating src\include\win32\ioaint.h"
			Set fout = f.CreateTextFile("src\include\win32\ioaint.h")
			Set fin = f.OpenTextFile("test\mpi\f77\io\ioaint.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			printMsg "VERBOSE", "Creating src\include\win64\ioaint.h"
			Set fout = f.CreateTextFile("src\include\win64\ioaint.h")
			Set fin = f.OpenTextFile("test\mpi\f77\io\ioaint.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()
		Else
			printMsg "VERBOSE", "Skipping file: ioaint.h"
		End If

		'
		' iooffset.h
		'
		If f.FileExists("test\mpi\f77\io\iooffset.h.in") Then
			'cEcho "Creating test\mpi\f77\io\iooffset.h"
			'Set fout = f.CreateTextFile("test\mpi\f77\io\iooffset.h")
			printMsg "VERBOSE", "Creating src\include\win32\iooffset.h"
			Set fout = f.CreateTextFile("src\include\win32\iooffset.h")
			Set fin = f.OpenTextFile("test\mpi\f77\io\iooffset.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			printMsg "VERBOSE", "Creating src\include\win64\iooffset.h"
			Set fout = f.CreateTextFile("src\include\win64\iooffset.h")
			Set fin = f.OpenTextFile("test\mpi\f77\io\iooffset.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()
		Else
			printMsg "VERBOSE", "Skipping file: iooffset.h"
		End If

		'
		' iodisp.h
		'
		If f.FileExists("test\mpi\f77\io\iodisp.h.in") Then
			'cEcho "Creating test\mpi\f77\io\iodisp.h"
			'Set fout = f.CreateTextFile("test\mpi\f77\io\iodisp.h")
			printMsg "VERBOSE", "Creating src\include\win32\iodisp.h"
			Set fout = f.CreateTextFile("src\include\win32\iodisp.h")
			Set fin = f.OpenTextFile("test\mpi\f77\io\iodisp.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			printMsg "VERBOSE", "Creating src\include\win64\iodisp.h"
			Set fout = f.CreateTextFile("src\include\win64\iodisp.h")
			Set fin = f.OpenTextFile("test\mpi\f77\io\iodisp.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()
		Else
			printMsg "VERBOSE", "Skipping file: iodisp.h"
		End If

		'
		' addsize.h
		'
		If f.FileExists("test\mpi\f77\rma\addsize.h.in") Then
			'cEcho "Creating test\mpi\f77\rma\addsize.h"
			'Set fout = f.CreateTextFile("test\mpi\f77\rma\addsize.h")
			printMsg "VERBOSE", "Creating src\include\win32\addsize.h"
			Set fout = f.CreateTextFile("src\include\win32\addsize.h")
			Set fin = f.OpenTextFile("test\mpi\f77\rma\addsize.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			printMsg "VERBOSE", "Creating src\include\win64\addsize.h"
			Set fout = f.CreateTextFile("src\include\win64\addsize.h")
			Set fin = f.OpenTextFile("test\mpi\f77\rma\addsize.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()
		Else
			printMsg "VERBOSE", "Skipping file: addsize.h"
		End If

		'
		' type1aint.h
		'
		If f.FileExists("test\mpi\f77\spawn\type1aint.h.in") Then
			'cEcho "Creating test\mpi\f77\spawn\type1aint.h"
			'Set fout = f.CreateTextFile("test\mpi\f77\spawn\type1aint.h")
			printMsg "VERBOSE", "Creating src\include\win32\type1aint.h"
			Set fout = f.CreateTextFile("src\include\win32\type1aint.h")
			Set fin = f.OpenTextFile("test\mpi\f77\spawn\type1aint.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			printMsg "VERBOSE", "Creating src\include\win64\type1aint.h"
			Set fout = f.CreateTextFile("src\include\win64\type1aint.h")
			Set fin = f.OpenTextFile("test\mpi\f77\spawn\type1aint.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()
		Else
			printMsg "VERBOSE", "Skipping file: type1aint.h"
		End If

	End If

End Function

printMsg "STATUS", "Configuring MPICH2 test directory..."
ConfigureTestDir()

'
' fooconf.h
'
'Set fout = f.CreateTextFile("src\include\fooconf.h")
'Call WriteHeader(fout, "foo")
'Call AddDefinitions(fout, "src\include\fooconf.h.in", false)
'fout.WriteLine("foo specific stuff")
'Call WriteFooter(fout)
'fout.Close()

'
' Generate mpicc
'
Function GenerateMPICC()
	set f = WScript.CreateObject("Scripting.FileSystemObject")
	vbLessThan = "<"
	vbGreaterThan = ">"
	path_to_mpich = f.GetAbsolutePathName("winconfigure.wsf")
	path_to_mpich = Left(path_to_mpich, Len(path_to_mpich) - 16)
	If Not f.FolderExists("bin") Then
		f.CreateFolder("bin")
	End If
	printMsg "VERBOSE", "Creating bin\mpicc.wsf"
	Set fout = f.CreateTextFile("bin\mpicc.wsf")
	fout.WriteLine(vbLessThan & "package" & vbGreaterThan)
	fout.WriteLine(vbLessThan & "job id=""mpicc""" & vbGreaterThan)
	fout.WriteLine("    " & vbLessThan & "runtime" & vbGreaterThan)
	fout.WriteLine("        " & vbLessThan & "description" & vbGreaterThan & "This script compiles C console MPICH2 applications" & vbLessThan & "/description" & vbGreaterThan)
	fout.WriteLine("        " & vbLessThan & "unnamed")
	fout.WriteLine("            name = ""file""")
	fout.WriteLine("            helpstring = ""List the source files to compile""")
	fout.WriteLine("            many = ""true""")
	fout.WriteLine("            required = ""1""")
	fout.WriteLine("        /" & vbGreaterThan)
	fout.WriteLine("        " & vbLessThan & "named")
	fout.WriteLine("            name = ""out""")
	fout.WriteLine("            helpstring = ""Name of the output executable, default=myapp.exe""")
	fout.WriteLine("            type = ""string""")
	fout.WriteLine("            required = ""false""")
	fout.WriteLine("        /" & vbGreaterThan)
	fout.WriteLine("        " & vbLessThan & "example" & vbGreaterThan & "Example: mpicc main.c /out:foobar.exe" & vbLessThan & "/example" & vbGreaterThan)
	fout.WriteLine("    " & vbLessThan & "/runtime" & vbGreaterThan)
	fout.WriteLine(vbLessThan & "script language=""VBScript""" & vbGreaterThan)
	fout.WriteLine("")
	fout.WriteLine("' Set defaults")
	fout.WriteLine("outputExe = ""myapp.exe""")
	fout.WriteLine("")
	fout.WriteLine("If WScript.Arguments.Unnamed.Count = 0 Then")
	fout.WriteLine("    WScript.Arguments.ShowUsage")
	fout.WriteLine("    WScript.Quit")
	fout.WriteLine("End If")
	fout.WriteLine("")
	fout.WriteLine("Set f = WScript.CreateObject(""Scripting.FileSystemObject"")")
	fout.WriteLine("")
	fout.WriteLine("' Process named arguments")
	fout.WriteLine("If WScript.Arguments.Named.Exists(""out"") Then")
	fout.WriteLine("	outputExe = WScript.Arguments.Named.Item(""out"")")
	fout.WriteLine("End If")
	fout.WriteLine("")
	fout.WriteLine("' Create a new instance of Visual Studio .NET.")
	fout.WriteLine("Set DTE = WScript.CreateObject(""VisualStudio.DTE.7.1"")")
	fout.WriteLine("Set solution = DTE.Solution")
	if bVS2005 then
	    fout.WriteLine("solution.Open(""" & path_to_mpich & "examples\windows\skeleton\skeleton.vs05.sln"")")
	else
	    fout.WriteLine("solution.Open(""" & path_to_mpich & "examples\windows\skeleton\skeleton.sln"")")
	end if
	fout.WriteLine("Set project = solution.Projects.Item(1)")
	fout.WriteLine("")
	fout.WriteLine("' Add the C files to the project")
	fout.WriteLine("Set Cfiles = WScript.Arguments.Unnamed")
	fout.WriteLine("For arg = 0 To Cfiles.Count - 1")
	fout.WriteLine("	Cfile = Cfiles(arg)")
	fout.WriteLine("	Cfile = f.GetAbsolutePathName(Cfile)")
	fout.WriteLine("	project.ProjectItems.AddFromFile(Cfile)")
	fout.WriteLine("Next")
	fout.WriteLine("")
	fout.WriteLine("' Build the solution")
	fout.WriteLine("solution.SolutionBuild.Build()")
	fout.WriteLine("")
	fout.WriteLine("While solution.SolutionBuild.BuildState " & vbLessThan & vbGreaterThan & " 3")
	fout.WriteLine("	WScript.Sleep 1000")
	fout.WriteLine("Wend")
	fout.WriteLine("")
	fout.WriteLine("' Save the output on error")
	fout.WriteLine("If solution.SolutionBuild.LastBuildInfo " & vbLessThan & vbGreaterThan & " 0 Then")
	fout.WriteLine("	WScript.Echo ""Build failed""")
	fout.WriteLine("	Set shell = WScript.CreateObject(""WScript.shell"")")
	fout.WriteLine("	shell.run """ & path_to_mpich & "examples\windows\skeleton\Debug\BuildLog.htm""")
	fout.WriteLine("End If")
	fout.WriteLine("")
	fout.WriteLine("' Remove the C files from the project")
	fout.WriteLine("For i = 1 To project.ProjectItems.Count")
	fout.WriteLine("	If project.ProjectItems.Item(i).Name = ""Source Files"" Then")
	fout.WriteLine("		index = i")
	fout.WriteLine("	End If")
	fout.WriteLine("Next")
	fout.WriteLine("For arg = 0 To Cfiles.Count - 1")
	fout.WriteLine("	Cfile = Cfiles(arg)")
	fout.WriteLine("	Cfile = f.GetFileName(Cfile)")
	fout.WriteLine("	For i = project.ProjectItems.Item(index).ProjectItems.Count To 1 Step -1")
	fout.WriteLine("		If project.ProjectItems.Item(index).ProjectItems.Item(i).Name = Cfile Then")
	fout.WriteLine("			project.ProjectItems.Item(index).ProjectItems.Item(i).Remove()")
	fout.WriteLine("		End If")
	fout.WriteLine("	Next")
	fout.WriteLine("Next")
	fout.WriteLine("")
	fout.WriteLine("' Copy the executable")
	fout.WriteLine("If f.FileExists(""" & path_to_mpich & "examples\windows\skeleton\Debug\skeleton.exe"") Then")
	fout.WriteLine("	f.CopyFile """ & path_to_mpich & "examples\windows\skeleton\Debug\skeleton.exe"", outputExe, True")
	fout.WriteLine("End If")
	fout.WriteLine("")
	fout.WriteLine("' Clean up")
	fout.WriteLine("solution.SolutionBuild.Clean()")
	fout.WriteLine("")
	fout.WriteLine(vbLessThan & "/script" & vbGreaterThan)
	fout.WriteLine(vbLessThan & "/job" & vbGreaterThan)
	fout.WriteLine(vbLessThan & "/package" & vbGreaterThan)
	fout.Close()
End Function

GenerateMPICC()

Function MyTrim(str)
	str = Trim(str)
	while (Left(str, 1) = vbTab)
		str = Right(str, Len(str) - 1)
	wend
	while (Right(str, 1) = vbTab)
		str = Left(str, Len(str) - 1)
	wend
	MyTrim = str
End Function

' Use this function to exclude files that shouldn't be compiled
Function CompileFile(fname)
	CompileFile = true
	'fname = MyTrim(fname)
	If fname = "" Then
		CompileFile = false
	End If
	If fname = "$(mpi_sources)" Then
		CompileFile = false
	End If
	If fname = "${mpi_sources}" Then
		CompileFile = false
	End If
	If fname = "${socksources}" Then
		CompileFile = false
	End If
	If fname = "timelimit.c" Then
		CompileFile = false
	End If
	If fname = "dbg_control.c" Then
		CompileFile = false
	End If
	If fname = "dbginit.c" Then
		CompileFile = false
	End If
	If fname = "groupdebug.c" Then
		CompileFile = false
	End If
	if Left(fname, 1) = "@" Then
		CompileFile = false
	End If
	If Right(fname, 2) = ".h" Then
		CompileFile = false
	End If
'	If fname = "register_datarepf.c" Then
'		CompileFile = false
'	End If
	If fname = "fileutil.c" Then
		CompileFile = false
	End If
End Function

Sub OutputLine(path, line)
	Dim do_output
	do_output = false
	If Left(line, 14) = "mpi_sources = " Then
		line = Right(line, Len(line) - 14)
		do_output = true
	End If
	If Left(line, 28) = "lib${MPILIBNAME}_a_SOURCES =" Then
		line = Right(line, Len(line) - 28)
		do_output = true
	End If
	If Left(line, 18) = "libmpl_a_SOURCES =" Then
		line = Right(line, Len(line) - 18)
		do_output = true
	End If
	If Left(line, 29) = "lib${MPIFLIBNAME}_a_SOURCES =" Then
		line = Right(line, Len(line) - 29)
		do_output = true
	End If
	If Left(line, 14) = "win_sources = " Then
		line = Right(line, Len(line) - 14)
		do_output = true
	End If
	If Left(line, 14) = "socksources = " Then
		line = Right(line, Len(line) - 14)
		do_output = true
	End If
	If do_output Then
		'WScript.Echo line
		line = Replace(line, "	", " ")
		fnames = Split(line)
		For Each fname in fnames
			fname = MyTrim(fname)
			If CompileFile(fname) Then
				If creating_rules Then
					' Make a rule for the entire directory
					files_found = true
					If Right(fname, 4) = ".cpp" Or Right(fname, 4) = ".cxx" Then
						cxx_files_found = true
					End If
					If Right(fname, 2) = ".f" Then
						fortran_files_found = true
					End If
					' Make rules for each individual file
					'mfile.WriteLine("$(" & outdir & ")\" & Left(fname, Len(fname) -1) & "obj: ..\" & path & "\" & fname)
					'mfile.WriteLine("	$(cc) $(cflags) /Fo""$(" & outdir & ")\\"" /Fd""$(" & outdir & ")\\"" ..\" & path & "\" & fname)
				Else
					'WScript.Echo path & "\" & fname
					' remove the file extension
					If Right(fname, 4) = ".cpp" Or Right(fname, 4) = ".cxx" Then
						fname = Left(fname, Len(fname) - 3)
					Else
						fname = Left(fname, Len(fname) - 1)
					End If
					mfile.Write(" \" & vbCrLF & "	$(" & outdir & ")\" & fname & "obj")
				End If
			End If
		Next
	End If
End Sub

' Returns true if name (folder/file name) is excluded from build
' eg: We don't want to compile sock/poll on windows
Function IsInBuildExclusionList(name)
    IsInBuildExclusionList = false
    If Right(name, 4) = "poll" Then
        IsInBuildExclusionList = true
    End If
End Function

compile_flags=""
Sub SetCompileFlags(flags)
    If compile_flags <> "" Then
        printMsg "ERROR", "Setting compile flags before resetting the prev saved state is not supported"
    Else
        compile_flags = flags
    End If
End Sub
Function IsSetCompileFlags()
    If compile_flags <> "" Then
        IsSetCompileFlags = True
    Else
        IsSetCompileFlags = False
    End If
End Function
Function GetCompileFlags()
    GetCompileFlags = compile_flags
End Function

Sub ResetCompileFlags()
    If compile_flags = "" Then
        printMsg "ERROR", "Dup reset of compile flags"
    End If
    compile_flags = ""
End Sub

Sub FindSimpleMakeFiles(folder, trimpath)
	For Each sub_folder in folder.SubFolders
                If Not IsInBuildExclusionList(sub_folder) Then
		    FindSimpleMakeFiles sub_folder, trimpath
                End If
	Next
	For Each file in folder.Files
		If file.Name = "Makefile.sm" Then
			Dim line, fullline
			Set fin = f.OpenTextFile(file.Path)
			'WScript.Echo file.ParentFolder
			fullline = ""
			files_found = false
			cxx_files_found = false
			fortran_files_found = false
			while not fin.AtEndOfStream
				line = MyTrim(fin.ReadLine)
				If Left(line, 1) <> "#" Then
					If Right(line, 1) = "\" Then
						If fullline = "" Then
							fullline = Left(line, len(line)-1)
						Else
							fullline = fullline & " " & Left(line, len(line)-1)
						End If
					Else
						If fullline = "" Then
							fullline = line
						Else
							fullline = fullline & " " & line
						End If
						'OutputLine file.ParentFolder, fullline
						OutputLine Right(file.ParentFolder, Len(file.ParentFolder) - trimpath), fullline
						fullline = ""
					End If
				End If
			wend
			fin.Close
			If creating_rules And files_found Then
				mfile.WriteLine("{..\" & Right(file.ParentFolder, Len(file.ParentFolder) - trimpath) & "}.c{$(" & outdir & ")}.obj:")
				mfile.Write("    $(cc) ")
                                If IsSetCompileFlags() Then
                                    ' Get the compiler flags and use it
                                    mfile.Write(GetCompileFlags() & " ")
                                Else
                                    ' Use default cflags
                                    mfile.Write(" $(cflags) ")
                                End If
				If extra_flags <> "" Then
					mfile.Write(extra_flags & " ")
				End If
				mfile.WriteLine("/Fo""$(" & outdir & ")\\"" /Fd""$(" & outdir & ")\\"" $**")
				mfile.WriteLine
				If cxx_files_found Then
					mfile.WriteLine("{..\" & Right(file.ParentFolder, Len(file.ParentFolder) - trimpath) & "}.cpp{$(" & outdir & ")}.obj:")
					mfile.WriteLine("    $(cc) $(" & cxxflags & ") /Fo""$(" & outdir & ")\\"" /Fd""$(" & outdir & ")\\"" $**")
					mfile.WriteLine
					mfile.WriteLine("{..\" & Right(file.ParentFolder, Len(file.ParentFolder) - trimpath) & "}.cxx{$(" & outdir & ")}.obj:")
					mfile.WriteLine("    $(cc) $(" & cxxflags & ") /Fo""$(" & outdir & ")\\"" /Fd""$(" & outdir & ")\\"" $**")
					mfile.WriteLine
				End If
				If fortran_files_found Then
					mfile.WriteLine("{..\" & Right(file.ParentFolder, Len(file.ParentFolder) - trimpath) & "}.f{$(" & outdir & ")}.obj:")
					'mfile.WriteLine("    $(fc) $(" & fort_prefix & "fortflags) /Fo""$(" & outdir & ")\\"" /Fd""$(" & outdir & ")\\"" $**")
					mfile.WriteLine("    $(fc) $(" & fort_prefix & "fortflags) /module:""$(" & outdir & ")\\"" /object:""$(" & outdir & ")\\"" $**")
					mfile.WriteLine
				End If
			End If
		End If
	Next
End Sub

Sub CreateRules(folder, trimpath)
	creating_rules = true
	FindSimpleMakeFiles folder, trimpath
End Sub

Sub CreateObjs(package, folder, trimpath, do_start, do_end)
	creating_rules = false
	If do_start Then
		mfile.Write(package & "_objs =")
	End If
	FindSimpleMakeFiles folder, trimpath
	If do_end Then
		mfile.WriteLine
		mfile.WriteLine
	End If
End Sub

Function GenBuild()
	If Not f.FolderExists("winbuild") Then
		f.CreateFolder("winbuild")
	End If
	Set bfile = f.CreateTextFile("winbuild\build.bat", true)
	bfile.WriteLine("REM   (C) 2001 by Argonne National Laboratory.")
	bfile.WriteLine("REM      See COPYRIGHT in top-level directory.")
	bfile.WriteLine
	bfile.WriteLine("IF ""%1"" == """" ( SET SILENT=/S ) ELSE ( SET SILENT= )")
	bfile.WriteLine("nmake %SILENT%")
	bfile.WriteLine("nmake %SILENT% /NOLOGO CHANNEL=sock RLOG=1")
	bfile.WriteLine("nmake %SILENT% /NOLOGO CHANNEL=mt")
	bfile.WriteLine("nmake %SILENT% /NOLOGO CHANNEL=mt RLOG=1")
	bfile.WriteLine("nmake %SILENT% /NOLOGO CHANNEL=nemesis")
	bfile.WriteLine("nmake %SILENT% /NOLOGO CHANNEL=nemesis RLOG=1")
'	bfile.WriteLine("REM nmake %SILENT% /NOLOGO CHANNEL=sshm")
'	bfile.WriteLine("REM nmake %SILENT% /NOLOGO CHANNEL=sshm RLOG=1")
'	bfile.WriteLine("REM nmake %SILENT% /NOLOGO CHANNEL=ib IB=IBAL IB_PATH=c:\ibal\src\base IB_PATH_LIB=c:\ibal\Install")
'	bfile.WriteLine("REM nmake %SILENT% /NOLOGO CHANNEL=ib IB=IBAL IB_PATH=c:\ibal\src\base IB_PATH_LIB=c:\ibal\Install RLOG=1")
'	bfile.WriteLine("REM nmake %SILENT% /NOLOGO CHANNEL=ib IB=VAPI")
'	bfile.WriteLine("REM nmake %SILENT% /NOLOGO CHANNEL=ib IB=VAPI RLOG=1")
'	bfile.WriteLine("REM nmake %SILENT% /NOLOGO CHANNEL=essm")
'	bfile.WriteLine("REM nmake %SILENT% /NOLOGO CHANNEL=essm RLOG=1")
	bfile.WriteLine("nmake %SILENT% /NOLOGO cxx")
	bfile.WriteLine("nmake %SILENT% /NOLOGO fort")
	bfile.WriteLine("nmake %SILENT% /NOLOGO mpi_mod")
	bfile.WriteLine("nmake %SILENT% /NOLOGO gfort")
	bfile.WriteLine("nmake %SILENT% /NOLOGO sfort")
	bfile.WriteLine("nmake %SILENT% /NOLOGO irlog2rlog")
	bfile.WriteLine("nmake %SILENT% /NOLOGO TraceInput")
	bfile.WriteLine("nmake %SILENT% /NOLOGO gcc_libs")
	bfile.WriteLine("nmake %SILENT% /NOLOGO impgen")
	bfile.Close()

	Set mfile = f.CreateTextFile("winbuild\makefile", true)
	mfile.WriteLine("#")
	mfile.WriteLine("#   (C) 2001 by Argonne National Laboratory.")
	mfile.WriteLine("#      See COPYRIGHT in top-level directory.")
	mfile.WriteLine("#")
	mfile.WriteLine
	mfile.WriteLine("!IF ( ""$(CPU)"" == ""i386"" ) || ( ""$(CPU)"" == ""I386"" ) || ( ""$(CPU)"" == ""X86"" ) || ( ""$(CPU)"" == """" ) || ( ""$(CPU)"" == ""ia32"" ) || ( ""$(CPU)"" == ""IA32"" )")
	mfile.WriteLine("CPU = x86")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!IF ( ""$(CPU)"" == ""X64"" ) || ( ""$(CPU)"" == ""AMD64"" ) || ( ""$(CPU)"" == ""amd64"" )")
	mfile.WriteLine("CPU = x64")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!IF ""$(CPU)"" == ""IA64""")
	mfile.WriteLine("CPU = ia64")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CPU)"" != ""x86""")
	mfile.WriteLine("!IF ""$(CPU)"" != ""x64""")
	mfile.WriteLine("!IF ""$(CPU)"" != ""ia64""")
	mfile.WriteLine("!ERROR  Must specify CPU environment variable ( CPU=i386,x86,ia32,x64,amd64,ia64 )")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(cc)"" == """"")
	mfile.WriteLine("cc     = cl")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!IF ""$(link)"" == """"")
	mfile.WriteLine("link   = link")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!IF ""$(implib)"" == """"")
	mfile.WriteLine("implib = lib")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!IF ""$(fc)"" == """"")
	mfile.WriteLine("fc = ifort")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IFDEF MPICH2_CFLAGS")
	mfile.WriteLine("common_cflags = $(common_cflags) $(MPICH2_CFLAGS)")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CPU)"" == ""x86""")
	mfile.WriteLine("common_cflags = $(common_cflags) -D_X86_=1 -DWIN32 -D_WIN32 -W3")
	mfile.WriteLine("!ELSEIF ""$(CPU)"" == ""x64""")
	'mfile.WriteLine("common_cflags = $(common_cflags) -D_AMD64_=1 -D__x86_64__ -DWIN64 -D_WIN64 -Wp64 -W4")
	mfile.WriteLine("common_cflags = $(common_cflags) -D_AMD64_=1 -DWIN64 -D_WIN64 -Wp64 -W4")
	mfile.WriteLine("!ELSEIF ""$(CPU)"" == ""ia64""")
	mfile.WriteLine("common_cflags = $(common_cflags) -D_IA64_=1 -DWIN64 -D_WIN64 -Wp64 -W4")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IFNDEF APPVER")
	mfile.WriteLine("APPVER = 5.0")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!IF ""$(APPVER)"" == ""5.0""")
	mfile.WriteLine("NMAKE_WINVER = 0x0500")
	mfile.WriteLine("!ELSEIF ""$(APPVER)"" == ""5.01""")
	mfile.WriteLine("NMAKE_WINVER = 0x0501")
	mfile.WriteLine("!ELSEIF ""$(APPVER)"" == ""5.02""")
	mfile.WriteLine("NMAKE_WINVER = 0x0502")
	mfile.WriteLine("!ELSEIF ""$(APPVER)"" == ""6.0""")
	mfile.WriteLine("NMAKE_WINVER = 0x0600")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("common_cflags = $(common_cflags) -Oi -D_WINNT -D_WIN32_WINNT=$(NMAKE_WINVER)")
	mfile.WriteLine
        mfile.WriteLine("# Set USE_MTDLL_RUNLIB env variable to 1 if you need to use")
        mfile.WriteLine("# Multithreaded dynamic link runtime library to build MPICH2")
        mfile.WriteLine("# Default is multithreaded static run lib")
                        ' IF (NODEBUG)
	mfile.WriteLine("!IFDEF NODEBUG")
	mfile.WriteLine("common_cflags = $(common_cflags) -DNDEBUG -D_MT")
	mfile.WriteLine("!IFDEF ENABLE_FAST")
	mfile.WriteLine("common_cflags = $(common_cflags) -Ox -Ob2 -Ot -GS- -GR-")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("common_cflags = $(common_cflags) -O2 -DHAVE_ERROR_CHECKING=MPID_ERROR_LEVEL_ALL")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!IFDEF USE_MTDLL_RUNLIB")
	mfile.WriteLine("common_cflags = $(common_cflags) -D_DLL -MD")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("common_cflags = $(common_cflags) -MT")
	mfile.WriteLine("!ENDIF")
                        ' ELSE (NODEBUG)
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("common_cflags = $(common_cflags) -DHAVE_ERROR_CHECKING=MPID_ERROR_LEVEL_ALL -DUSE_DBG_LOGGING -DDEBUG -Zi -Od -D_MT")
	mfile.WriteLine("!IFDEF USE_MTDLL_RUNLIB")
	mfile.WriteLine("common_cflags = $(common_cflags) -D_DLL -MDd")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("common_cflags = $(common_cflags) -MTd")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
        ' FIXME: We should try to use CCP_SDK env instead of hardcoding the HPC SDK path
        ' WARNING: This HPC SDK include path contains its own mpi.h - So include it with caution
        mfile.WriteLine("MS_HPC_SDK_INC_PATH = ""C:\Program Files\Microsoft HPC Pack 2008 SDK\Include""")
	mfile.WriteLine
        mfile.WriteLine("MS_HPC_SDK_ND_INC_PATH = ""C:\Program Files\Microsoft HPC Pack 2008 SDK\NetworkDirect\Include""")
	mfile.WriteLine
        ' The HPC SDK lib path contains the type libraries required for interfacing with the HPC job manager
	mfile.WriteLine("!IF ""$(CPU)"" == ""x86""")
	mfile.WriteLine("MS_HPC_SDK_LIB_PATH = ""C:\Program Files\Microsoft HPC Pack 2008 SDK\Lib\i386""")
	mfile.WriteLine("!ELSEIF ""$(CPU)"" == ""x64""")
	mfile.WriteLine("MS_HPC_SDK_LIB_PATH = ""C:\Program Files\Microsoft HPC Pack 2008 SDK\Lib\amd64""")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("lflags  = $(lflags) /LIBPATH:$(MS_HPC_SDK_LIB_PATH) /OPT:REF /INCREMENTAL:NO /NOLOGO /MANIFEST")
	mfile.WriteLine("!IFDEF NODEBUG")
	mfile.WriteLine("lflags = $(lflags) /RELEASE")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("lflags = $(lflags) /DEBUG:full /DEBUGTYPE:cv")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("conlflags = $(lflags) -subsystem:console,$(APPVER)")
	mfile.WriteLine("dlllflags = $(lflags) -dll")
	mfile.WriteLine("liblflags =")
	' End of win32.mak replacement
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CHANNEL)"" == """"")
	mfile.WriteLine("CHANNEL = sock")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IFDEF NODEBUG")
	mfile.WriteLine("D =")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("D = d")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IFDEF RLOG")
	mfile.WriteLine("P = p")
	mfile.WriteLine("common_cflags = $(common_cflags) /DHAVE_STRNICMP /DHAVE_TIMING=MPID_TIMING_KIND_LOG_DETAILED /DUSE_LOGGING=MPID_LOGGING_RLOG")
	mfile.WriteLine("rlog_libs = $(RLOG_OUTDIR)\rlog$(D).lib")
	mfile.WriteLine("PLIB_DEP = rlog")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("P =")
	mfile.WriteLine("rlog_libs =")
	mfile.WriteLine("PLIB_DEP =")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("common_cflags = -c -nologo $(common_cflags) \")
	mfile.WriteLine(" /DHAVE_WINDOWS_H \")
	mfile.WriteLine(" /DUSE_WINCONF_H \")
	mfile.WriteLine(" /DMPIO_BUILD_PROFILING \")
	mfile.WriteLine(" /DROMIO_INSIDE_MPICH2")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(NO_FORTRAN)"" == """"")
	mfile.WriteLine("common_cflags = $(common_cflags) /DHAVE_FORTRAN_BINDING")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("common_cflags = $(common_cflags) \")
        mfile.WriteLine(" /I$(MS_HPC_SDK_LIB_PATH) \")
        mfile.WriteLine(" /I$(MS_HPC_SDK_ND_INC_PATH) \")
	mfile.WriteLine(" /I..\src\include \")
	mfile.WriteLine(" /I..\src\util\wrappers \")
	mfile.WriteLine(" /I..\src\openpa\src \")
	mfile.WriteLine(" /I..\src\mpl\include \")
	mfile.WriteLine(" /I..\src\mpid\ch3\include \")
	mfile.WriteLine(" /I..\src\mpid\ch3\channels\$(CHANNEL)\include \")
	mfile.WriteLine(" /I..\src\mpid\ch3\channels\$(CHANNEL)\src \")
	mfile.WriteLine(" /I..\src\mpid\common\sock \")
	mfile.WriteLine(" /I..\src\mpid\common\sock\iocp \")
	mfile.WriteLine(" /I..\src\mpid\ch3\util\sock \")
	mfile.WriteLine(" /I..\src\mpi\romio\mpi-io \")
	mfile.WriteLine(" /I..\src\mpi\romio\adio\include \")
	mfile.WriteLine(" /I..\src\mpid\common\datatype \")
	mfile.WriteLine(" /I..\src\mpid\common\locks \")
	mfile.WriteLine(" /I..\src\mpid\common\sched \")
	mfile.WriteLine(" /I..\src\mpi\datatype \")
	mfile.WriteLine(" /I..\src\mpi\binding\f90 \")
	mfile.WriteLine(" /I..\src\pm\smpd \")
	mfile.WriteLine(" /I..\src\pm\smpd\sock\include \")
	mfile.WriteLine(" /I..\src\pm\smpd\sock\iocp\include \")
	mfile.WriteLine(" /I..\src\mpi\spawn \")
	mfile.WriteLine(" /I..\src\binding\f77")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CPU)"" == ""i386"" || ""$(CPU)"" == ""x86""")
	mfile.WriteLine("common_cflags = $(common_cflags) /I..\src\include\win32 /I..\src\binding\f90\win32 /I..\src\openpa\src\win32")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("common_cflags = $(common_cflags) /I..\src\include\win64 /I..\src\binding\f90\win64 /I..\src\openpa\src\win64")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("cxxflags = $(common_cflags) /DMPI_EXPORTS")
	mfile.WriteLine("cflags = $(cflags) $(common_cflags) /DMPI_EXPORTS /DMPICH_SKIP_MPICXX")
	mfile.WriteLine("fcflags = $(common_cflags) /DMPICH_SKIP_MPICXX \")
	mfile.WriteLine(" /DUSE_FORT_CDECL \")
	mfile.WriteLine(" /DUSE_MSC_DLLSPEC \")
	mfile.WriteLine(" /DFORTRAN_EXPORTS \")
	mfile.WriteLine(" /DF77_NAME_UPPER \")
	mfile.WriteLine(" /DHAVE_C_API")
	mfile.WriteLine("gfcflags = $(common_cflags) /DMPICH_SKIP_MPICXX \")
	mfile.WriteLine(" /DUSE_FORT_CDECL \")
	mfile.WriteLine(" /DUSE_MSC_DLLSPEC \")
	mfile.WriteLine(" /DFORTRAN_EXPORTS \")
	mfile.WriteLine(" /DFORTRANDOUBLEUNDERSCORE \")
	mfile.WriteLine(" /DF77_NAME_LOWER_2USCORE \")
	mfile.WriteLine(" /DHAVE_C_API")
	mfile.WriteLine("sfcflags = $(common_cflags) /DMPICH_SKIP_MPICXX \")
	mfile.WriteLine(" /DUSE_FORT_STDCALL \")
	mfile.WriteLine(" /DUSE_MSC_DLLSPEC \")
	mfile.WriteLine(" /DFORTRAN_EXPORTS \")
	mfile.WriteLine(" /DF77_NAME_UPPER \")
	mfile.WriteLine(" /DUSE_FORT_MIXED_STR_LEN \")
	mfile.WriteLine(" /DHAVE_C_API")
	mfile.WriteLine("!IF ""$(CPU)"" != ""x86""")
	mfile.WriteLine("fcflags = $(fcflags) /DHAVE_AINT_LARGER_THAN_FINT")
	mfile.WriteLine("gfcflags = $(gfcflags) /DHAVE_AINT_LARGER_THAN_FINT")
	mfile.WriteLine("sfcflags = $(sfcflags) /DHAVE_AINT_LARGER_THAN_FINT")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("fpcflags = \")
        mfile.WriteLine(" $(fcflags) \")
        mfile.WriteLine(" /DMPICH_MPI_FROM_PMPI \")
        mfile.WriteLine(" /DUSE_ONLY_MPI_NAMES")
	mfile.WriteLine("fortflags = /iface:cref /c /names:uppercase")
	mfile.WriteLine("gfortflags = /iface:cref /assume:underscore /c /names:lowercase")
	mfile.WriteLine("sfortflags = /iface:stdcall /c /names:uppercase")
	mfile.WriteLine("!IF ""$(CPU)"" == ""x86""")
        mfile.WriteLine("fortflags = $(fortflags) /I..\src\include\win32 ")
        mfile.WriteLine("!ELSE")
        mfile.WriteLine("fortflags = $(fortflags) /I..\src\include\win64 ")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("impl_cxxflags = $(cflags)")
	mfile.WriteLine("mpe_cflags = \")
	mfile.WriteLine(" /I ..\src\mpe2\include \")
	mfile.WriteLine(" /I ..\src\mpe2\src\logging\include \")
	mfile.WriteLine(" /I ..\src\mpe2\src\callstack \")
	mfile.WriteLine(" /I ..\src\mpe2\src\callstack\include")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CHANNEL)"" == ""ib""")
	mfile.WriteLine("!IFNDEF IB")
	mfile.WriteLine("IB = IBAL")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!IFNDEF IB_PATH")
	mfile.WriteLine("!IF ""$(CPU)"" != ""x86""")
	mfile.WriteLine("IB_PATH = c:\mellanox64")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("IB_PATH = c:\mellanox")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!IF ""$(IB)"" == ""IBAL""")
	mfile.WriteLine("cflags = $(cflags) /DUSE_IB_$(IB) /I$(IB_PATH)\shared\include /I$(IB_PATH)\shared\include\iba /I$(IB_PATH)\winuser\include")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("cflags = $(cflags) /DUSE_IB_$(IB) /I$(IB_PATH)\include")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CHANNEL)"" == ""mt""")
	mfile.WriteLine("cflags = $(cflags) \")
	mfile.WriteLine(" /DMPICH_MULTITHREADED \")
	mfile.WriteLine(" /I..\src\mpid\ch3\channels\sock\include \")
	mfile.WriteLine(" /I..\src\mpid\ch3\channels\sock\src")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CHANNEL)"" == ""nemesis""")
	mfile.WriteLine("cflags = $(cflags) \")
	mfile.WriteLine(" /DMPICH_MULTITHREADED /D ENABLE_NO_MACRO_VARARG_NAME \")
	mfile.WriteLine(" /I..\src\mpid\ch3\channels\nemesis\nemesis\include \")
	mfile.WriteLine(" /I..\src\mpid\ch3\channels\nemesis\nemesis\utils\monitor \")
	mfile.WriteLine(" /I..\src\mpid\ch3\channels\nemesis\nemesis\netmod\wintcp \")
	mfile.WriteLine(" /I..\src\mpid\ch3\channels\nemesis\nemesis\netmod\nd")
	mfile.WriteLine("!ENDIF")
'	mfile.WriteLine
'	mfile.WriteLine("!IF ""$(CHANNEL)"" == ""essm""")
'	mfile.WriteLine("cflags = $(cflags) /DMPICH_MULTITHREADED")
'	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("mpich2_libs = activeds.lib adsiid.lib netapi32.lib ntdsapi.lib secur32.lib mswsock.lib ws2_32.lib mpr.lib rpcrt4.lib crypt32.lib gdi32.lib kernel32.lib advapi32.lib comsupp.lib")
	mfile.WriteLine("!IF ""$(CPU)"" != ""x86""")
	mfile.WriteLine("# common_libs = bufferoverflowU.lib")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CHANNEL)"" == ""ib""")
	mfile.WriteLine("!IF ""$(IB)"" == ""IBAL""")
	mfile.WriteLine("!IF ""$(IB_PATH_LIB)"" == """"")
	mfile.WriteLine("mpich2_libs = $(mpich2_libs) ibal.lib complib.lib /LIBPATH:$(IB_PATH)\lib")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("!IF ""$(CPU)"" != ""x86""")
	mfile.WriteLine("mpich2_libs = $(mpich2_libs) ibal.lib complib.lib /LIBPATH:$(IB_PATH_LIB)\AMD64")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("mpich2_libs = $(mpich2_libs) ibal.lib complib.lib /LIBPATH:$(IB_PATH_LIB)\x86")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("!IF ""$(IB_PATH_LIB)"" == """"")
	mfile.WriteLine("mpich2_libs = $(mpich2_libs) vapi.lib vapi_common.lib /LIBPATH:$(IB_PATH)\lib\release")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("mpich2_libs = $(mpich2_libs) vapi.lib vapi_common.lib /LIBPATH:$(IB_PATH_LIB)")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(NODEBUG)"" == """"")
	mfile.WriteLine("CFG = Debug")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("CFG = Release")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CHANNEL)"" == ""ib""")
	mfile.WriteLine("OUTDIR = $(CPU)\$(CFG)\$(CHANNEL)_$(IB)$(P)")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("OUTDIR = $(CPU)\$(CFG)\$(CHANNEL)$(P)")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("BIN_OUTDIR = $(CPU)\$(CFG)\bin")
	mfile.WriteLine("SOCK_OUTDIR = $(CPU)\$(CFG)\sock$(P)")
	mfile.WriteLine("MT_OUTDIR = $(CPU)\$(CFG)\mt$(P)")
	mfile.WriteLine("NEMESIS_OUTDIR = $(CPU)\$(CFG)\nemesis$(P)")
'	mfile.WriteLine("SSHM_OUTDIR = $(CPU)\$(CFG)\sshm$(P)")
'	mfile.WriteLine("ESSM_OUTDIR = $(CPU)\$(CFG)\essm$(P)")
'	mfile.WriteLine("IB_OUTDIR = $(CPU)\$(CFG)\ib_$(IB)$(P)")
	mfile.WriteLine("FORTP_OUTDIR = $(CPU)\$(CFG)\fortranp")
	mfile.WriteLine("FORT_OUTDIR = $(CPU)\$(CFG)\fortran")
	mfile.WriteLine("GFORT_OUTDIR = $(CPU)\$(CFG)\gfortran")
	mfile.WriteLine("SFORT_OUTDIR = $(CPU)\$(CFG)\sfortran")
	mfile.WriteLine("CXX_OUTDIR = $(CPU)\$(CFG)\cxx")
	mfile.WriteLine("MPI_OUTDIR = $(CPU)\$(CFG)\mpi")
	mfile.WriteLine("RLOG_OUTDIR = $(CPU)\$(CFG)\rlog")
	mfile.WriteLine("MPE_OUTDIR = $(CPU)\$(CFG)\mpe")
	mfile.WriteLine("MPE_WRAP_OUTDIR = $(CPU)\$(CFG)\mpe_wrap")
	mfile.WriteLine("GCC_OUTDIR = $(CPU)\$(CFG)\gcc")
	mfile.WriteLine
	mfile.WriteLine("# The first rule gets built if nothing is specified on the nmake command line")
	mfile.WriteLine("all_redirect: all")
	mfile.WriteLine
	mfile.WriteLine("$(OUTDIR) :")
	mfile.WriteLine("    if not exist ""$(OUTDIR)\$(NULL)"" mkdir $(OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(BIN_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(BIN_OUTDIR)\$(NULL)"" mkdir $(BIN_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(FORTP_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(FORTP_OUTDIR)\$(NULL)"" mkdir $(FORTP_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(FORT_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(FORT_OUTDIR)\$(NULL)"" mkdir $(FORT_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(GFORT_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(GFORT_OUTDIR)\$(NULL)"" mkdir $(GFORT_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(SFORT_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(SFORT_OUTDIR)\$(NULL)"" mkdir $(SFORT_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(CXX_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(CXX_OUTDIR)\$(NULL)"" mkdir $(CXX_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(MPI_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(MPI_OUTDIR)\$(NULL)"" mkdir $(MPI_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(RLOG_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(RLOG_OUTDIR)\$(NULL)"" mkdir $(RLOG_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(MPE_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(MPE_OUTDIR)\$(NULL)"" mkdir $(MPE_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(MPE_WRAP_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(MPE_WRAP_OUTDIR)\$(NULL)"" mkdir $(MPE_WRAP_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("$(GCC_OUTDIR) :")
	mfile.WriteLine("	if not exist ""$(GCC_OUTDIR)\$(NULL)"" mkdir $(GCC_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("# clean destroys everything, even user generated files")
	mfile.WriteLine("CLEAN:")
	mfile.WriteLine("	if exist $(OUTDIR)\$(NULL) rd /s /q $(OUTDIR)")
	mfile.WriteLine("	if exist $(BIN_OUTDIR)\$(NULL) rd /s /q $(BIN_OUTDIR)")
	mfile.WriteLine("	if exist $(SOCK_OUTDIR)\$(NULL) rd /s /q $(SOCK_OUTDIR)")
	mfile.WriteLine("	if exist $(MT_OUTDIR)\$(NULL) rd /s /q $(MT_OUTDIR)")
	mfile.WriteLine("	if exist $(SSM_OUTDIR)\$(NULL) rd /s /q $(SSM_OUTDIR)")
	mfile.WriteLine("	if exist $(SHM_OUTDIR)\$(NULL) rd /s /q $(SHM_OUTDIR)")
	mfile.WriteLine("	if exist $(NEMESIS_OUTDIR)\$(NULL) rd /s /q $(NEMESIS_OUTDIR)")
'	mfile.WriteLine("	if exist $(SSHM_OUTDIR)\$(NULL) rd /s /q $(SSHM_OUTDIR)")
'	mfile.WriteLine("	if exist $(ESSM_OUTDIR)\$(NULL) rd /s /q $(ESSM_OUTDIR)")
'	mfile.WriteLine("	if exist $(IB_OUTDIR)IBAL\$(NULL) rd /s /q $(IB_OUTDIR)IBAL")
'	mfile.WriteLine("	if exist $(IB_OUTDIR)VAPI\$(NULL) rd /s /q $(IB_OUTDIR)VAPI")
	mfile.WriteLine("	if exist $(SOCK_OUTDIR)p\$(NULL) rd /s /q $(SOCK_OUTDIR)p")
	mfile.WriteLine("	if exist $(MT_OUTDIR)p\$(NULL) rd /s /q $(MT_OUTDIR)p")
	mfile.WriteLine("	if exist $(SSM_OUTDIR)p\$(NULL) rd /s /q $(SSM_OUTDIR)p")
	mfile.WriteLine("	if exist $(SHM_OUTDIR)p\$(NULL) rd /s /q $(SHM_OUTDIR)p")
	mfile.WriteLine("	if exist $(NEMESIS_OUTDIR)p\$(NULL) rd /s /q $(NEMESIS_OUTDIR)p")
'	mfile.WriteLine("	if exist $(SSHM_OUTDIR)p\$(NULL) rd /s /q $(SSHM_OUTDIR)p")
'	mfile.WriteLine("	if exist $(ESSM_OUTDIR)p\$(NULL) rd /s /q $(ESSM_OUTDIR)p")
'	mfile.WriteLine("	if exist $(IB_OUTDIR)IBALp\$(NULL) rd /s /q $(IB_OUTDIR)IBALp")
'	mfile.WriteLine("	if exist $(IB_OUTDIR)VAPIp\$(NULL) rd /s /q $(IB_OUTDIR)VAPIp")
	mfile.WriteLine("	if exist $(FORTP_OUTDIR)\$(NULL) rd /s /q $(FORTP_OUTDIR)")
	mfile.WriteLine("	if exist $(FORT_OUTDIR)\$(NULL) rd /s /q $(FORT_OUTDIR)")
	mfile.WriteLine("	if exist $(GFORT_OUTDIR)\$(NULL) rd /s /q $(GFORT_OUTDIR)")
	mfile.WriteLine("	if exist $(SFORT_OUTDIR)\$(NULL) rd /s /q $(SFORT_OUTDIR)")
	mfile.WriteLine("	if exist $(CXX_OUTDIR)\$(NULL) rd /s /q $(CXX_OUTDIR)")
	mfile.WriteLine("	if exist $(MPI_OUTDIR)\$(NULL) rd /s /q $(MPI_OUTDIR)")
	mfile.WriteLine("	if exist $(RLOG_OUTDIR)\$(NULL) rd /s /q $(RLOG_OUTDIR)")
	mfile.WriteLine("	if exist $(MPE_OUTDIR)\$(NULL) rd /s /q $(MPE_OUTDIR)")
	mfile.WriteLine("	if exist $(MPE_WRAP_OUTDIR)\$(NULL) rd /s /q $(MPE_WRAP_OUTDIR)")
	mfile.WriteLine("	if exist $(GCC_OUTDIR)\$(NULL) rd /s /q $(GCC_OUTDIR)")
	mfile.WriteLine

	trimlength = Len(f.GetFolder(".").Path) + 1

	mfile.WriteLine
	mfile.WriteLine("# MPICH2")
	mfile.WriteLine
	CreateRules f.GetFolder("src\mpi"), trimlength
	CreateRules f.GetFolder("src\binding\f90"), trimlength
	CreateRules f.GetFolder("src\mpid\common\datatype"), trimlength
	CreateRules f.GetFolder("src\util\mem"), trimlength
	CreateRules f.GetFolder("src\util\dbg"), trimlength
	CreateRules f.GetFolder("src\util\msgs"), trimlength
	CreateRules f.GetFolder("src\util\procmap"), trimlength
	CreateRules f.GetFolder("src\util\ex"), trimlength
	CreateRules f.GetFolder("src\pmi\smpd"), trimlength
	CreateRules f.GetFolder("src\pm\smpd"), trimlength
	' Create a special rule for smpd_adreg.cpp since it must be compiled for UNICODE
	mfile.WriteLine("$(" & outdir & ")\smpd_adreg.obj: ..\src\pm\smpd\smpd_adreg.cpp")
	mfile.WriteLine("    $(cc) $(cflags) /DUNICODE /D_UNICODE /Fo""$(" & outdir & ")\\"" /Fd""$(" & outdir & ")\\"" ..\src\pm\smpd\smpd_adreg.cpp")
	mfile.WriteLine
	CreateRules f.GetFolder("src\nameserv\pmi"), trimlength
	CreateRules f.GetFolder("src\mpid\ch3\src"), trimlength
	CreateRules f.GetFolder("src\mpid\common\locks"), trimlength
	CreateRules f.GetFolder("src\mpid\common\sock\iocp"), trimlength
	CreateRules f.GetFolder("src\mpid\common\sched"), trimlength
	CreateRules f.GetFolder("src\util\info"), trimlength
'	CreateRules f.GetFolder("src\util\timing"), trimlength
	CreateRules f.GetFolder("src\util\logging\common"), trimlength
	CreateRules f.GetFolder("src\util\param"), trimlength
        CreateRules f.GetFolder("src\util\thread"), trimlength
        CreateRules f.GetFolder("src\util\other"), trimlength
        ' Insert rules for mpl manually since mpl is not build with Makefile.sm files
        mfile.WriteLine("{..\src\mpl\src}.c{$(OUTDIR)}.obj:")
        mfile.WriteLine("    $(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" $**")
        mfile.WriteLine
	' Insert rules for romio manually since romio is not build with Makefile.sm files
	mfile.WriteLine("{..\src\mpi\romio\adio\ad_ntfs}.c{$(OUTDIR)}.obj:")
	mfile.WriteLine("    $(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("{..\src\mpi\romio\adio\common}.c{$(OUTDIR)}.obj:")
	mfile.WriteLine("    $(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("{..\src\mpi\romio\mpi-io}.c{$(OUTDIR)}.obj:")
	mfile.WriteLine("    $(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("{..\src\mpi\romio\mpi-io\glue\mpich2}.c{$(OUTDIR)}.obj:")
	mfile.WriteLine("    $(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("{..\src\mpi\romio\mpi2-other\array}.c{$(OUTDIR)}.obj:")
	mfile.WriteLine("    $(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("$(OUTDIR)\rlogtime.obj: ..\src\util\logging\rlog\rlogtime.c")
	mfile.WriteLine("	$(cc) $(cflags) /I..\src\util\logging\common /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" ..\src\util\logging\rlog\rlogtime.c")
	mfile.WriteLine
	CreateObjs "mpich2", f.GetFolder("src\mpi"), trimlength, true, false
	CreateObjs "mpich2", f.GetFolder("src\mpid\common\datatype"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\util\mem"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\util\dbg"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\util\msgs"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\util\procmap"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\util\ex"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\pmi\smpd"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\pm\smpd"), trimlength, false, false
	mfile.Write(" \" & vbCrLF & "	$(" & outdir & ")\smpd_adreg.obj")
	CreateObjs "mpich2", f.GetFolder("src\nameserv\pmi"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\mpid\ch3\src"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\mpid\common\locks"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\mpid\common\sock\iocp"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\mpid\common\sched"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\util\info"), trimlength, false, false
'	CreateObjs "mpich2", f.GetFolder("src\util\timing"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\util\logging\common"), trimlength, false, false
	CreateObjs "mpich2", f.GetFolder("src\util\param"), trimlength, false, false
        CreateObjs "mpich2", f.GetFolder("src\util\thread"), trimlength, false, false
        CreateObjs "mpich2", f.GetFolder("src\util\other"), trimlength, false, false
	mfile.WriteLine(" \" & vbCrLf & "	$(OUTDIR)\ad_ntfs.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_close.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_done.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_fcntl.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_flush.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_iread.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_iwrite.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_open.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_read.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_resize.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_wait.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_ntfs_write.obj \")
	mfile.WriteLine("	$(OUTDIR)\greq_fns.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_darray.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_subarray.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_aggregate.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_close.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_delete.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_end.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_fstype.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_get_sh_fp.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_hints.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_init.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_iopen.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_iread_fake.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_iwrite_fake.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_open.obj \")
	mfile.WriteLine("	$(OUTDIR)\system_hints.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_prealloc.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_features.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_opencoll.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_read_coll.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_read_str.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_read_str_naive.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_seek.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_set_sh_fp.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_set_view.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_write_coll.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_write_str.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_write_str_naive.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_io_coll.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_opencoll.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_coll_build_req_new.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_coll_exch_new.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_aggregate_new.obj \")
	mfile.WriteLine("	$(OUTDIR)\ad_features.obj \")
	mfile.WriteLine("	$(OUTDIR)\heap-sort.obj \")
'	mfile.WriteLine("	$(OUTDIR)\async_list.obj \")
	mfile.WriteLine("	$(OUTDIR)\byte_offset.obj \")
	mfile.WriteLine("	$(OUTDIR)\cb_config_list.obj \")
	mfile.WriteLine("	$(OUTDIR)\eof_offset.obj \")
	mfile.WriteLine("	$(OUTDIR)\error.obj \")
	mfile.WriteLine("	$(OUTDIR)\flatten.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_fp_posn.obj \")
	mfile.WriteLine("	$(OUTDIR)\iscontig.obj \")
	mfile.WriteLine("	$(OUTDIR)\lock.obj \")
	mfile.WriteLine("	$(OUTDIR)\malloc.obj \")
'	mfile.WriteLine("	$(OUTDIR)\req_malloc.obj \")
	mfile.WriteLine("	$(OUTDIR)\shfp_fname.obj \")
	mfile.WriteLine("	$(OUTDIR)\status_setb.obj \")
	mfile.WriteLine("	$(OUTDIR)\close.obj \")
	mfile.WriteLine("	$(OUTDIR)\delete.obj \")
	mfile.WriteLine("	$(OUTDIR)\mpir-mpioinit.obj \")
	mfile.WriteLine("	$(OUTDIR)\file_c2f.obj \")
	mfile.WriteLine("	$(OUTDIR)\file_f2c.obj \")
	mfile.WriteLine("	$(OUTDIR)\fsync.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_amode.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_atom.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_bytoff.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_extent.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_group.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_info.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_posn.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_posn_sh.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_size.obj \")
	mfile.WriteLine("	$(OUTDIR)\get_view.obj \")
	mfile.WriteLine("	$(OUTDIR)\mpio_err.obj \")
	mfile.WriteLine("	$(OUTDIR)\mpio_file.obj \")
	mfile.WriteLine("	$(OUTDIR)\ioreq_c2f.obj \")
	mfile.WriteLine("	$(OUTDIR)\ioreq_f2c.obj \")
	mfile.WriteLine("	$(OUTDIR)\iotest.obj \")
	mfile.WriteLine("	$(OUTDIR)\iowait.obj \")
	mfile.WriteLine("	$(OUTDIR)\iread.obj \")
	mfile.WriteLine("	$(OUTDIR)\iread_at.obj \")
	mfile.WriteLine("	$(OUTDIR)\iread_sh.obj \")
	mfile.WriteLine("	$(OUTDIR)\iwrite.obj \")
	mfile.WriteLine("	$(OUTDIR)\iwrite_at.obj \")
	mfile.WriteLine("	$(OUTDIR)\iwrite_sh.obj \")
	mfile.WriteLine("	$(OUTDIR)\mpich2_fileutil.obj \")
	mfile.WriteLine("	$(OUTDIR)\mpiu_greq.obj \")
	mfile.WriteLine("	$(OUTDIR)\open.obj \")
	mfile.WriteLine("	$(OUTDIR)\prealloc.obj \")
	mfile.WriteLine("	$(OUTDIR)\rd_atallb.obj \")
	mfile.WriteLine("	$(OUTDIR)\rd_atalle.obj \")
	mfile.WriteLine("	$(OUTDIR)\read.obj \")
	mfile.WriteLine("	$(OUTDIR)\read_all.obj \")
	mfile.WriteLine("	$(OUTDIR)\read_allb.obj \")
	mfile.WriteLine("	$(OUTDIR)\read_alle.obj \")
	mfile.WriteLine("	$(OUTDIR)\read_at.obj \")
	mfile.WriteLine("	$(OUTDIR)\read_atall.obj \")
	mfile.WriteLine("	$(OUTDIR)\read_ord.obj \")
	mfile.WriteLine("	$(OUTDIR)\read_ordb.obj \")
	mfile.WriteLine("	$(OUTDIR)\read_orde.obj \")
	mfile.WriteLine("	$(OUTDIR)\read_sh.obj \")
	mfile.WriteLine("	$(OUTDIR)\seek.obj \")
	mfile.WriteLine("	$(OUTDIR)\seek_sh.obj \")
	mfile.WriteLine("	$(OUTDIR)\set_atom.obj \")
	mfile.WriteLine("	$(OUTDIR)\set_info.obj \")
	mfile.WriteLine("	$(OUTDIR)\set_size.obj \")
	mfile.WriteLine("	$(OUTDIR)\set_view.obj \")
	mfile.WriteLine("	$(OUTDIR)\wr_atallb.obj \")
	mfile.WriteLine("	$(OUTDIR)\wr_atalle.obj \")
	mfile.WriteLine("	$(OUTDIR)\strfns.obj \")
	mfile.WriteLine("	$(OUTDIR)\write.obj \")
	mfile.WriteLine("	$(OUTDIR)\write_all.obj \")
	mfile.WriteLine("	$(OUTDIR)\write_allb.obj \")
	mfile.WriteLine("	$(OUTDIR)\write_alle.obj \")
	mfile.WriteLine("	$(OUTDIR)\write_at.obj \")
	mfile.WriteLine("	$(OUTDIR)\write_atall.obj \")
	mfile.WriteLine("	$(OUTDIR)\write_ord.obj \")
	mfile.WriteLine("	$(OUTDIR)\write_ordb.obj \")
	mfile.WriteLine("	$(OUTDIR)\write_orde.obj \")
	mfile.WriteLine("	$(OUTDIR)\write_sh.obj \")
        ' Insert objs for mpl manually
        mfile.WriteLine("   $(OUTDIR)\mplstr.obj \")
        mfile.WriteLine("   $(OUTDIR)\mplenv.obj \")
        mfile.WriteLine("   $(OUTDIR)\mpltrmem.obj \")
	' Insert objs for f90 type create funcs manually because the src/binding/f90
        ' directory has both C & fortran interfaces
        mfile.WriteLine("   $(OUTDIR)\create_f90_util.obj \")
        mfile.WriteLine("   $(OUTDIR)\create_f90_int.obj \")
        mfile.WriteLine("   $(OUTDIR)\create_f90_real.obj \")
        mfile.WriteLine("   $(OUTDIR)\create_f90_complex.obj")
	mfile.WriteLine
	mfile.WriteLine("!IFDEF RLOG")
	mfile.WriteLine("mpich2_objs = $(mpich2_objs) $(OUTDIR)\rlogtime.obj")
	mfile.WriteLine("!ENDIF")

	mfile.WriteLine
	mfile.WriteLine("# ch3sock")
	mfile.WriteLine
	outdir = "SOCK_OUTDIR"
	CreateRules f.GetFolder("src\mpid\ch3\channels\sock"), trimlength
	'CreateRules f.GetFolder("src\mpid\common\sock\iocp"), trimlength
	CreateRules f.GetFolder("src\mpid\ch3\util\sock"), trimlength
	CreateObjs "ch3sock", f.GetFolder("src\mpid\ch3\channels\sock"), trimlength, true, false
	CreateObjs "ch3sock", f.GetFolder("src\mpid\ch3\util\sock"), trimlength, false, true
	'CreateObjs "ch3sock", f.GetFolder("src\mpid\common\sock\iocp"), trimlength, false, true

	mfile.WriteLine
	mfile.WriteLine("# ch3mt")
	mfile.WriteLine
	outdir = "MT_OUTDIR"
	CreateRules f.GetFolder("src\mpid\ch3\channels\sock"), trimlength
	CreateRules f.GetFolder("src\mpid\ch3\util\sock"), trimlength
	'CreateRules f.GetFolder("src\util\events"), trimlength
	CreateObjs "ch3mt", f.GetFolder("src\mpid\ch3\channels\sock"), trimlength, true, false
	CreateObjs "ch3mt", f.GetFolder("src\mpid\ch3\util\sock"), trimlength, false, true
	'CreateObjs "ch3mt", f.GetFolder("src\util\events"), trimlength, false, false

	mfile.WriteLine
	mfile.WriteLine("# ch3nemesis")
	mfile.WriteLine
	outdir = "NEMESIS_OUTDIR"
	CreateRules f.GetFolder("src\mpid\ch3\channels\nemesis\src"), trimlength
	CreateRules f.GetFolder("src\mpid\ch3\channels\nemesis\nemesis\src"), trimlength
'	CreateRules f.GetFolder("src\mpid\ch3\channels\nemesis\nemesis\utils"), trimlength
	CreateRules f.GetFolder("src\mpid\ch3\channels\nemesis\nemesis\netmod\wintcp"), trimlength
	CreateRules f.GetFolder("src\mpid\ch3\channels\nemesis\nemesis\netmod\nd"), trimlength
	CreateRules f.GetFolder("src\mpid\ch3\channels\nemesis\nemesis\netmod\none"), trimlength
	CreateObjs "ch3nemesis", f.GetFolder("src\mpid\ch3\channels\nemesis\src"), trimlength, true, false
	CreateObjs "ch3nemesis", f.GetFolder("src\mpid\ch3\channels\nemesis\nemesis\src"), trimlength, false, false
'	CreateObjs "ch3nemesis", f.GetFolder("src\mpid\ch3\channels\nemesis\nemesis\utils"), trimlength, false, false
	CreateObjs "ch3nemesis", f.GetFolder("src\mpid\ch3\channels\nemesis\nemesis\netmod\wintcp"), trimlength, false, false
	CreateObjs "ch3nemesis", f.GetFolder("src\mpid\ch3\channels\nemesis\nemesis\netmod\nd"), trimlength, false, false
	CreateObjs "ch3nemesis", f.GetFolder("src\mpid\ch3\channels\nemesis\nemesis\netmod\none"), trimlength, false, true


	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CHANNEL)"" == ""sock""")
	mfile.WriteLine
	mfile.WriteLine("ch3sock: $(SOCK_OUTDIR)\mpich2$(P)$(D).dll")
	mfile.WriteLine
	mfile.WriteLine("$(SOCK_OUTDIR)\mpich2$(P)$(D).dll: $(ch3sock_objs) $(mpich2_objs) $(PLIB_DEP)")
	mfile.WriteLine("	$(link) $(dlllflags) $(ch3sock_objs) $(mpich2_objs) $(mpich2_libs) $(rlog_libs) $(common_libs) -out:$(SOCK_OUTDIR)\mpich2$(P)$(D).dll /DEF:..\mpich2.def")
	mfile.WriteLine("	if exist $(SOCK_OUTDIR)\mpich2$(P)$(D).dll.manifest mt.exe -manifest $(SOCK_OUTDIR)\mpich2$(P)$(D).dll.manifest -outputresource:$(SOCK_OUTDIR)\mpich2$(P)$(D).dll;2")
	mfile.WriteLine
	mfile.WriteLine("!ELSE")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CHANNEL)"" == ""mt""")
	mfile.WriteLine("channel_objs = $(ch3mt_objs)")
	mfile.WriteLine("!ELSEIF ""$(CHANNEL)"" == ""nemesis""")
	mfile.WriteLine("channel_objs = $(ch3nemesis_objs)")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("!ERROR Invalid channel selected - $(CHANNEL)")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine
	mfile.WriteLine("ch3$(CHANNEL): $(OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	mfile.WriteLine
	mfile.WriteLine("$(OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll: $(channel_objs) $(mpich2_objs) $(PLIB_DEP)")
	mfile.WriteLine("	$(link) $(dlllflags) $(channel_objs) $(mpich2_objs) $(mpich2_libs) $(rlog_libs) $(common_libs) -out:$(OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll /DEF:..\mpich2.def")
	mfile.WriteLine("	if exist $(OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll.manifest mt.exe -manifest $(OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll.manifest -outputresource:$(OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll;2")
	mfile.WriteLine
	mfile.WriteLine("!ENDIF")

	'mfile.WriteLine
	'mfile.WriteLine("!IF ""$(CHANNEL)"" == ""sock""")
	'mfile.WriteLine("ch3sock: $(SOCK_OUTDIR)\mpich2$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("$(SOCK_OUTDIR)\mpich2$(P)$(D).dll: $(ch3sock_objs) $(mpich2_objs)")
	'mfile.WriteLine("	$(link) $(dlllflags) $(ch3sock_objs) $(mpich2_objs) $(rlog_libs) $(common_libs) -out:$(SOCK_OUTDIR)\mpich2$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("!ELSEIF ""$(CHANNEL)"" == ""ssm""")
	'mfile.WriteLine("ch3ssm: $(SSM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("$(SSM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll: $(ch3ssm_objs) $(mpich2_objs)")
	'mfile.WriteLine("	$(link) $(dlllflags) $(ch3ssm_objs) $(mpich2_objs) $(rlog_libs) $(common_libs) -out:$(SSM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("!ELSEIF ""$(CHANNEL)"" == ""shm""")
	'mfile.WriteLine("ch3shm: $(SHM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("$(SHM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll: $(ch3shm_objs) $(mpich2_objs)")
	'mfile.WriteLine("	$(link) $(dlllflags) $(ch3shm_objs) $(mpich2_objs) $(rlog_libs) $(common_libs) -out:$(SHM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("!ELSEIF ""$(CHANNEL)"" == ""sshm""")
	'mfile.WriteLine("ch3sshm: $(SSHM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("$(SSHM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll: $(ch3sshm_objs) $(mpich2_objs)")
	'mfile.WriteLine("	$(link) $(dlllflags) $(ch3sshm_objs) $(mpich2_objs) $(rlog_libs) $(common_libs) -out:$(SSHM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("!ELSEIF ""$(CHANNEL)"" == ""essm""")
	'mfile.WriteLine("ch3essm: $(ESSM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("$(ESSM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll: $(ch3essm_objs) $(mpich2_objs)")
	'mfile.WriteLine("	$(link) $(dlllflags) $(ch3essm_objs) $(mpich2_objs) $(rlog_libs) $(common_libs) -out:$(ESSM_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("!ELSEIF ""$(CHANNEL)"" == ""ib""")
	'mfile.WriteLine("ch3ib: $(IB_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("$(IB_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll: $(ch3ib_objs) $(mpich2_objs)")
	'mfile.WriteLine("	$(link) $(dlllflags) $(ch3ib_objs) $(mpich2_objs) $(rlog_libs) $(common_libs) -out:$(IB_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("!ELSEIF ""$(CHANNEL)"" == ""mt""")
	'mfile.WriteLine("ch3mt: $(MT_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("$(MT_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll: $(ch3mt_objs) $(mpich2_objs)")
	'mfile.WriteLine("	$(link) $(dlllflags) $(ch3mt_objs) $(mpich2_objs) $(rlog_libs) $(common_libs) -out:$(MT_OUTDIR)\mpich2$(CHANNEL)$(P)$(D).dll")
	'mfile.WriteLine
	'mfile.WriteLine("!ELSE")
	'mfile.WriteLine("!ERROR No channel selected")
	'mfile.WriteLine("!ENDIF")

	mfile.WriteLine
	mfile.WriteLine("# Fortran")
	mfile.WriteLine
	outdir = "FORT_OUTDIR"
        'extra_flags = "$(fcflags)"
        SetCompileFlags("$(fcflags)")
	fort_prefix = ""
	CreateRules f.GetFolder("src\binding\f77"), trimlength
	CreateRules f.GetFolder("src\binding\f90"), trimlength
        ResetCompileFlags()
	mfile.WriteLine
	CreateObjs "fort", f.GetFolder("src\binding\f77"), trimlength, true, false
	mfile.WriteLine(" \" & vbCrLf & "   $(FORT_OUTDIR)\typef90intf.obj \")
        mfile.WriteLine("   $(FORT_OUTDIR)\typef90realf.obj \")
        mfile.WriteLine("   $(FORT_OUTDIR)\typef90cmplxf.obj")
        mfile.WriteLine

	mfile.WriteLine("$(FORT_OUTDIR)\fmpich2$(D).dll: $(fort_objs)")
	mfile.WriteLine("	$(link) $(dlllflags) $(fort_objs) $(FORTP_OUTDIR)\fmpich2p$(D).lib $(MPI_OUTDIR)\mpi$(D).lib $(common_libs) /DEF:..\src\binding\f77\mpich2f.def -out:$(FORT_OUTDIR)\fmpich2$(D).dll")
	mfile.WriteLine("	if exist $(FORT_OUTDIR)\fmpich2$(D).dll.manifest mt.exe -manifest $(FORT_OUTDIR)\fmpich2$(D).dll.manifest -outputresource:$(FORT_OUTDIR)\fmpich2$(D).dll;2")
	mfile.WriteLine
	mfile.WriteLine("fort: fortp $(FORT_OUTDIR) $(FORT_OUTDIR)\fmpich2$(D).dll")
	mfile.WriteLine
	outdir = "FORTP_OUTDIR"
        'extra_flags = "$(fpcflags)"
        SetCompileFlags("$(fpcflags)")
	fort_prefix = ""
	CreateRules f.GetFolder("src\binding\f77"), trimlength
	CreateRules f.GetFolder("src\binding\f90"), trimlength
        ResetCompileFlags()
        mfile.WriteLine
        CreateObjs "fortp", f.GetFolder("src\binding\f77"), trimlength, true, false
	mfile.WriteLine(" \" & vbCrLf & "   $(FORTP_OUTDIR)\typef90intf.obj \")
        mfile.WriteLine("   $(FORTP_OUTDIR)\typef90realf.obj \")
        mfile.WriteLine("   $(FORTP_OUTDIR)\typef90cmplxf.obj")
        mfile.WriteLine

	mfile.WriteLine("$(FORTP_OUTDIR)\fmpich2p$(D).lib: $(fortp_objs)")
	mfile.WriteLine("	$(implib) $(liblflags) $(fortp_objs) $(MPI_OUTDIR)\mpi$(D).lib $(common_libs) -out:$(FORTP_OUTDIR)\fmpich2p$(D).lib")
	mfile.WriteLine
	mfile.WriteLine("fortp: $(FORTP_OUTDIR) $(FORTP_OUTDIR)\fmpich2p$(D).lib")

	mfile.WriteLine
        ' Adding rules for F90 mod files
        mfile.WriteLine("{..\src\binding\f90}.f90{$(FORT_OUTDIR)}.mod:")
	mfile.WriteLine("!IF ""$(CPU)"" == ""x86""")
        mfile.WriteLine("   copy /y ..\src\binding\f90\win32\mpi_sizeofs.f90 ..\src\binding\f90")
	mfile.WriteLine("!ELSE")
        mfile.WriteLine("   copy /y ..\src\binding\f90\win64\mpi_sizeofs.f90 ..\src\binding\f90")
	mfile.WriteLine("!ENDIF")
        mfile.WriteLine("   $(fc) $(fortflags) /module:""$(FORT_OUTDIR)\\"" /object:""$(FORT_OUTDIR)\\"" $**")
        mfile.WriteLine
        mfile.WriteLine("mpi_mod_objs = \")
        mfile.WriteLine("   $(FORT_OUTDIR)\mpi_constants.mod \")
        mfile.WriteLine("   $(FORT_OUTDIR)\mpi_base.mod \")
        mfile.WriteLine("   $(FORT_OUTDIR)\mpi_sizeofs.mod \")
        mfile.WriteLine("   $(FORT_OUTDIR)\mpi.mod ")
        mfile.WriteLine
        mfile.WriteLine("mpi_mod: $(FORT_OUTDIR) $(mpi_mod_objs)")
        mfile.WriteLine
	outdir = "GFORT_OUTDIR"
        'extra_flags = "$(gfcflags)"
        SetCompileFlags("$(gfcflags)")
	fort_prefix = "g"
	CreateRules f.GetFolder("src\binding\f77"), trimlength
        ResetCompileFlags()
	CreateObjs "gfort", f.GetFolder("src\binding\f77"), trimlength, true, true
	mfile.WriteLine("$(GFORT_OUTDIR)\fmpich2g$(D).dll: $(gfort_objs)")
	mfile.WriteLine("	$(link) $(dlllflags) $(gfort_objs) $(MPI_OUTDIR)\mpi$(D).lib $(common_libs) /DEF:..\src\binding\f77\mpich2fg.def -out:$(GFORT_OUTDIR)\fmpich2g$(D).dll")
	mfile.WriteLine("	if exist $(GFORT_OUTDIR)\fmpich2g$(D).dll.manifest mt.exe -manifest $(GFORT_OUTDIR)\fmpich2g$(D).dll.manifest -outputresource:$(GFORT_OUTDIR)\fmpich2g$(D).dll;2")
	mfile.WriteLine
	mfile.WriteLine("gfort: $(GFORT_OUTDIR) $(GFORT_OUTDIR)\fmpich2g$(D).dll")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CPU)"" != ""x86""")
	mfile.WriteLine("# We don't build sfort for non-x86 platforms")
	mfile.WriteLine("sfort: $(SFORT_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("!ELSE")
	outdir = "SFORT_OUTDIR"
        SetCompileFlags("$(sfcflags)")
        'extra_flags = "$(sfcflags)"
	fort_prefix = "s"
	CreateRules f.GetFolder("src\binding\f77"), trimlength
        ResetCompileFlags()
	CreateObjs "sfort", f.GetFolder("src\binding\f77"), trimlength, true, false
	' Add the extra character* versions of the MPI functions here
	mfile.WriteLine(" \" & vbCrLf & "	$(SFORT_OUTDIR)\accumulatefs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\allgatherfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\allgathervfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\allreducefs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\alltoallfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\alltoallvfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\alltoallwfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\bcastfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\bsendfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\bsend_initfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\bufattachfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\bufdetachfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\exscanfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\gatherfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\gathervfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\getfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\ibsendfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\irecvfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\irsendfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\isendfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\issendfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\putfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\recvfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\recv_initfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\redscatfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\reducefs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\rsendfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\rsend_initfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\scanfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\scatterfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\scattervfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\sendfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\sendrecvfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\send_initfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\sndrcvrplfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\ssendfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\ssend_initfs.obj \")
	mfile.WriteLine("	$(SFORT_OUTDIR)\win_createfs.obj")
	mfile.WriteLine
	mfile.WriteLine("$(SFORT_OUTDIR)\fmpich2s$(D).dll: $(sfort_objs)")
	mfile.WriteLine("	$(link) $(dlllflags) $(sfort_objs) $(MPI_OUTDIR)\mpi$(D).lib $(common_libs) /DEF:..\src\binding\f77\mpich2fs.def -out:$(SFORT_OUTDIR)\fmpich2s$(D).dll")
	mfile.WriteLine("	if exist $(SFORT_OUTDIR)\fmpich2s$(D).dll.manifest mt.exe -manifest $(SFORT_OUTDIR)\fmpich2s$(D).dll.manifest -outputresource:$(SFORT_OUTDIR)\fmpich2s$(D).dll;2")
	mfile.WriteLine
	mfile.WriteLine("sfort: $(SFORT_OUTDIR) $(SFORT_OUTDIR)\fmpich2s$(D).dll")
	mfile.WriteLine
	mfile.WriteLine("!ENDIF")
	extra_flags = ""
	fort_prefix = ""

	mfile.WriteLine
	mfile.WriteLine("# MPI multi-channel wrapper")
	mfile.WriteLine
	outdir = "MPI_OUTDIR"
	CreateRules f.GetFolder("src\util\multichannel"), trimlength
	CreateObjs "mpi", f.GetFolder("src\util\multichannel"), trimlength, true, true
	mfile.WriteLine("$(MPI_OUTDIR)\mpich2mpi$(D).dll: $(mpi_objs)")
	mfile.WriteLine("	$(link) $(dlllflags) $(mpi_objs) $(common_libs) /DEF:..\mpi.def -out:$(MPI_OUTDIR)\mpich2mpi$(D).dll /IMPLIB:$(MPI_OUTDIR)\mpi$(D).lib")
	mfile.WriteLine("	if exist $(MPI_OUTDIR)\mpich2mpi$(D).dll.manifest mt.exe -manifest $(MPI_OUTDIR)\mpich2mpi$(D).dll.manifest -outputresource:$(MPI_OUTDIR)\mpich2mpi$(D).dll;2")
	mfile.WriteLine
	mfile.WriteLine("mpi: $(MPI_OUTDIR) $(MPI_OUTDIR)\mpich2mpi$(D).dll")

	mfile.WriteLine
	mfile.WriteLine("# C++")
	mfile.WriteLine
	outdir = "CXX_OUTDIR"
	cxxflags = "cxxflags"
	CreateRules f.GetFolder("src\binding\cxx"), trimlength
	CreateObjs "cxx", f.GetFolder("src\binding\cxx"), trimlength, true, true
	mfile.WriteLine("$(CXX_OUTDIR)\cxx$(D).lib: $(cxx_objs)")
	mfile.WriteLine("	$(implib) $(liblflags) $(cxx_objs) -out:$(CXX_OUTDIR)\cxx$(D).lib")
	mfile.WriteLine
	mfile.WriteLine("cxx: $(CXX_OUTDIR) $(CXX_OUTDIR)\cxx$(D).lib")

	mfile.WriteLine
	mfile.WriteLine("# MPE")
	mfile.WriteLine
	mfile.WriteLine("{..\src\mpe2\src\logging\src}.c{$(MPE_OUTDIR)}.obj:")
	mfile.WriteLine("    $(cc) $(cflags) $(mpe_cflags) /DMPE_EXPORTS /Fo""$(MPE_OUTDIR)\\"" /Fd""$(MPE_OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("{..\src\mpe2\src\callstack\src}.c{$(MPE_OUTDIR)}.obj:")
	mfile.WriteLine("    $(cc) $(cflags) $(mpe_cflags) /DMPE_EXPORTS /Fo""$(MPE_OUTDIR)\\"" /Fd""$(MPE_OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("$(MPE_OUTDIR)\mpiu_thread.obj: ..\src\util\thread\mpiu_thread.c")
	mfile.WriteLine("    $(cc) $(cflags) $(mpe_cflags) /DMPE_EXPORTS /Fo""$(MPE_OUTDIR)\\"" /Fd""$(MPE_OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("mpe_objs = \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_block.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_buffer.obj \")
	mfile.WriteLine("   $(MPE_OUTDIR)\clog_commset.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_merger.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_preamble.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_print.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_record.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_sync.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_timer.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_util.obj \")
	mfile.WriteLine("   $(MPE_OUTDIR)\clog_uuid.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_cache.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\clog_joiner.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\mpe_logf.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\mpiu_thread.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\fancyprint.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\iterator.obj \")
	mfile.WriteLine("	$(MPE_OUTDIR)\mpe_log.obj")
	mfile.WriteLine
	mfile.WriteLine("{..\src\mpe2\src\callstack\src}.c{$(MPE_OUTDIR)}.obj:")
	mfile.WriteLine("    $(cc) $(cflags) $(mpe_cflags) /DMPE_EXPORTS /Fo""$(MPE_OUTDIR)\\"" /Fd""$(MPE_OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("$(MPE_OUTDIR)\mpe$(D).dll: $(mpe_objs)")
	mfile.WriteLine("	$(link) $(dlllflags) $(mpe_objs) $(MPI_OUTDIR)\mpi$(D).lib $(common_libs) /DEF:..\src\mpe2\mpe.def -out:$(MPE_OUTDIR)\mpe$(D).dll /IMPLIB:$(MPE_OUTDIR)\mpe$(D).lib")
	mfile.WriteLine("	if exist $(MPE_OUTDIR)\mpe$(D).dll.manifest mt.exe -manifest $(MPE_OUTDIR)\mpe$(D).dll.manifest -outputresource:$(MPE_OUTDIR)\mpe$(D).dll;2")
	mfile.WriteLine
	mfile.WriteLine("mpe: $(MPE_OUTDIR) $(MPE_OUTDIR)\mpe$(D).dll ")

	mfile.WriteLine
	mfile.WriteLine("# MPE wrapper")
	mfile.WriteLine
	mfile.WriteLine("{..\src\mpe2\src\wrappers\src}.c{$(MPE_WRAP_OUTDIR)}.obj:")
	mfile.WriteLine("    $(cc) $(cflags) /DUSE_STDARG  /I..\src\mpe2\include /I..\src\mpe2\src\logging\include /I..\src\mpe2\src\wrappers\include /Fo""$(MPE_WRAP_OUTDIR)\\"" /Fd""$(MPE_WRAP_OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("mpe_wrap_objs = \")
	mfile.WriteLine("	$(MPE_WRAP_OUTDIR)\log_mpi_util.obj \")
	mfile.WriteLine("	$(MPE_WRAP_OUTDIR)\log_mpi_core.obj")
	mfile.WriteLine
	mfile.WriteLine("$(MPE_WRAP_OUTDIR)\mpich2mpe$(D).dll: $(mpe_wrap_objs)")
	mfile.WriteLine("	$(link) $(dlllflags) $(mpe_wrap_objs) $(MPI_OUTDIR)\mpi$(D).lib $(MPE_OUTDIR)\mpe$(D).lib $(common_libs) /DEF:..\src\mpe2\src\wrappers\mpewrap.def -out:$(MPE_WRAP_OUTDIR)\mpich2mpe$(D).dll /IMPLIB:$(MPE_WRAP_OUTDIR)\mpich2mpe$(D).lib")
	mfile.WriteLine("	if exist $(MPE_WRAP_OUTDIR)\mpich2mpe$(D).dll.manifest mt.exe -manifest $(MPE_WRAP_OUTDIR)\mpich2mpe$(D).dll.manifest -outputresource:$(MPE_WRAP_OUTDIR)\mpich2mpe$(D).dll;2")
	mfile.WriteLine
	mfile.WriteLine("mpe_wrap: $(MPE_WRAP_OUTDIR) $(MPE_WRAP_OUTDIR)\mpich2mpe$(D).dll")

	mfile.WriteLine
	mfile.WriteLine("# RLOG")
	mfile.WriteLine
	mfile.WriteLine("{..\src\util\logging\rlog}.c{$(RLOG_OUTDIR)}.obj:")
	mfile.WriteLine("    $(cc) $(cflags) /Fo""$(RLOG_OUTDIR)\\"" /Fd""$(RLOG_OUTDIR)\\"" $**")
	mfile.WriteLine
	mfile.WriteLine("rlog_objs = \")
	mfile.WriteLine("	$(RLOG_OUTDIR)\rlog.obj \")
	mfile.WriteLine("	$(RLOG_OUTDIR)\rlogutil.obj \")
	mfile.WriteLine("	$(RLOG_OUTDIR)\irlogutil.obj")
	mfile.WriteLine
	mfile.WriteLine("$(RLOG_OUTDIR)\rlog$(D).lib: $(rlog_objs)")
	mfile.WriteLine("	$(implib) $(liblflags) $(rlog_objs) -out:$(RLOG_OUTDIR)\rlog$(D).lib")
	mfile.WriteLine
	mfile.WriteLine("rlog: $(RLOG_OUTDIR) $(RLOG_OUTDIR)\rlog$(D).lib")
	mfile.WriteLine
	mfile.WriteLine("irlog_objs = \")
	mfile.WriteLine("	$(RLOG_OUTDIR)\irlog2rlog.obj")
	mfile.WriteLine
	mfile.WriteLine("$(RLOG_OUTDIR)\irlog2rlog.exe: $(irlog_objs) $(rlog_objs) $(mpich2_objs)")
	mfile.WriteLine("	$(link) $(conlflags) $(irlog_objs) $(rlog_objs) $(mpich2_objs) $(ch3sock_objs) $(common_libs) -out:""$(RLOG_OUTDIR)\irlog2rlog.exe"" $(mpich2_libs)")
	mfile.WriteLine("	if exist $(RLOG_OUTDIR)\irlog2rlog.exe.manifest mt.exe -manifest $(RLOG_OUTDIR)\irlog2rlog.exe.manifest -outputresource:$(RLOG_OUTDIR)\irlog2rlog.exe;1")
	mfile.WriteLine
	mfile.WriteLine("# create special rules for the TraceInput.dll source files since they need to include Java paths")
	mfile.WriteLine("$(RLOG_OUTDIR)\logformat_trace_InputLog.obj: ..\src\util\logging\rlog\TraceInput\logformat_trace_InputLog.c")
	mfile.WriteLine("    $(cc) $(cflags) /I..\src\mpe2\src\slog2sdk\src\logformat\trace /I..\src\util\logging\rlog -DHAVE_STRNICMP /I""$(JAVA_HOME)""\include /I""$(JAVA_HOME)""\include\win32 /Fo""$(RLOG_OUTDIR)\\"" /Fd""$(RLOG_OUTDIR)\\"" ..\src\util\logging\rlog\TraceInput\logformat_trace_InputLog.c")
	mfile.WriteLine
	mfile.WriteLine("$(RLOG_OUTDIR)\trace_input.obj: ..\src\util\logging\rlog\TraceInput\trace_input.c")
	mfile.WriteLine("    $(cc) $(cflags) /DHAVE_STRNICMP /I..\src\mpe2\src\slog2sdk\src\logformat\trace /I..\src\util\logging\rlog /I""$(JAVA_HOME)""\include /I""$(JAVA_HOME)""\include\win32 /Fo""$(RLOG_OUTDIR)\\"" /Fd""$(RLOG_OUTDIR)\\"" ..\src\util\logging\rlog\TraceInput\trace_input.c")
	mfile.WriteLine
	mfile.WriteLine("trace_input_objs = \")
	mfile.WriteLine("	$(RLOG_OUTDIR)\logformat_trace_InputLog.obj \")
	mfile.WriteLine("	$(RLOG_OUTDIR)\trace_input.obj")
	mfile.WriteLine
	mfile.WriteLine("$(RLOG_OUTDIR)\TraceInput.dll: $(trace_input_objs) $(rlog_objs) $(mpich2_objs)")
	mfile.WriteLine("	$(link) $(dlllflags) $(trace_input_objs) $(rlog_objs) $(mpich2_objs) $(ch3sock_objs) $(common_libs) -out:$(RLOG_OUTDIR)\TraceInput.dll /IMPLIB:$(RLOG_OUTDIR)\TraceInput.lib $(mpich2_libs)")
	mfile.WriteLine("	if exist $(RLOG_OUTDIR)\TraceInput.dll.manifest mt.exe -manifest $(RLOG_OUTDIR)\TraceInput.dll.manifest -outputresource:$(RLOG_OUTDIR)\TraceInput.dll;2")
	mfile.WriteLine
	mfile.WriteLine("TraceInput: $(RLOG_OUTDIR) $(RLOG_OUTDIR)\TraceInput.dll")
	mfile.WriteLine
	mfile.WriteLine("irlog2rlog: $(RLOG_OUTDIR) $(RLOG_OUTDIR)\irlog2rlog.exe")
	mfile.WriteLine

	mfile.WriteLine
	mfile.WriteLine("# mpiexec")
	mfile.WriteLine
	mfile.WriteLine("$(OUTDIR)\mpiexec.obj: ..\src\pm\smpd\mpiexec.c")
	mfile.WriteLine("	$(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" ..\src\pm\smpd\mpiexec.c")
	mfile.WriteLine("$(OUTDIR)\mpiexec_rsh.obj: ..\src\pm\smpd\mpiexec_rsh.c")
	mfile.WriteLine("	$(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" ..\src\pm\smpd\mpiexec_rsh.c")
	mfile.WriteLine("$(OUTDIR)\mp_parse_command_line.obj: ..\src\pm\smpd\mp_parse_command_line.c")
	mfile.WriteLine("	$(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" ..\src\pm\smpd\mp_parse_command_line.c")
	mfile.WriteLine("$(OUTDIR)\mp_parse_oldconfig.obj: ..\src\pm\smpd\mp_parse_oldconfig.c")
	mfile.WriteLine("	$(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" ..\src\pm\smpd\mp_parse_oldconfig.c")
	mfile.WriteLine
	mfile.WriteLine("mpiexec_objs = \")
	mfile.WriteLine("	$(OUTDIR)\mpiexec.obj \")
	mfile.WriteLine("	$(OUTDIR)\mpiexec_rsh.obj \")
	mfile.WriteLine("	$(OUTDIR)\mp_parse_command_line.obj \")
	mfile.WriteLine("	$(OUTDIR)\mp_parse_oldconfig.obj")
	mfile.WriteLine
	mfile.WriteLine("$(BIN_OUTDIR)\mpiexec.exe: $(mpiexec_objs) $(mpich2_objs)")
	mfile.WriteLine("	$(link) $(conlflags) $(mpiexec_objs) $(mpich2_objs) $(ch3sock_objs) $(common_libs) -out:$(BIN_OUTDIR)\mpiexec.exe $(mpich2_libs)")
	mfile.WriteLine("	if exist $(BIN_OUTDIR)\mpiexec.exe.manifest mt.exe -manifest $(BIN_OUTDIR)\mpiexec.exe.manifest -outputresource:$(BIN_OUTDIR)\mpiexec.exe;1")
	mfile.WriteLine
	mfile.WriteLine("mpiexec: $(BIN_OUTDIR) $(BIN_OUTDIR)\mpiexec.exe")

	mfile.WriteLine
	mfile.WriteLine("# smpd")
	mfile.WriteLine
	mfile.WriteLine("$(OUTDIR)\smpd.obj: ..\src\pm\smpd\smpd.c")
	mfile.WriteLine("	$(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" ..\src\pm\smpd\smpd.c")
	mfile.WriteLine("$(OUTDIR)\smpd_cmd_args.obj: ..\src\pm\smpd\smpd_cmd_args.c")
	mfile.WriteLine("	$(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" ..\src\pm\smpd\smpd_cmd_args.c")
	mfile.WriteLine("$(OUTDIR)\smpd_service.obj: ..\src\pm\smpd\smpd_service.c")
	mfile.WriteLine("	$(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" ..\src\pm\smpd\smpd_service.c")
	mfile.WriteLine("$(OUTDIR)\smpd_watchprocs.obj: ..\src\pm\smpd\smpd_watchprocs.c")
	mfile.WriteLine("	$(cc) $(cflags) /Fo""$(OUTDIR)\\"" /Fd""$(OUTDIR)\\"" ..\src\pm\smpd\smpd_watchprocs.c")
	mfile.WriteLine
	mfile.WriteLine("smpd_objs = \")
	mfile.WriteLine("	$(OUTDIR)\smpd.obj \")
	mfile.WriteLine("	$(OUTDIR)\smpd_cmd_args.obj \")
	mfile.WriteLine("	$(OUTDIR)\smpd_service.obj \")
	mfile.WriteLine("	$(OUTDIR)\smpd_watchprocs.obj")
	mfile.WriteLine
	mfile.WriteLine("$(BIN_OUTDIR)\smpd.exe: $(smpd_objs) $(mpich2_objs)")
	mfile.WriteLine("	$(link) $(conlflags) $(smpd_objs) $(mpich2_objs) $(ch3sock_objs) $(common_libs) -out:$(BIN_OUTDIR)\smpd.exe $(mpich2_libs)")
	mfile.WriteLine("	if exist $(BIN_OUTDIR)\smpd.exe.manifest mt.exe -manifest $(BIN_OUTDIR)\smpd.exe.manifest -outputresource:$(BIN_OUTDIR)\smpd.exe;1")
	mfile.WriteLine
	mfile.WriteLine("smpd: $(BIN_OUTDIR) $(BIN_OUTDIR)\smpd.exe")

	mfile.WriteLine
	mfile.WriteLine("# impgen")
	mfile.WriteLine
	mfile.WriteLine("$(GCC_OUTDIR)\gccimpgen.obj: ..\maint\gccimpgen.cpp")
	mfile.WriteLine("	$(cc) $(cflags) /Fo""$(GCC_OUTDIR)\\"" /Fd""$(GCC_OUTDIR)\\"" ..\maint\gccimpgen.cpp")
	mfile.WriteLine
	mfile.WriteLine("$(GCC_OUTDIR)\impgen.exe: $(GCC_OUTDIR)\gccimpgen.obj")
	mfile.WriteLine("	$(link) $(conlflags) $(GCC_OUTDIR)\gccimpgen.obj $(common_libs) -out:$(GCC_OUTDIR)\impgen.exe")
	mfile.WriteLine("	if exist $(GCC_OUTDIR)\impgen.exe.manifest mt.exe -manifest $(GCC_OUTDIR)\impgen.exe.manifest -outputresource:$(GCC_OUTDIR)\impgen.exe;1")
	mfile.WriteLine
	mfile.WriteLine("impgen: $(GCC_OUTDIR) $(GCC_OUTDIR)\impgen.exe")
	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CPU)"" != ""x86""")
	mfile.WriteLine("# Add 64bit gcc stuff here")
	mfile.WriteLine("gcc_libs: $(GCC_OUTDIR)")
	mfile.WriteLine
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("gcc_libs: impgen")
	mfile.WriteLine("	IF EXIST ""$(GCC_OUTDIR)\mpich2gcc$(D).def"" del $(GCC_OUTDIR)\mpich2gcc$(D).def")
	mfile.WriteLine("	$(GCC_OUTDIR)\impgen.exe $(SOCK_OUTDIR)\mpich2$(D).dll > $(GCC_OUTDIR)\mpich2gcc$(D).def")
	mfile.WriteLine("	dlltool --dllname mpich2$(D).dll --def $(GCC_OUTDIR)\mpich2gcc$(D).def --output-lib $(GCC_OUTDIR)\libmpich2$(D).a")
	mfile.WriteLine("	del $(GCC_OUTDIR)\mpich2gcc$(D).def")
	mfile.WriteLine("	IF EXIST ""$(GCC_OUTDIR)\mpich2mpi$(D).def"" del $(GCC_OUTDIR)\mpich2mpi$(D).def")
	mfile.WriteLine("	$(GCC_OUTDIR)\impgen.exe $(MPI_OUTDIR)\mpich2mpi$(D).dll > $(GCC_OUTDIR)\mpich2mpi$(D).def")
	mfile.WriteLine("	dlltool --dllname mpich2mpi$(D).dll --def $(GCC_OUTDIR)\mpich2mpi$(D).def --output-lib $(GCC_OUTDIR)\libmpi$(D).a")
	mfile.WriteLine("	del $(GCC_OUTDIR)\mpich2mpi$(D).def")
	mfile.WriteLine("	IF EXIST ""$(GCC_OUTDIR)\fmpich2gcc$(D).def"" del $(GCC_OUTDIR)\fmpich2gcc$(D).def")
	mfile.WriteLine("	$(GCC_OUTDIR)\impgen.exe $(GFORT_OUTDIR)\fmpich2g$(D).dll > $(GCC_OUTDIR)\fmpich2gcc$(D).def")
	mfile.WriteLine("	dlltool --dllname fmpich2g$(D).dll --def $(GCC_OUTDIR)\fmpich2gcc$(D).def --output-lib $(GCC_OUTDIR)\libfmpich2g$(D).a")
	mfile.WriteLine("	del $(GCC_OUTDIR)\fmpich2gcc$(D).def")
	mfile.WriteLine
	mfile.WriteLine("!ENDIF")

	mfile.WriteLine
	mfile.WriteLine("!IF ""$(CHANNEL)"" == ""sock""")
	mfile.WriteLine("!IFDEF RLOG")
	mfile.WriteLine("all: $(OUTDIR) rlog ch3$(CHANNEL)")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("all: $(OUTDIR) $(BIN_OUTDIR) ch3$(CHANNEL) smpd mpiexec mpi mpe mpe_wrap")
	mfile.WriteLine("!ENDIF")
	mfile.WriteLine("!ELSE")
	mfile.WriteLine("all: $(OUTDIR) ch3$(CHANNEL)")
	mfile.WriteLine("!ENDIF")

	mfile.Close()
End Function

printMsg "STATUS", "Creating makefile & build scripts for MPICH2..."
GenBuild()

Function ParseDirs(filename)
	Dim line, fullline
	'cEcho filename
	Set fin = f.OpenTextFile(filename)
	fullline = ""
	while not fin.AtEndOfStream
		line = MyTrim(fin.ReadLine)
		If Left(line, 1) <> "#" Then
			If Right(line, 1) = "\" Then
				If fullline = "" Then
					fullline = Left(line, len(line)-1)
				Else
					fullline = fullline & " " & Left(line, len(line)-1)
				End If
			Else
				If fullline = "" Then
					fullline = line
				Else
					fullline = fullline & " " & line
				End If
				'OutputLine Right(file.ParentFolder, Len(file.ParentFolder) - trimpath), fullline
				If Left(fullline, 10) = "SUBDIRS = " Then
					line = Right(fullline, Len(fullline) - 10)
					'cEcho line
					fin.Close
					ParseDirs = Split(line)
					Exit Function
				End If
				fullline = ""
			End If
		End If
	wend
	fin.Close
	ParseDirs = Array() ' return an empty array
End Function

Function ParseSrcFiles(filename)
	Dim line, fullline, src_line
	'cEcho filename
	Set fin = f.OpenTextFile(filename)
	fullline = ""
	src_line = ""
	while not fin.AtEndOfStream
		line = MyTrim(fin.ReadLine)
		If Left(line, 1) <> "#" Then
			If Right(line, 1) = "\" Then
				If fullline = "" Then
					fullline = Left(line, len(line)-1)
				Else
					fullline = fullline & " " & Left(line, len(line)-1)
				End If
			Else
				If fullline = "" Then
					fullline = line
				Else
					fullline = fullline & " " & line
				End If
				'OutputLine Right(file.ParentFolder, Len(file.ParentFolder) - trimpath), fullline
				If Left(fullline, 14) = "mpi_sources = " Then
					src_line = src_line & " " & Right(fullline, Len(fullline) - 14)
					'cEcho src_line
				End If
				If Left(fullline, 14) = "win_sources = " Then
					src_line = src_line & " " & Right(fullline, Len(fullline) - 14)
					'cEcho src_line
				End If
				If Left(fullline, 28) = "lib${MPILIBNAME}_a_SOURCES =" Then
					src_line = src_line & " " & Right(fullline, Len(fullline) - 28)
					'cEcho src_line
				End If
				If Left(fullline, 18) = "libmpl_a_SOURCES =" Then
					src_line = src_line & " " & Right(fullline, Len(fullline) - 18)
					'cEcho src_line
				End If
				fullline = ""
			End If
		End If
	wend
	fin.Close
	ParseSrcFiles = Split(src_line)
End Function

Function TraverseSubdir(byref dirname)
	TraverseSubdir = true
	If dirname = "." Then
		TraverseSubdir = false
	End If
	If dirname = "@device_name@" Then
		dirname = "ch3"
	ElseIf dirname = "@channel_name@" Then
		dirname = buildfiles_channel
	ElseIf dirname = "@pm_name@" Then
		dirname = "smpd"
	ElseIf dirname = "@pmi_name@" Then
		dirname = "smpd"
	Elseif Left(dirname, 1) = "@" Then
		TraverseSubdir = false
	End If
	If Left(dirname, 1) = "$" Then
		TraverseSubdir = false
	End If
	If dirname = "" Then
		TraverseSubdir = false
	End If
	If dirname = "binding" Then
		TraverseSubdir = false
	End If
End Function

Function GenBuildFiles(dirname)
	Dim dirs
	Dim dirs_fout, srcs_fout, mfile, first
	first = true
	dirs = ParseDirs(dirname & "\Makefile.sm")
	For Each subdir in dirs
		If TraverseSubdir(subdir) Then
			If remove_buildfiles Then
				If f.FileExists(dirname & "\DIRS") Then
					printMsg "VERBOSE", "del " & dirname & "\DIRS"
					f.DeleteFile(dirname & "\DIRS")
				End If
			Else
				If first Then
					Set dirs_fout = f.CreateTextFile(dirname & "\DIRS", true)
					dirs_fout.Write("DIRS = ")
					first = false
				End If
				dirs_fout.Write("\" & vbCrLf & " " & subdir)
			End If
			'cEcho "subdir: '" & dirname & "\" & subdir & "'"
			GenBuildFiles(dirname & "\" & subdir)
		End If
	Next
	If Not first Then
		dirs_fout.WriteLine
		dirs_fout.Close
		printMsg "VERBOSE", dirname & "\DIRS"
	End If
	If remove_buildfiles Then
		If f.FileExists(dirname & "\SOURCES") Then
			printMsg "VERBOSE", "del " & dirname & "\SOURCES"
			f.DeleteFile(dirname & "\SOURCES")
		End If
		If f.FileExists(dirname & "\makefile") Then
			printMsg "VERBOSE", "del " & dirname & "\makefile"
			f.DeleteFile(dirname & "\makefile")
		End If
	Else
		first = true
		For Each src_filename in ParseSrcFiles(dirname & "\Makefile.sm")
			If CompileFile(src_filename) Then
				'cEcho dirname & "\Makefile.sm" & ": " & src_filename
				If first Then
					Set srcs_fout = f.CreateTextFile(dirname & "\SOURCES")
					srcs_fout.Write("SOURCES = ")
					first = false
				End If
				srcs_fout.Write("\" & vbCrLf & " " & src_filename)
			End If
		Next
		If Not first Then
			srcs_fout.WriteLine
			srcs_fout.WriteLine
			Dim ex, dotdots, includes
			Set ex = New RegExp
			ex.Global = True
			ex.Pattern = "\w+\\"
			dotdots = ex.Replace(dirname & "\", "..\")
			srcs_fout.WriteLine("TARGETPATH=." & dotdots & "obj$(BUILD_ALT_DIR)")
			srcs_fout.WriteLine
			srcs_fout.WriteLine("TARGETTYPE=LIBRARY")'DYNLINK")
			srcs_fout.WriteLine
			srcs_fout.WriteLine("TARGETNAME=mpich2")
			srcs_fout.WriteLine
			srcs_fout.WriteLine("DLLDEF=" & dotdots & "mpich2.def")
			srcs_fout.WriteLine
			includes = dotdots & "src\include;" & _
				dotdots & "src\include\win32;" & _
				dotdots & "src\mpid\ch3\include;" & _
				dotdots & "src\mpid\ch3\channels\" & buildfiles_channel & "\include;" & _
				dotdots & "src\mpid\ch3\channels\" & buildfiles_channel & "\src;" & _
				dotdots & "src\mpid\common\sock;" & _
				dotdots & "src\mpid\common\sock\iocp;" & _
				dotdots & "src\mpi\romio\mpi-io;" & _
				dotdots & "src\mpi\romio\adio\include;" & _
				dotdots & "src\mpid\common\datatype;" & _
				dotdots & "src\mpid\common\locks;" & _
				dotdots & "src\mpi\datatype;" & _
				dotdots & "src\pm\smpd;" & _
				dotdots & "src\mpi\spawn;" & _
				dotdots & "src\binding\f77"
			srcs_fout.WriteLine("INCLUDES=$(INCLUDES);" & includes)
			srcs_fout.WriteLine
			srcs_fout.WriteLine("C_DEFINES=$(C_DEFINES) -DHAVE_WINDOWS_H -DUSE_WINCONF_H -DMPIO_BUILD_PROFILING -DROMIO_INSIDE_MPICH2 -DHAVE_FORTRAN_BINDING -DMPICH_SKIP_MPICXX")
			srcs_fout.WriteLine
			srcs_fout.WriteLine("MSC_WARNING_LEVEL= /W4")
			srcs_fout.WriteLine
			srcs_fout.Close
			printMsg "VERBOSE", dirname & "\SOURCES"
			Set mfile = f.CreateTextFile(dirname & "\makefile")
			mfile.WriteLine("#")
			mfile.WriteLine("# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source file to this component.")
			mfile.WriteLine("#")
			mfile.WriteLine
			mfile.WriteLine("!INCLUDE $(NTMAKEENV)\makefile.def")
			mfile.Close
			printMsg "VERBOSE", dirname & "\makefile"
		End If
	End If
End Function

' Only build these files if specified: "winconfigure --genbuildfiles"
'cEcho "Creating build tool files"
'GenBuildFiles(".")

Function ReplaceBetweenTags(str, tag1, find_str, tag2, replace_str)
	Dim index, left_str, right_str, start_index, end_index
	index = InStr(str, find_str)
	If index = 0 Then
		'MsgBox find_str & " not found in: " & str
		ReplaceBetweenTags = str
		Exit Function
	End If
	left_str = Left(str, index)
	right_str = Right(str, Len(str) - index)
	start_index = InStrRev(left_str, tag1)
	If start_index = 0 Then
		'MsgBox tag1 & " not found in: " & left_str
		ReplaceBetweenTags = str
		Exit Function
	End If
	end_index = InStr(right_str, tag2)
	If end_index = 0 Then
		'MsgBox tag2 & " not found in: " & right_str
		ReplaceBetweenTags = str
		Exit Function
	End If
	end_index = end_index + index
	ReplaceBetweenTags = Left(str, start_index-1) & replace_str & Right(str, Len(str) - end_index - Len(tag2) + 1)
End Function

If bRemoveFortran Then
	'Dim regEx, Match, Matches
	Set regEx = New RegExp
	regEx.IgnoreCase = False
	regEx.Global = True

	' mpich2.def
	'  remove:
	'	MPIPRIV
	'	MPIR_Keyval_set_fortran
	'	MPIR_Keyval_set_fortran90
	'	MPIR_Grequest_set_lang_f77
	Set fin = f.OpenTextFile("mpich2.def")
	contents = fin.ReadAll()
	fin.Close()
	regEx.Pattern = "(.*MPIPRIV.*)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPIR_Keyval_set_fortran)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPIR_Grequest_set_lang_f77)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPIR_F_MPI_BOTTOM)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPI_F_STATUS_IGNORE)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPI_F_STATUSES_IGNORE)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPI_F_ERRCODES_IGNORE)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPI_F_ARGVS_NULL)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*[P]?MPI_Status_c2f)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*[P]?MPI_Status_f2c)"
	contents = regEx.Replace(contents, ";$1")
	'cEcho "Creating mpich2.def"
	gEcho "Creating mpich2.def"
	Set fout = f.CreateTextFile( "mpich2.def" )
	fout.Write(contents)
	fout.Close()

	' mpich2.sln
	'  remove:
	'	Project(..."mpich2f"...EndProject
	'   Project(..."mpich2ff"...EndProject
	'   fortDebug = fortDebug
	'   fortRelease = fortRelease
	'   gfortDebug = gfortDebug
	'   gfortRelease = gfortRelease
	'   sfortDebug = sfortDebug
	'   sfortRelease = sfortRelease
	'   *.fortDebug.*
	'   *.fortRelease.*
	'   *.gfortDebug.*
	'   *.gfortRelease.*
	'   *.sfortDebug.*
	'   *.sfortRelease.*
	'   *= fortDebug|Win32
	'   *= fortRelease|Win32
	'   *= gfortDebug|Win32
	'   *= gfortRelease|Win32
	'   *= sfortDebug|Win32
	'   *= sfortRelease|Win32
	if bVS2005 then
	    Set fin = f.OpenTextFile( "mpich2.vs05.sln" )
	else
	    Set fin = f.OpenTextFile( "mpich2.sln" )
	end if
	contents = fin.ReadAll()
	fin.Close()
	regEx.Pattern = "Project\(.*""mpich2ff?"".*\s*.*\s*.*\s*.*EndProject[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*[gs]?fortDebug = [gs]?fortDebug.*[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*[gs]?fortRelease = [gs]?fortRelease.*[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*\.[gs]*fortDebug\..*[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*\.[gs]*fortRelease\..*[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*= [gs]?fortDebug\|Win32[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*= [gs]?fortRelease\|Win32[\r\n]*"
	contents = regEx.Replace(contents, "")
	if bVS2005 then
		'cEcho "Creating mpich2.vs05.sln"
		gEcho "Creating mpich2.vs05.sln"
	    Set fout = f.CreateTextFile( "mpich2.vs05.sln" )
	else
		'cEcho "Creating mpich2.sln"
		gEcho "Creating mpich2.sln"
	    Set fout = f.CreateTextFile( "mpich2.sln" )
	end if
	fout.Write(contents)
	fout.Close()
	
	' mpich2.vcproj
	'  remove:
	'   ,HAVE_FORTRAN_BINDING
	'   mpich2ffd.lib
	'   mpich2ff.lib
	if bVS2005 then
	    Set fin = f.OpenTextFile( "mpich2.vs05.vcproj" )
	else
	    Set fin = f.OpenTextFile( "mpich2.vcproj" )
	end if
	contents = fin.ReadAll()
	fin.Close()
	contents = Replace(contents, ",HAVE_FORTRAN_BINDING", "")
	contents = Replace(contents, ";HAVE_FORTRAN_BINDING", "")
	contents = Replace(contents, "mpich2ffd.lib", "")
	contents = Replace(contents, "mpich2ff.lib", "")
	'regEx.Pattern = ".*<File.*\s*.*c2f\.c\s*.*</File>.*[\r\n]*"
	'contents = regEx.Replace(contents, "")
	'regEx.Pattern = ".*<File.*\s*.*f2c\.c\s*.*</File>.*[\r\n]*"
	'contents = regEx.Replace(contents, "")
	'regEx.Pattern = ".*<File.*\s*.*setbot\.c.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*</File>.*[\r\n]+"
	'contents = regEx.Replace(contents, "")
	contents = ReplaceBetweenTags(contents, "<File", "statusc2f.c", "</File>", "")
	contents = ReplaceBetweenTags(contents, "<File", "statusf2c.c", "</File>", "")
	contents = ReplaceBetweenTags(contents, "<File", "setbot.c", "</File>", "")
	if bVS2005 then
		'cEcho "Creating mpich2.vs05.vcproj"
		gEcho "Creating mpich2.vs05.vcproj"
	    Set fout = f.CreateTextFile( "mpich2.vs05.vcproj" )
	else
		'cEcho "Creating mpich2.vcproj"
		gEcho "Creating mpich2.vcproj"
	    Set fout = f.CreateTextFile( "mpich2.vcproj" )
	end if
	fout.Write(contents)
	fout.Close()

	' mpich2s.vcproj
	'  remove:
	'   lib\mpich2ffd.lib
	'   lib\mpich2ff.lib
	if bVS2005 then
	    Set fin = f.OpenTextFile( "mpich2s.vs05.vcproj" )
	else
	    Set fin = f.OpenTextFile( "mpich2s.vcproj" )
	end if
	contents = fin.ReadAll()
	fin.Close()
	contents = Replace(contents, ",HAVE_FORTRAN_BINDING", "")
	contents = Replace(contents, ";HAVE_FORTRAN_BINDING", "")
	contents = Replace(contents, "lib\mpich2ffd.lib", "")
	contents = Replace(contents, "lib\mpich2ff.lib", "")
	'regEx.Pattern = ".*<File.*\s*.*c2f\.c\s*.*</File>.*[\r\n]*"
	'contents = regEx.Replace(contents, "")
	'regEx.Pattern = ".*<File.*\s*.*f2c\.c\s*.*</File>.*[\r\n]*"
	'contents = regEx.Replace(contents, "")
	'regEx.Pattern = ".*<File.*\s*.*setbot\.c.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*</File>.*[\r\n]+"
	'contents = regEx.Replace(contents, "")
	contents = ReplaceBetweenTags(contents, "<File", "statusc2f.c", "</File>", "")
	contents = ReplaceBetweenTags(contents, "<File", "statusf2c.c", "</File>", "")
	contents = ReplaceBetweenTags(contents, "<File", "setbot.c", "</File>", "")
	if bVS2005 then
		'cEcho "Creating mpich2s.vs05.vcproj"
		gEcho "Creating mpich2s.vs05.vcproj"
	    Set fout = f.CreateTextFile( "mpich2s.vs05.vcproj" )
	else
		'cEcho "Creating mpich2s.vcproj"
		gEcho "Creating mpich2s.vcproj"
	    Set fout = f.CreateTextFile( "mpich2s.vcproj" )
	end if
	fout.Write(contents)
	fout.Close()

	' maint\mpich2i.vdproj
	'  remove:
	'   lots of stuff
End If

Sub UpdateSMPDVersion
        GetMPICH2Versions mpich2VerStr, mpich2ABIVerStr, mpich2ReleaseDate
	printMsg "VERBOSE", "Creating src\pm\smpd\smpd_version.h"
	Set fout = f.CreateTextFile("src\pm\smpd\smpd_version.h", true)
	fout.WriteLine("#define SMPD_VERSION """ & mpich2VerStr & """")
	fout.Close()
End Sub

Call UpdateSMPDVersion()

'
' Report any errors
'
If unhandled_definitions <> "" Then
	printMsg "ERROR", "Unhandled definitions" & vbNewLine & unhandled_definitions
	printMsg "ERROR", "ERROR: " & unhandled_definitions_count & " definitions not handled"
	printMsg "ERROR", "(" & unhandled_definitions_instances & " instances of unhandled definitions)"
End If
If unhandled_ats <> "" Then
	printMsg "ERROR", "Unhandled @foo@'s:" & vbNewLine & unhandled_ats
	printMsg "ERROR", "ERROR: " & unhandled_ats_count & " @foo@'s not handled"
	printMsg "ERROR", "(" & unhandled_ats_instances & " instances of unhandled @foo@'s)"
End If
printMsg "STATUS", "Configuring MPICH2 completed"
printMsgFlush

</script>
</job>
</package>
